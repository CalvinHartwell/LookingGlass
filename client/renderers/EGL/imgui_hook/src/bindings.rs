/* automatically generated by rust-bindgen 0.54.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __LINUX__: u32 = 1;
pub const SIZEOF_VOIDP: u32 = 8;
pub const HAVE_GCC_ATOMICS: u32 = 1;
pub const HAVE_LIBC: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_CTYPE_H: u32 = 1;
pub const HAVE_ICONV_H: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_MATH_H: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_SIGNAL_H: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_WCHAR_H: u32 = 1;
pub const HAVE_LIBUNWIND_H: u32 = 1;
pub const HAVE_MALLOC: u32 = 1;
pub const HAVE_CALLOC: u32 = 1;
pub const HAVE_REALLOC: u32 = 1;
pub const HAVE_FREE: u32 = 1;
pub const HAVE_GETENV: u32 = 1;
pub const HAVE_SETENV: u32 = 1;
pub const HAVE_PUTENV: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_QSORT: u32 = 1;
pub const HAVE_ABS: u32 = 1;
pub const HAVE_BCOPY: u32 = 1;
pub const HAVE_MEMSET: u32 = 1;
pub const HAVE_MEMCPY: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_MEMCMP: u32 = 1;
pub const HAVE_WCSLEN: u32 = 1;
pub const HAVE_WCSDUP: u32 = 1;
pub const HAVE_WCSSTR: u32 = 1;
pub const HAVE_WCSCMP: u32 = 1;
pub const HAVE_WCSNCMP: u32 = 1;
pub const HAVE_STRLEN: u32 = 1;
pub const HAVE_STRCHR: u32 = 1;
pub const HAVE_STRRCHR: u32 = 1;
pub const HAVE_STRSTR: u32 = 1;
pub const HAVE_STRTOK_R: u32 = 1;
pub const HAVE_STRTOL: u32 = 1;
pub const HAVE_STRTOUL: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRTOD: u32 = 1;
pub const HAVE_ATOI: u32 = 1;
pub const HAVE_ATOF: u32 = 1;
pub const HAVE_STRCMP: u32 = 1;
pub const HAVE_STRNCMP: u32 = 1;
pub const HAVE_STRCASECMP: u32 = 1;
pub const HAVE_STRNCASECMP: u32 = 1;
pub const HAVE_SSCANF: u32 = 1;
pub const HAVE_VSSCANF: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE_M_PI: u32 = 1;
pub const HAVE_ACOS: u32 = 1;
pub const HAVE_ACOSF: u32 = 1;
pub const HAVE_ASIN: u32 = 1;
pub const HAVE_ASINF: u32 = 1;
pub const HAVE_ATAN: u32 = 1;
pub const HAVE_ATANF: u32 = 1;
pub const HAVE_ATAN2: u32 = 1;
pub const HAVE_ATAN2F: u32 = 1;
pub const HAVE_CEIL: u32 = 1;
pub const HAVE_CEILF: u32 = 1;
pub const HAVE_COPYSIGN: u32 = 1;
pub const HAVE_COPYSIGNF: u32 = 1;
pub const HAVE_COS: u32 = 1;
pub const HAVE_COSF: u32 = 1;
pub const HAVE_EXP: u32 = 1;
pub const HAVE_EXPF: u32 = 1;
pub const HAVE_FABS: u32 = 1;
pub const HAVE_FABSF: u32 = 1;
pub const HAVE_FLOOR: u32 = 1;
pub const HAVE_FLOORF: u32 = 1;
pub const HAVE_FMOD: u32 = 1;
pub const HAVE_FMODF: u32 = 1;
pub const HAVE_LOG: u32 = 1;
pub const HAVE_LOGF: u32 = 1;
pub const HAVE_LOG10: u32 = 1;
pub const HAVE_LOG10F: u32 = 1;
pub const HAVE_POW: u32 = 1;
pub const HAVE_POWF: u32 = 1;
pub const HAVE_SCALBN: u32 = 1;
pub const HAVE_SCALBNF: u32 = 1;
pub const HAVE_SIN: u32 = 1;
pub const HAVE_SINF: u32 = 1;
pub const HAVE_SQRT: u32 = 1;
pub const HAVE_SQRTF: u32 = 1;
pub const HAVE_TAN: u32 = 1;
pub const HAVE_TANF: u32 = 1;
pub const HAVE_FOPEN64: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FSEEKO64: u32 = 1;
pub const HAVE_SIGACTION: u32 = 1;
pub const HAVE_SA_SIGACTION: u32 = 1;
pub const HAVE_SETJMP: u32 = 1;
pub const HAVE_NANOSLEEP: u32 = 1;
pub const HAVE_SYSCONF: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_MPROTECT: u32 = 1;
pub const HAVE_PTHREAD_SETNAME_NP: u32 = 1;
pub const HAVE_SEM_TIMEDWAIT: u32 = 1;
pub const HAVE_GETAUXVAL: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE__EXIT: u32 = 1;
pub const HAVE_DBUS_DBUS_H: u32 = 1;
pub const HAVE_FCITX_FRONTEND_H: u32 = 1;
pub const HAVE_IBUS_IBUS_H: u32 = 1;
pub const HAVE_IMMINTRIN_H: u32 = 1;
pub const HAVE_LIBSAMPLERATE_H: u32 = 1;
pub const HAVE_LIBUDEV_H: u32 = 1;
pub const HAVE_XINPUT_H: u32 = 1;
pub const SDL_AUDIO_DRIVER_ALSA: u32 = 1;
pub const SDL_AUDIO_DRIVER_ALSA_DYNAMIC: &'static [u8; 15usize] = b"libasound.so.2\0";
pub const SDL_AUDIO_DRIVER_DISK: u32 = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_AUDIO_DRIVER_JACK: u32 = 1;
pub const SDL_AUDIO_DRIVER_JACK_DYNAMIC: &'static [u8; 13usize] = b"libjack.so.0\0";
pub const SDL_AUDIO_DRIVER_OSS: u32 = 1;
pub const SDL_AUDIO_DRIVER_PULSEAUDIO: u32 = 1;
pub const SDL_AUDIO_DRIVER_PULSEAUDIO_DYNAMIC: &'static [u8; 21usize] = b"libpulse-simple.so.0\0";
pub const SDL_INPUT_LINUXEV: u32 = 1;
pub const SDL_INPUT_LINUXKD: u32 = 1;
pub const SDL_JOYSTICK_LINUX: u32 = 1;
pub const SDL_JOYSTICK_HIDAPI: u32 = 1;
pub const SDL_HAPTIC_LINUX: u32 = 1;
pub const SDL_LIBUSB_DYNAMIC: &'static [u8; 1usize] = b"\0";
pub const SDL_SENSOR_DUMMY: u32 = 1;
pub const SDL_LOADSO_DLOPEN: u32 = 1;
pub const SDL_THREAD_PTHREAD: u32 = 1;
pub const SDL_THREAD_PTHREAD_RECURSIVE_MUTEX: u32 = 1;
pub const SDL_TIMER_UNIX: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_VIDEO_DRIVER_WAYLAND: u32 = 1;
pub const SDL_VIDEO_DRIVER_KMSDRM: u32 = 1;
pub const SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC: &'static [u8; 12usize] = b"libdrm.so.2\0";
pub const SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM: &'static [u8; 12usize] = b"libgbm.so.1\0";
pub const SDL_VIDEO_DRIVER_WAYLAND_QT_TOUCH: u32 = 1;
pub const SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC: &'static [u8; 23usize] = b"libwayland-client.so.0\0";
pub const SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_EGL: &'static [u8; 20usize] = b"libwayland-egl.so.1\0";
pub const SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_CURSOR: &'static [u8; 23usize] =
    b"libwayland-cursor.so.0\0";
pub const SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_XKBCOMMON: &'static [u8; 18usize] =
    b"libxkbcommon.so.0\0";
pub const SDL_VIDEO_DRIVER_X11: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC: &'static [u8; 12usize] = b"libX11.so.6\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT: &'static [u8; 13usize] = b"libXext.so.6\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR: &'static [u8; 16usize] = b"libXcursor.so.1\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XINERAMA: &'static [u8; 17usize] = b"libXinerama.so.1\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2: &'static [u8; 11usize] = b"libXi.so.6\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR: &'static [u8; 15usize] = b"libXrandr.so.2\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS: &'static [u8; 12usize] = b"libXss.so.1\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XVIDMODE: &'static [u8; 16usize] = b"libXxf86vm.so.1\0";
pub const SDL_VIDEO_DRIVER_X11_XCURSOR: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINERAMA: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINPUT2: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XRANDR: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XSCRNSAVER: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XSHAPE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XVIDMODE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_CONST_PARAM_XEXTADDDISPLAY: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL_GLX: u32 = 1;
pub const SDL_VIDEO_OPENGL_EGL: u32 = 1;
pub const SDL_VIDEO_VULKAN: u32 = 1;
pub const SDL_POWER_LINUX: u32 = 1;
pub const SDL_FILESYSTEM_UNIX: u32 = 1;
pub const SDL_ASSEMBLY_ROUTINES: u32 = 1;
pub const SDL_LIBSAMPLERATE_DYNAMIC: &'static [u8; 19usize] = b"libsamplerate.so.0\0";
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _CTYPE_H: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
// pub const FP_NAN: u32 = 0;
// pub const FP_INFINITE: u32 = 1;
// pub const FP_ZERO: u32 = 2;
// pub const FP_SUBNORMAL: u32 = 3;
// pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const SDL_PRIs64: &'static [u8; 3usize] = b"ld\0";
pub const SDL_PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const SDL_PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const SDL_PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_AUDIOCVT_MAX_FILTERS: u32 = 9;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_SIMD_ALIGNED: u32 = 8;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
    b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
    b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &'static [u8; 28usize] =
    b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &'static [u8; 29usize] =
    b"SDL_RENDER_LOGICAL_SIZE_MODE\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
    b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_EXTERNAL_CONTEXT: &'static [u8; 27usize] = b"SDL_VIDEO_EXTERNAL_CONTEXT\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VIDEO_X11_WINDOW_VISUALID: &'static [u8; 30usize] =
    b"SDL_VIDEO_X11_WINDOW_VISUALID\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &'static [u8; 26usize] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &'static [u8; 39usize] =
    b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_VIDEO_X11_FORCE_EGL: &'static [u8; 24usize] = b"SDL_VIDEO_X11_FORCE_EGL\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &'static [u8; 44usize] =
    b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &'static [u8; 29usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &'static [u8; 35usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &'static [u8; 31usize] =
    b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &'static [u8; 28usize] =
    b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &'static [u8; 30usize] =
    b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &'static [u8; 29usize] =
    b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &'static [u8; 31usize] =
    b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
    b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &'static [u8; 29usize] =
    b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &'static [u8; 23usize] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_MOUSE_TOUCH_EVENTS: &'static [u8; 23usize] = b"SDL_MOUSE_TOUCH_EVENTS\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
    b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &'static [u8; 34usize] =
    b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &'static [u8; 35usize] =
    b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &'static [u8; 28usize] =
    b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
    b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &'static [u8; 26usize] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &'static [u8; 36usize] =
    b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_GAMECONTROLLERTYPE: &'static [u8; 23usize] = b"SDL_GAMECONTROLLERTYPE\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG_FILE: &'static [u8; 30usize] =
    b"SDL_GAMECONTROLLERCONFIG_FILE\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &'static [u8; 34usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &'static [u8; 41usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS: &'static [u8; 37usize] =
    b"SDL_GAMECONTROLLER_USE_BUTTON_LABELS\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &'static [u8; 20usize] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &'static [u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &'static [u8; 31usize] =
    b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &'static [u8; 26usize] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &'static [u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &'static [u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE: &'static [u8; 29usize] =
    b"SDL_JOYSTICK_HIDAPI_GAMECUBE\0";
pub const SDL_HINT_ENABLE_STEAM_CONTROLLERS: &'static [u8; 29usize] =
    b"SDL_ENABLE_STEAM_CONTROLLERS\0";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &'static [u8; 34usize] =
    b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &'static [u8; 27usize] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &'static [u8; 22usize] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize] =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
    b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &'static [u8; 29usize] =
    b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &'static [u8; 31usize] =
    b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &'static [u8; 29usize] =
    b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
    b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &'static [u8; 23usize] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION: &'static [u8; 44usize] =
    b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION: &'static [u8; 45usize] =
    b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &'static [u8; 25usize] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &'static [u8; 29usize] =
    b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE: &'static [u8; 27usize] = b"SDL_ANDROID_BLOCK_ON_PAUSE\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &'static [u8; 25usize] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &'static [u8; 32usize] =
    b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &'static [u8; 23usize] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &'static [u8; 31usize] =
    b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &'static [u8; 27usize] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &'static [u8; 34usize] =
    b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &'static [u8; 20usize] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &'static [u8; 24usize] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &'static [u8; 21usize] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &'static [u8; 26usize] = b"SDL_AUDIO_RESAMPLING_MODE\0";
pub const SDL_HINT_AUDIO_CATEGORY: &'static [u8; 19usize] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_HINT_RENDER_BATCHING: &'static [u8; 20usize] = b"SDL_RENDER_BATCHING\0";
pub const SDL_HINT_EVENT_LOGGING: &'static [u8; 18usize] = b"SDL_EVENT_LOGGING\0";
pub const SDL_HINT_WAVE_RIFF_CHUNK_SIZE: &'static [u8; 25usize] = b"SDL_WAVE_RIFF_CHUNK_SIZE\0";
pub const SDL_HINT_WAVE_TRUNCATION: &'static [u8; 20usize] = b"SDL_WAVE_TRUNCATION\0";
pub const SDL_HINT_WAVE_FACT_CHUNK: &'static [u8; 20usize] = b"SDL_WAVE_FACT_CHUNK\0";
pub const SDL_HINT_DISPLAY_USABLE_BOUNDS: &'static [u8; 26usize] = b"SDL_DISPLAY_USABLE_BOUNDS\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 12;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 62001;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
extern "C" {
    #[doc = "  \\brief Gets the name of the platform."]
    pub fn SDL_GetPlatform() -> *const ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type wint_t = ::std::os::raw::c_uint;
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(
        __wcs: *const ::std::os::raw::c_int,
        __wc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn wmemchr(
        __s: *const ::std::os::raw::c_int,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemmove(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t, __ps: *mut mbstate_t)
        -> size_t;
}
extern "C" {
    pub fn __mbrlen(
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: size_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: size_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __nwc: size_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut size_t) -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: size_t,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> size_t;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = u32;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_2 = 0;
pub const FP_INFINITE: _bindgen_ty_2 = 1;
pub const FP_ZERO: _bindgen_ty_2 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_2 = 3;
pub const FP_NORMAL: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = u32;
pub const SDL_bool_SDL_FALSE: SDL_bool = 0;
pub const SDL_bool_SDL_TRUE: SDL_bool = 1;
pub type SDL_bool = u32;
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [::std::os::raw::c_int; 1usize];
pub const SDL_DUMMY_ENUM_DUMMY_ENUM_VALUE: SDL_DUMMY_ENUM = 0;
pub type SDL_DUMMY_ENUM = u32;
pub type SDL_compile_time_assert_enum = [::std::os::raw::c_int; 1usize];
extern "C" {
    pub fn SDL_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_realloc(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_free(mem: *mut ::std::os::raw::c_void);
}
pub type SDL_malloc_func =
    ::std::option::Option<unsafe extern "C" fn(size: size_t) -> *mut ::std::os::raw::c_void>;
pub type SDL_calloc_func = ::std::option::Option<
    unsafe extern "C" fn(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void,
>;
pub type SDL_realloc_func = ::std::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type SDL_free_func =
    ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = "  \\brief Get the current set of SDL memory functions"]
    pub fn SDL_GetMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
extern "C" {
    #[doc = "  \\brief Replace SDL's memory allocation functions with a custom set"]
    #[doc = ""]
    #[doc = "  \\note If you are replacing SDL's memory functions, you should call"]
    #[doc = "        SDL_GetNumAllocations() and be very careful if it returns non-zero."]
    #[doc = "        That means that your free function will be called with memory"]
    #[doc = "        allocated by the previous memory allocation functions."]
    pub fn SDL_SetMemoryFunctions(
        malloc_func: SDL_malloc_func,
        calloc_func: SDL_calloc_func,
        realloc_func: SDL_realloc_func,
        free_func: SDL_free_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the number of outstanding (unfreed) allocations"]
    pub fn SDL_GetNumAllocations() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_getenv(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_qsort(
        base: *mut ::std::os::raw::c_void,
        nmemb: size_t,
        size: size_t,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SDL_abs(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isdigit(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isspace(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isupper(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_islower(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_toupper(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_tolower(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_memset(
        dst: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memcmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcsstr(haystack: *const wchar_t, needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_wcsncmp(
        str1: *const wchar_t,
        str2: *const wchar_t,
        maxlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strlen(str_: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn SDL_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        maxlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_utf8strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_bytes: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        maxlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_strdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strrev(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strupr(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strlwr(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strchr(
        str_: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strrchr(
        str_: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strtokr(
        s1: *mut ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        saveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_utf8strlen(str_: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn SDL_itoa(
        value: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_uitoa(
        value: ::std::os::raw::c_uint,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ltoa(
        value: ::std::os::raw::c_long,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ultoa(
        value: ::std::os::raw::c_ulong,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_lltoa(
        value: Sint64,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(
        value: Uint64,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_atoi(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_atof(str_: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strtol(
        str_: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SDL_strtoul(
        str_: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SDL_strtoll(
        str_: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> Sint64;
}
extern "C" {
    pub fn SDL_strtoull(
        str_: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> Uint64;
}
extern "C" {
    pub fn SDL_strtod(
        str_: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn SDL_strcmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strncmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        maxlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strcasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strncasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_sscanf(
        text: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_vsscanf(
        text: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_snprintf(
        text: *mut ::std::os::raw::c_char,
        maxlen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_vsnprintf(
        text: *mut ::std::os::raw::c_char,
        maxlen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan2f(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_scalbn(x: f64, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn SDL_scalbnf(x: f32, n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_iconv_t {
    _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
    pub fn SDL_iconv_open(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
    ) -> SDL_iconv_t;
}
extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const ::std::os::raw::c_char,
        inbytesleft: *mut size_t,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbytesleft: *mut size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = "  This function converts a string between encodings in one pass, returning a"]
    #[doc = "  string that must be freed with SDL_free() or NULL on error."]
    pub fn SDL_iconv_string(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
        inbuf: *const ::std::os::raw::c_char,
        inbytesleft: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = "  The prototype for the application's main() function"]
pub type SDL_main_func = ::std::option::Option<
    unsafe extern "C" fn(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SDL_main(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This is called by the real SDL main function to let the rest of the"]
    #[doc = "  library know that initialization was done properly."]
    #[doc = ""]
    #[doc = "  Calling this yourself without knowing what you're doing can cause"]
    #[doc = "  crashes and hard to diagnose problems with your application."]
    pub fn SDL_SetMainReady();
}
#[doc = "< Retry the assert immediately."]
pub const SDL_AssertState_SDL_ASSERTION_RETRY: SDL_AssertState = 0;
#[doc = "< Make the debugger trigger a breakpoint."]
pub const SDL_AssertState_SDL_ASSERTION_BREAK: SDL_AssertState = 1;
#[doc = "< Terminate the program."]
pub const SDL_AssertState_SDL_ASSERTION_ABORT: SDL_AssertState = 2;
#[doc = "< Ignore the assert."]
pub const SDL_AssertState_SDL_ASSERTION_IGNORE: SDL_AssertState = 3;
#[doc = "< Ignore the assert from now on."]
pub const SDL_AssertState_SDL_ASSERTION_ALWAYS_IGNORE: SDL_AssertState = 4;
pub type SDL_AssertState = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AssertData {
    pub always_ignore: ::std::os::raw::c_int,
    pub trigger_count: ::std::os::raw::c_uint,
    pub condition: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub linenum: ::std::os::raw::c_int,
    pub function: *const ::std::os::raw::c_char,
    pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AssertData>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AssertData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).always_ignore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(always_ignore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).trigger_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(trigger_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).condition as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).linenum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(linenum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).function as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AssertData>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn SDL_ReportAssertion(
        arg1: *mut SDL_AssertData,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> SDL_AssertState;
}
pub type SDL_AssertionHandler = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const SDL_AssertData,
        userdata: *mut ::std::os::raw::c_void,
    ) -> SDL_AssertState,
>;
extern "C" {
    #[doc = "  \\brief Set an application-defined assertion handler."]
    #[doc = ""]
    #[doc = "  This allows an app to show its own assertion UI and/or force the"]
    #[doc = "  response to an assertion failure. If the app doesn't provide this, SDL"]
    #[doc = "  will try to do the right thing, popping up a system-specific GUI dialog,"]
    #[doc = "  and probably minimizing any fullscreen windows."]
    #[doc = ""]
    #[doc = "  This callback may fire from any thread, but it runs wrapped in a mutex, so"]
    #[doc = "  it will only fire from one thread at a time."]
    #[doc = ""]
    #[doc = "  Setting the callback to NULL restores SDL's original internal handler."]
    #[doc = ""]
    #[doc = "  This callback is NOT reset to SDL's internal handler upon SDL_Quit()!"]
    #[doc = ""]
    #[doc = "  Return SDL_AssertState value of how to handle the assertion failure."]
    #[doc = ""]
    #[doc = "  \\param handler Callback function, called when an assertion fails."]
    #[doc = "  \\param userdata A pointer passed to the callback as-is."]
    pub fn SDL_SetAssertionHandler(
        handler: SDL_AssertionHandler,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief Get the default assertion handler."]
    #[doc = ""]
    #[doc = "  This returns the function pointer that is called by default when an"]
    #[doc = "   assertion is triggered. This is an internal function provided by SDL,"]
    #[doc = "   that is used for assertions when SDL_SetAssertionHandler() hasn't been"]
    #[doc = "   used to provide a different function."]
    #[doc = ""]
    #[doc = "  \\return The default SDL_AssertionHandler that is called when an assert triggers."]
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = "  \\brief Get the current assertion handler."]
    #[doc = ""]
    #[doc = "  This returns the function pointer that is called when an assertion is"]
    #[doc = "   triggered. This is either the value last passed to"]
    #[doc = "   SDL_SetAssertionHandler(), or if no application-specified function is"]
    #[doc = "   set, is equivalent to calling SDL_GetDefaultAssertionHandler()."]
    #[doc = ""]
    #[doc = "   \\param puserdata Pointer to a void*, which will store the \"userdata\""]
    #[doc = "                    pointer that was passed to SDL_SetAssertionHandler()."]
    #[doc = "                    This value will always be NULL for the default handler."]
    #[doc = "                    If you don't care about this data, it is safe to pass"]
    #[doc = "                    a NULL pointer to this function to ignore it."]
    #[doc = "  \\return The SDL_AssertionHandler that is called when an assert triggers."]
    pub fn SDL_GetAssertionHandler(
        puserdata: *mut *mut ::std::os::raw::c_void,
    ) -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = "  \\brief Get a list of all assertion failures."]
    #[doc = ""]
    #[doc = "  Get all assertions triggered since last call to SDL_ResetAssertionReport(),"]
    #[doc = "  or the start of the program."]
    #[doc = ""]
    #[doc = "  The proper way to examine this data looks something like this:"]
    #[doc = ""]
    #[doc = "  <code>"]
    #[doc = "  const SDL_AssertData *item = SDL_GetAssertionReport();"]
    #[doc = "  while (item) {"]
    #[doc = "      printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\","]
    #[doc = "             item->condition, item->function, item->filename,"]
    #[doc = "             item->linenum, item->trigger_count,"]
    #[doc = "             item->always_ignore ? \"yes\" : \"no\");"]
    #[doc = "      item = item->next;"]
    #[doc = "  }"]
    #[doc = "  </code>"]
    #[doc = ""]
    #[doc = "  \\return List of all assertions."]
    #[doc = "  \\sa SDL_ResetAssertionReport"]
    pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
    #[doc = "  \\brief Reset the list of all assertion failures."]
    #[doc = ""]
    #[doc = "  Reset list of all assertions triggered."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetAssertionReport"]
    pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = ::std::os::raw::c_int;
extern "C" {
    #[doc = " \\brief Try to lock a spin lock by setting it to a non-zero value."]
    #[doc = ""]
    #[doc = " \\param lock Points to the lock."]
    #[doc = ""]
    #[doc = " \\return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held."]
    pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Lock a spin lock by setting it to a non-zero value."]
    #[doc = ""]
    #[doc = " \\param lock Points to the lock."]
    pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " \\brief Unlock a spin lock by setting it to 0. Always returns immediately"]
    #[doc = ""]
    #[doc = " \\param lock Points to the lock."]
    pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " Memory barriers are designed to prevent reads and writes from being"]
    #[doc = " reordered by the compiler and being seen out of order on multi-core CPUs."]
    #[doc = ""]
    #[doc = " A typical pattern would be for thread A to write some data and a flag,"]
    #[doc = " and for thread B to read the flag and get the data. In this case you"]
    #[doc = " would insert a release barrier between writing the data and the flag,"]
    #[doc = " guaranteeing that the data write completes no later than the flag is"]
    #[doc = " written, and you would insert an acquire barrier between reading the"]
    #[doc = " flag and reading the data, to ensure that all the reads associated"]
    #[doc = " with the flag have completed."]
    #[doc = ""]
    #[doc = " In this pattern you should always see a release barrier paired with"]
    #[doc = " an acquire barrier and you should gate the data reads/writes with a"]
    #[doc = " single flag variable."]
    #[doc = ""]
    #[doc = " For more information on these semantics, take a look at the blog post:"]
    #[doc = " http://preshing.com/20120913/acquire-and-release-semantics"]
    pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
    pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " \\brief A type representing an atomic integer value.  It is a struct"]
#[doc = "        so people don't accidentally use numeric operations on it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_atomic_t {
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<SDL_atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_atomic_t>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_atomic_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " \\brief Set an atomic variable to a new value if it is currently an old value."]
    #[doc = ""]
    #[doc = " \\return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\note If you don't know what this function is for, you shouldn't use it!"]
    pub fn SDL_AtomicCAS(
        a: *mut SDL_atomic_t,
        oldval: ::std::os::raw::c_int,
        newval: ::std::os::raw::c_int,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Set an atomic variable to a value."]
    #[doc = ""]
    #[doc = " \\return The previous value of the atomic variable."]
    pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the value of an atomic variable"]
    pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add to an atomic variable."]
    #[doc = ""]
    #[doc = " \\return The previous value of the atomic variable."]
    #[doc = ""]
    #[doc = " \\note This same style can be used for any number operation"]
    pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set a pointer to a new value if it is currently an old value."]
    #[doc = ""]
    #[doc = " \\return SDL_TRUE if the pointer was set, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\note If you don't know what this function is for, you shouldn't use it!"]
    pub fn SDL_AtomicCASPtr(
        a: *mut *mut ::std::os::raw::c_void,
        oldval: *mut ::std::os::raw::c_void,
        newval: *mut ::std::os::raw::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Set a pointer to a value atomically."]
    #[doc = ""]
    #[doc = " \\return The previous value of the pointer."]
    pub fn SDL_AtomicSetPtr(
        a: *mut *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Get the value of a pointer atomically."]
    pub fn SDL_AtomicGetPtr(a: *mut *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_SetError(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ClearError();
}
pub const SDL_errorcode_SDL_ENOMEM: SDL_errorcode = 0;
pub const SDL_errorcode_SDL_EFREAD: SDL_errorcode = 1;
pub const SDL_errorcode_SDL_EFWRITE: SDL_errorcode = 2;
pub const SDL_errorcode_SDL_EFSEEK: SDL_errorcode = 3;
pub const SDL_errorcode_SDL_UNSUPPORTED: SDL_errorcode = 4;
pub const SDL_errorcode_SDL_LASTERROR: SDL_errorcode = 5;
pub type SDL_errorcode = u32;
extern "C" {
    pub fn SDL_Error(code: SDL_errorcode) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  Create a mutex, initialized unlocked."]
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
    pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Try to lock the mutex"]
    #[doc = ""]
    #[doc = "  \\return 0, SDL_MUTEX_TIMEDOUT, or -1 on error"]
    pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Destroy a mutex."]
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
    _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
    #[doc = "  Create a semaphore, initialized with value, returns NULL on failure."]
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
    #[doc = "  Destroy a semaphore."]
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
    #[doc = "  This function suspends the calling thread until the semaphore pointed"]
    #[doc = "  to by \\c sem has a positive count. It then atomically decreases the"]
    #[doc = "  semaphore count."]
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Non-blocking variant of SDL_SemWait()."]
    #[doc = ""]
    #[doc = "  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would"]
    #[doc = "          block, and -1 on error."]
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Variant of SDL_SemWait() with a timeout in milliseconds."]
    #[doc = ""]
    #[doc = "  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not"]
    #[doc = "          succeed in the allotted time, and -1 on error."]
    #[doc = ""]
    #[doc = "  \\warning On some platforms this function is implemented by looping with a"]
    #[doc = "           delay of 1 ms, and so should be avoided if possible."]
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Atomically increases the semaphore's count (not blocking)."]
    #[doc = ""]
    #[doc = "  \\return 0, or -1 on error."]
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Returns the current count of the semaphore."]
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  Create a condition variable."]
    #[doc = ""]
    #[doc = "  Typical use of condition variables:"]
    #[doc = ""]
    #[doc = "  Thread A:"]
    #[doc = "    SDL_LockMutex(lock);"]
    #[doc = "    while ( ! condition ) {"]
    #[doc = "        SDL_CondWait(cond, lock);"]
    #[doc = "    }"]
    #[doc = "    SDL_UnlockMutex(lock);"]
    #[doc = ""]
    #[doc = "  Thread B:"]
    #[doc = "    SDL_LockMutex(lock);"]
    #[doc = "    ..."]
    #[doc = "    condition = true;"]
    #[doc = "    ..."]
    #[doc = "    SDL_CondSignal(cond);"]
    #[doc = "    SDL_UnlockMutex(lock);"]
    #[doc = ""]
    #[doc = "  There is some discussion whether to signal the condition variable"]
    #[doc = "  with the mutex locked or not.  There is some potential performance"]
    #[doc = "  benefit to unlocking first on some platforms, but there are some"]
    #[doc = "  potential race conditions depending on how your code is structured."]
    #[doc = ""]
    #[doc = "  In general it's safer to signal the condition variable while the"]
    #[doc = "  mutex is locked."]
    pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
    #[doc = "  Destroy a condition variable."]
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
    #[doc = "  Restart one of the threads that are waiting on the condition variable."]
    #[doc = ""]
    #[doc = "  \\return 0 or -1 on error."]
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Restart all threads that are waiting on the condition variable."]
    #[doc = ""]
    #[doc = "  \\return 0 or -1 on error."]
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Wait on the condition variable, unlocking the provided mutex."]
    #[doc = ""]
    #[doc = "  \\warning The mutex must be locked before entering this function!"]
    #[doc = ""]
    #[doc = "  The mutex is re-locked once the condition variable is signaled."]
    #[doc = ""]
    #[doc = "  \\return 0 when it is signaled, or -1 on error."]
    pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Waits for at most \\c ms milliseconds, and returns 0 if the condition"]
    #[doc = "  variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not"]
    #[doc = "  signaled in the allotted time, and -1 on error."]
    #[doc = ""]
    #[doc = "  \\warning On some platforms this function is implemented by looping with a"]
    #[doc = "           delay of 1 ms, and so should be avoided if possible."]
    pub fn SDL_CondWaitTimeout(
        cond: *mut SDL_cond,
        mutex: *mut SDL_mutex,
        ms: Uint32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
pub type SDL_threadID = ::std::os::raw::c_ulong;
pub type SDL_TLSID = ::std::os::raw::c_uint;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_LOW: SDL_ThreadPriority = 0;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_NORMAL: SDL_ThreadPriority = 1;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_HIGH: SDL_ThreadPriority = 2;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_TIME_CRITICAL: SDL_ThreadPriority = 3;
#[doc = "  The SDL thread priority."]
#[doc = ""]
#[doc = "  \\note On many systems you require special privileges to set high or time critical priority."]
pub type SDL_ThreadPriority = u32;
#[doc = "  The function passed to SDL_CreateThread()."]
#[doc = "  It is passed a void* user context parameter and returns an int."]
pub type SDL_ThreadFunction = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "  Create a thread with a default stack size."]
    #[doc = ""]
    #[doc = "  This is equivalent to calling:"]
    #[doc = "  SDL_CreateThreadWithStackSize(fn, name, 0, data);"]
    pub fn SDL_CreateThread(
        fn_: SDL_ThreadFunction,
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = "  Create a thread."]
    #[doc = ""]
    #[doc = "   Thread naming is a little complicated: Most systems have very small"]
    #[doc = "    limits for the string length (Haiku has 32 bytes, Linux currently has 16,"]
    #[doc = "    Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll"]
    #[doc = "    have to see what happens with your system's debugger. The name should be"]
    #[doc = "    UTF-8 (but using the naming limits of C identifiers is a better bet)."]
    #[doc = "   There are no requirements for thread naming conventions, so long as the"]
    #[doc = "    string is null-terminated UTF-8, but these guidelines are helpful in"]
    #[doc = "    choosing a name:"]
    #[doc = ""]
    #[doc = "    http://stackoverflow.com/questions/149932/naming-conventions-for-threads"]
    #[doc = ""]
    #[doc = "   If a system imposes requirements, SDL will try to munge the string for"]
    #[doc = "    it (truncate, etc), but the original string contents will be available"]
    #[doc = "    from SDL_GetThreadName()."]
    #[doc = ""]
    #[doc = "   The size (in bytes) of the new stack can be specified. Zero means \"use"]
    #[doc = "    the system default\" which might be wildly different between platforms"]
    #[doc = "    (x86 Linux generally defaults to eight megabytes, an embedded device"]
    #[doc = "    might be a few kilobytes instead)."]
    #[doc = ""]
    #[doc = "   In SDL 2.1, stacksize will be folded into the original SDL_CreateThread"]
    #[doc = "    function."]
    pub fn SDL_CreateThreadWithStackSize(
        fn_: SDL_ThreadFunction,
        name: *const ::std::os::raw::c_char,
        stacksize: size_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = " Get the thread name, as it was specified in SDL_CreateThread()."]
    #[doc = "  This function returns a pointer to a UTF-8 string that names the"]
    #[doc = "  specified thread, or NULL if it doesn't have a name. This is internal"]
    #[doc = "  memory, not to be free()'d by the caller, and remains valid until the"]
    #[doc = "  specified thread is cleaned up by SDL_WaitThread()."]
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the thread identifier for the current thread."]
    pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
    #[doc = "  Get the thread identifier for the specified thread."]
    #[doc = ""]
    #[doc = "  Equivalent to SDL_ThreadID() if the specified thread is NULL."]
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
    #[doc = "  Set the priority for the current thread"]
    pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Wait for a thread to finish. Threads that haven't been detached will"]
    #[doc = "  remain (as a \"zombie\") until this function cleans them up. Not doing so"]
    #[doc = "  is a resource leak."]
    #[doc = ""]
    #[doc = "  Once a thread has been cleaned up through this function, the SDL_Thread"]
    #[doc = "  that references it becomes invalid and should not be referenced again."]
    #[doc = "  As such, only one thread may call SDL_WaitThread() on another."]
    #[doc = ""]
    #[doc = "  The return code for the thread function is placed in the area"]
    #[doc = "  pointed to by \\c status, if \\c status is not NULL."]
    #[doc = ""]
    #[doc = "  You may not wait on a thread that has been used in a call to"]
    #[doc = "  SDL_DetachThread(). Use either that function or this one, but not"]
    #[doc = "  both, or behavior is undefined."]
    #[doc = ""]
    #[doc = "  It is safe to pass NULL to this function; it is a no-op."]
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "  A thread may be \"detached\" to signify that it should not remain until"]
    #[doc = "  another thread has called SDL_WaitThread() on it. Detaching a thread"]
    #[doc = "  is useful for long-running threads that nothing needs to synchronize"]
    #[doc = "  with or further manage. When a detached thread is done, it simply"]
    #[doc = "  goes away."]
    #[doc = ""]
    #[doc = "  There is no way to recover the return code of a detached thread. If you"]
    #[doc = "  need this, don't detach the thread and instead use SDL_WaitThread()."]
    #[doc = ""]
    #[doc = "  Once a thread is detached, you should usually assume the SDL_Thread isn't"]
    #[doc = "  safe to reference again, as it will become invalid immediately upon"]
    #[doc = "  the detached thread's exit, instead of remaining until someone has called"]
    #[doc = "  SDL_WaitThread() to finally clean it up. As such, don't detach the same"]
    #[doc = "  thread more than once."]
    #[doc = ""]
    #[doc = "  If a thread has already exited when passed to SDL_DetachThread(), it will"]
    #[doc = "  stop waiting for a call to SDL_WaitThread() and clean up immediately."]
    #[doc = "  It is not safe to detach a thread that might be used with SDL_WaitThread()."]
    #[doc = ""]
    #[doc = "  You may not call SDL_WaitThread() on a thread that has been detached."]
    #[doc = "  Use either that function or this one, but not both, or behavior is"]
    #[doc = "  undefined."]
    #[doc = ""]
    #[doc = "  It is safe to pass NULL to this function; it is a no-op."]
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
    #[doc = "  \\brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific."]
    #[doc = ""]
    #[doc = "  \\return The newly created thread local storage identifier, or 0 on error"]
    #[doc = ""]
    #[doc = "  \\code"]
    #[doc = "  static SDL_SpinLock tls_lock;"]
    #[doc = "  static SDL_TLSID thread_local_storage;"]
    #[doc = ""]
    #[doc = "  void SetMyThreadData(void *value)"]
    #[doc = "  {"]
    #[doc = "      if (!thread_local_storage) {"]
    #[doc = "          SDL_AtomicLock(&tls_lock);"]
    #[doc = "          if (!thread_local_storage) {"]
    #[doc = "              thread_local_storage = SDL_TLSCreate();"]
    #[doc = "          }"]
    #[doc = "          SDL_AtomicUnlock(&tls_lock);"]
    #[doc = "      }"]
    #[doc = "      SDL_TLSSet(thread_local_storage, value, 0);"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  void *GetMyThreadData(void)"]
    #[doc = "  {"]
    #[doc = "      return SDL_TLSGet(thread_local_storage);"]
    #[doc = "  }"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = "  \\sa SDL_TLSGet()"]
    #[doc = "  \\sa SDL_TLSSet()"]
    pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
    #[doc = "  \\brief Get the value associated with a thread local storage ID for the current thread."]
    #[doc = ""]
    #[doc = "  \\param id The thread local storage ID"]
    #[doc = ""]
    #[doc = "  \\return The value associated with the ID for the current thread, or NULL if no value has been set."]
    #[doc = ""]
    #[doc = "  \\sa SDL_TLSCreate()"]
    #[doc = "  \\sa SDL_TLSSet()"]
    pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  \\brief Set the value associated with a thread local storage ID for the current thread."]
    #[doc = ""]
    #[doc = "  \\param id The thread local storage ID"]
    #[doc = "  \\param value The value to associate with the ID for the current thread"]
    #[doc = "  \\param destructor A function called when the thread exits, to free the value."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, -1 on error"]
    #[doc = ""]
    #[doc = "  \\sa SDL_TLSCreate()"]
    #[doc = "  \\sa SDL_TLSGet()"]
    pub fn SDL_TLSSet(
        id: SDL_TLSID,
        value: *const ::std::os::raw::c_void,
        destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This is the read/write operation structure -- very basic."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
    pub size: ::std::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
    #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio's whence values:"]
    #[doc = "  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END"]
    #[doc = ""]
    #[doc = "  \\return the final offset in the data stream, or -1 on error."]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: Sint64,
            whence: ::std::os::raw::c_int,
        ) -> Sint64,
    >,
    #[doc = "  Read up to \\c maxnum objects each of size \\c size from the data"]
    #[doc = "  stream to the area pointed at by \\c ptr."]
    #[doc = ""]
    #[doc = "  \\return the number of objects read, or 0 at error or end of file."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut ::std::os::raw::c_void,
            size: size_t,
            maxnum: size_t,
        ) -> size_t,
    >,
    #[doc = "  Write exactly \\c num objects each of size \\c size from the area"]
    #[doc = "  pointed at by \\c ptr to data stream."]
    #[doc = ""]
    #[doc = "  \\return the number of objects written, or 0 at error or end of file."]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const ::std::os::raw::c_void,
            size: size_t,
            num: size_t,
        ) -> size_t,
    >,
    #[doc = "  Close and free an allocated SDL_RWops structure."]
    #[doc = ""]
    #[doc = "  \\return 0 if successful or -1 on write error when flushing data."]
    pub close: ::std::option::Option<
        unsafe extern "C" fn(context: *mut SDL_RWops) -> ::std::os::raw::c_int,
    >,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub autoclose: SDL_bool,
    pub fp: *mut FILE,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).autoclose as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autoclose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).fp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).here as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(here)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).stop as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    pub data1: *mut ::std::os::raw::c_void,
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data2 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data2)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1>())).stdio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1>())).unknown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_RWops))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).seek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).close as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).hidden as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    pub fn SDL_RWFromFile(
        file: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromFP(fp: *mut FILE, autoclose: SDL_bool) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromMem(
        mem: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromConstMem(
        mem: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
    #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
    pub fn SDL_RWsize(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
    #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio's whence values:"]
    #[doc = "  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END"]
    #[doc = ""]
    #[doc = "  \\return the final offset in the data stream, or -1 on error."]
    pub fn SDL_RWseek(
        context: *mut SDL_RWops,
        offset: Sint64,
        whence: ::std::os::raw::c_int,
    ) -> Sint64;
}
extern "C" {
    #[doc = "  Return the current offset in the data stream, or -1 on error."]
    pub fn SDL_RWtell(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
    #[doc = "  Read up to \\c maxnum objects each of size \\c size from the data"]
    #[doc = "  stream to the area pointed at by \\c ptr."]
    #[doc = ""]
    #[doc = "  \\return the number of objects read, or 0 at error or end of file."]
    pub fn SDL_RWread(
        context: *mut SDL_RWops,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        maxnum: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = "  Write exactly \\c num objects each of size \\c size from the area"]
    #[doc = "  pointed at by \\c ptr to data stream."]
    #[doc = ""]
    #[doc = "  \\return the number of objects written, or 0 at error or end of file."]
    pub fn SDL_RWwrite(
        context: *mut SDL_RWops,
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        num: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = "  Close and free an allocated SDL_RWops structure."]
    #[doc = ""]
    #[doc = "  \\return 0 if successful or -1 on write error when flushing data."]
    pub fn SDL_RWclose(context: *mut SDL_RWops) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Load all the data from an SDL data stream."]
    #[doc = ""]
    #[doc = "  The data is allocated with a zero byte at the end (null terminated)"]
    #[doc = ""]
    #[doc = "  If \\c datasize is not NULL, it is filled with the size of the data read."]
    #[doc = ""]
    #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
    #[doc = ""]
    #[doc = "  The data should be freed with SDL_free()."]
    #[doc = ""]
    #[doc = "  \\return the data, or NULL if there was an error."]
    pub fn SDL_LoadFile_RW(
        src: *mut SDL_RWops,
        datasize: *mut size_t,
        freesrc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Load an entire file."]
    #[doc = ""]
    #[doc = "  The data is allocated with a zero byte at the end (null terminated)"]
    #[doc = ""]
    #[doc = "  If \\c datasize is not NULL, it is filled with the size of the data read."]
    #[doc = ""]
    #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
    #[doc = ""]
    #[doc = "  The data should be freed with SDL_free()."]
    #[doc = ""]
    #[doc = "  \\return the data, or NULL if there was an error."]
    pub fn SDL_LoadFile(
        file: *const ::std::os::raw::c_char,
        datasize: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> size_t;
}
extern "C" {
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> size_t;
}
extern "C" {
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> size_t;
}
extern "C" {
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> size_t;
}
extern "C" {
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> size_t;
}
extern "C" {
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> size_t;
}
extern "C" {
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> size_t;
}
#[doc = "  \\brief Audio format flags."]
#[doc = ""]
#[doc = "  These are what the 16 bits in SDL_AudioFormat currently mean..."]
#[doc = "  (Unspecified bits are always zero)."]
#[doc = ""]
#[doc = "  \\verbatim"]
#[doc = "++-----------------------sample is signed if set"]
#[doc = "||"]
#[doc = "||       ++-----------sample is bigendian if set"]
#[doc = "||       ||"]
#[doc = "||       ||          ++---sample is float if set"]
#[doc = "||       ||          ||"]
#[doc = "||       ||          || +---sample bit size---+"]
#[doc = "||       ||          || |                     |"]
#[doc = "15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  There are macros in SDL 2.0 and later to query these bits."]
pub type SDL_AudioFormat = Uint16;
#[doc = "  This function is called when the audio device needs more data."]
#[doc = ""]
#[doc = "  \\param userdata An application-specific parameter saved in"]
#[doc = "                  the SDL_AudioSpec structure"]
#[doc = "  \\param stream A pointer to the audio data buffer."]
#[doc = "  \\param len    The length of that buffer in bytes."]
#[doc = ""]
#[doc = "  Once the callback returns, the buffer will no longer be valid."]
#[doc = "  Stereo samples are stored in a LRLRLR ordering."]
#[doc = ""]
#[doc = "  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if"]
#[doc = "  you like. Just open your audio device with a NULL callback."]
pub type SDL_AudioCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        stream: *mut Uint8,
        len: ::std::os::raw::c_int,
    ),
>;
#[doc = "  The calculated values in this structure are calculated by SDL_OpenAudio()."]
#[doc = ""]
#[doc = "  For multi-channel audio, the default SDL channel mapping is:"]
#[doc = "  2:  FL FR                       (stereo)"]
#[doc = "  3:  FL FR LFE                   (2.1 surround)"]
#[doc = "  4:  FL FR BL BR                 (quad)"]
#[doc = "  5:  FL FR FC BL BR              (quad + center)"]
#[doc = "  6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)"]
#[doc = "  7:  FL FR FC LFE BC SL SR       (6.1 surround)"]
#[doc = "  8:  FL FR FC LFE BL BR SL SR    (7.1 surround)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioSpec {
    #[doc = "< DSP frequency -- samples per second"]
    pub freq: ::std::os::raw::c_int,
    #[doc = "< Audio data format"]
    pub format: SDL_AudioFormat,
    #[doc = "< Number of channels: 1 mono, 2 stereo"]
    pub channels: Uint8,
    #[doc = "< Audio buffer silence value (calculated)"]
    pub silence: Uint8,
    #[doc = "< Audio buffer size in sample FRAMES (total samples divided by channel count)"]
    pub samples: Uint16,
    #[doc = "< Necessary for some compile environments"]
    pub padding: Uint16,
    #[doc = "< Audio buffer size in bytes (calculated)"]
    pub size: Uint32,
    #[doc = "< Callback that feeds the audio device (NULL to use SDL_QueueAudio())."]
    pub callback: SDL_AudioCallback,
    #[doc = "< Userdata passed to callback (ignored for NULL callbacks)."]
    pub userdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioSpec>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).channels as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).silence as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(silence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).samples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).callback as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).userdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(userdata)
        )
    );
}
pub type SDL_AudioFilter =
    ::std::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioCVT {
    #[doc = "< Set to 1 if conversion possible"]
    pub needed: ::std::os::raw::c_int,
    #[doc = "< Source audio format"]
    pub src_format: SDL_AudioFormat,
    #[doc = "< Target audio format"]
    pub dst_format: SDL_AudioFormat,
    #[doc = "< Rate conversion increment"]
    pub rate_incr: f64,
    #[doc = "< Buffer to hold entire audio data"]
    pub buf: *mut Uint8,
    #[doc = "< Length of original audio buffer"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< Length of converted audio buffer"]
    pub len_cvt: ::std::os::raw::c_int,
    #[doc = "< buffer must be len*len_mult big"]
    pub len_mult: ::std::os::raw::c_int,
    #[doc = "< Given len, final size is len*len_ratio"]
    pub len_ratio: f64,
    #[doc = "< NULL-terminated list of filter functions"]
    pub filters: [SDL_AudioFilter; 10usize],
    #[doc = "< Current audio conversion function"]
    pub filter_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioCVT>(),
        128usize,
        concat!("Size of: ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioCVT>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).needed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).src_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(src_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).dst_format as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(dst_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).rate_incr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(rate_incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len_cvt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_cvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len_mult as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len_ratio as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).filters as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).filter_index as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filter_index)
        )
    );
}
extern "C" {
    pub fn SDL_GetNumAudioDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetAudioDriver(index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_AudioInit(driver_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_AudioQuit();
}
extern "C" {
    #[doc = "  This function returns the name of the current audio driver, or NULL"]
    #[doc = "  if no driver has been initialized."]
    pub fn SDL_GetCurrentAudioDriver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  This function opens the audio device with the desired parameters, and"]
    #[doc = "  returns 0 if successful, placing the actual hardware parameters in the"]
    #[doc = "  structure pointed to by \\c obtained.  If \\c obtained is NULL, the audio"]
    #[doc = "  data passed to the callback function will be guaranteed to be in the"]
    #[doc = "  requested format, and will be automatically converted to the hardware"]
    #[doc = "  audio format if necessary.  This function returns -1 if it failed"]
    #[doc = "  to open the audio device, or couldn't set up the audio thread."]
    #[doc = ""]
    #[doc = "  When filling in the desired audio spec structure,"]
    #[doc = "    - \\c desired->freq should be the desired audio frequency in samples-per-"]
    #[doc = "      second."]
    #[doc = "    - \\c desired->format should be the desired audio format."]
    #[doc = "    - \\c desired->samples is the desired size of the audio buffer, in"]
    #[doc = "      samples.  This number should be a power of two, and may be adjusted by"]
    #[doc = "      the audio driver to a value more suitable for the hardware.  Good values"]
    #[doc = "      seem to range between 512 and 8096 inclusive, depending on the"]
    #[doc = "      application and CPU speed.  Smaller values yield faster response time,"]
    #[doc = "      but can lead to underflow if the application is doing heavy processing"]
    #[doc = "      and cannot fill the audio buffer in time.  A stereo sample consists of"]
    #[doc = "      both right and left channels in LR ordering."]
    #[doc = "      Note that the number of samples is directly related to time by the"]
    #[doc = "      following formula:  \\code ms = (samples*1000)/freq \\endcode"]
    #[doc = "    - \\c desired->size is the size in bytes of the audio buffer, and is"]
    #[doc = "      calculated by SDL_OpenAudio()."]
    #[doc = "    - \\c desired->silence is the value used to set the buffer to silence,"]
    #[doc = "      and is calculated by SDL_OpenAudio()."]
    #[doc = "    - \\c desired->callback should be set to a function that will be called"]
    #[doc = "      when the audio device is ready for more data.  It is passed a pointer"]
    #[doc = "      to the audio buffer, and the length in bytes of the audio buffer."]
    #[doc = "      This function usually runs in a separate thread, and so you should"]
    #[doc = "      protect data structures that it accesses by calling SDL_LockAudio()"]
    #[doc = "      and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL"]
    #[doc = "      pointer here, and call SDL_QueueAudio() with some frequency, to queue"]
    #[doc = "      more audio samples to be played (or for capture devices, call"]
    #[doc = "      SDL_DequeueAudio() with some frequency, to obtain audio samples)."]
    #[doc = "    - \\c desired->userdata is passed as the first parameter to your callback"]
    #[doc = "      function. If you passed a NULL callback, this value is ignored."]
    #[doc = ""]
    #[doc = "  The audio device starts out playing silence when it's opened, and should"]
    #[doc = "  be enabled for playing by calling \\c SDL_PauseAudio(0) when you are ready"]
    #[doc = "  for your audio callback function to be called.  Since the audio driver"]
    #[doc = "  may modify the requested size of the audio buffer, you should allocate"]
    #[doc = "  any local mixing buffers after you open the audio device."]
    pub fn SDL_OpenAudio(
        desired: *mut SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
    ) -> ::std::os::raw::c_int;
}
#[doc = "  SDL Audio Device IDs."]
#[doc = ""]
#[doc = "  A successful call to SDL_OpenAudio() is always device id 1, and legacy"]
#[doc = "  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls"]
#[doc = "  always returns devices >= 2 on success. The legacy calls are good both"]
#[doc = "  for backwards compatibility and when you don't care about multiple,"]
#[doc = "  specific, or capture devices."]
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
    #[doc = "  Get the number of available devices exposed by the current driver."]
    #[doc = "  Only valid after a successfully initializing the audio subsystem."]
    #[doc = "  Returns -1 if an explicit list of devices can't be determined; this is"]
    #[doc = "  not an error. For example, if SDL is set up to talk to a remote audio"]
    #[doc = "  server, it can't list every one available on the Internet, but it will"]
    #[doc = "  still allow a specific host to be specified to SDL_OpenAudioDevice()."]
    #[doc = ""]
    #[doc = "  In many common cases, when this function returns a value <= 0, it can still"]
    #[doc = "  successfully open the default device (NULL for first argument of"]
    #[doc = "  SDL_OpenAudioDevice())."]
    pub fn SDL_GetNumAudioDevices(iscapture: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the human-readable name of a specific audio device."]
    #[doc = "  Must be a value between 0 and (number of audio devices-1)."]
    #[doc = "  Only valid after a successfully initializing the audio subsystem."]
    #[doc = "  The values returned by this function reflect the latest call to"]
    #[doc = "  SDL_GetNumAudioDevices(); recall that function to redetect available"]
    #[doc = "  hardware."]
    #[doc = ""]
    #[doc = "  The string returned by this function is UTF-8 encoded, read-only, and"]
    #[doc = "  managed internally. You are not to free it. If you need to keep the"]
    #[doc = "  string for any length of time, you should make your own copy of it, as it"]
    #[doc = "  will be invalid next time any of several other SDL functions is called."]
    pub fn SDL_GetAudioDeviceName(
        index: ::std::os::raw::c_int,
        iscapture: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Open a specific audio device. Passing in a device name of NULL requests"]
    #[doc = "  the most reasonable default (and is equivalent to calling SDL_OpenAudio())."]
    #[doc = ""]
    #[doc = "  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but"]
    #[doc = "  some drivers allow arbitrary and driver-specific strings, such as a"]
    #[doc = "  hostname/IP address for a remote audio server, or a filename in the"]
    #[doc = "  diskaudio driver."]
    #[doc = ""]
    #[doc = "  \\return 0 on error, a valid device ID that is >= 2 on success."]
    #[doc = ""]
    #[doc = "  SDL_OpenAudio(), unlike this function, always acts on device ID 1."]
    pub fn SDL_OpenAudioDevice(
        device: *const ::std::os::raw::c_char,
        iscapture: ::std::os::raw::c_int,
        desired: *const SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
        allowed_changes: ::std::os::raw::c_int,
    ) -> SDL_AudioDeviceID;
}
pub const SDL_AudioStatus_SDL_AUDIO_STOPPED: SDL_AudioStatus = 0;
pub const SDL_AudioStatus_SDL_AUDIO_PLAYING: SDL_AudioStatus = 1;
pub const SDL_AudioStatus_SDL_AUDIO_PAUSED: SDL_AudioStatus = 2;
pub type SDL_AudioStatus = u32;
extern "C" {
    pub fn SDL_GetAudioStatus() -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_PauseAudio(pause_on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "  \\brief Load the audio data of a WAVE file into memory"]
    #[doc = ""]
    #[doc = "  Loading a WAVE file requires \\c src, \\c spec, \\c audio_buf and \\c audio_len"]
    #[doc = "  to be valid pointers. The entire data portion of the file is then loaded"]
    #[doc = "  into memory and decoded if necessary."]
    #[doc = ""]
    #[doc = "  If \\c freesrc is non-zero, the data source gets automatically closed and"]
    #[doc = "  freed before the function returns."]
    #[doc = ""]
    #[doc = "  Supported are RIFF WAVE files with the formats PCM (8, 16, 24, and 32 bits),"]
    #[doc = "  IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and A-law and"]
    #[doc = "  -law (8 bits). Other formats are currently unsupported and cause an error."]
    #[doc = ""]
    #[doc = "  If this function succeeds, the pointer returned by it is equal to \\c spec"]
    #[doc = "  and the pointer to the audio data allocated by the function is written to"]
    #[doc = "  \\c audio_buf and its length in bytes to \\c audio_len. The \\ref SDL_AudioSpec"]
    #[doc = "  members \\c freq, \\c channels, and \\c format are set to the values of the"]
    #[doc = "  audio data in the buffer. The \\c samples member is set to a sane default and"]
    #[doc = "  all others are set to zero."]
    #[doc = ""]
    #[doc = "  It's necessary to use SDL_FreeWAV() to free the audio data returned in"]
    #[doc = "  \\c audio_buf when it is no longer used."]
    #[doc = ""]
    #[doc = "  Because of the underspecification of the Waveform format, there are many"]
    #[doc = "  problematic files in the wild that cause issues with strict decoders. To"]
    #[doc = "  provide compatibility with these files, this decoder is lenient in regards"]
    #[doc = "  to the truncation of the file, the fact chunk, and the size of the RIFF"]
    #[doc = "  chunk. The hints SDL_HINT_WAVE_RIFF_CHUNK_SIZE, SDL_HINT_WAVE_TRUNCATION,"]
    #[doc = "  and SDL_HINT_WAVE_FACT_CHUNK can be used to tune the behavior of the"]
    #[doc = "  loading process."]
    #[doc = ""]
    #[doc = "  Any file that is invalid (due to truncation, corruption, or wrong values in"]
    #[doc = "  the headers), too big, or unsupported causes an error. Additionally, any"]
    #[doc = "  critical I/O error from the data source will terminate the loading process"]
    #[doc = "  with an error. The function returns NULL on error and in all cases (with the"]
    #[doc = "  exception of \\c src being NULL), an appropriate error message will be set."]
    #[doc = ""]
    #[doc = "  It is required that the data source supports seeking."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = "  \\code"]
    #[doc = "      SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, ...);"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = "  \\param src The data source with the WAVE data"]
    #[doc = "  \\param freesrc A integer value that makes the function close the data source if non-zero"]
    #[doc = "  \\param spec A pointer filled with the audio format of the audio data"]
    #[doc = "  \\param audio_buf A pointer filled with the audio data allocated by the function"]
    #[doc = "  \\param audio_len A pointer filled with the length of the audio data buffer in bytes"]
    #[doc = "  \\return NULL on error, or non-NULL on success."]
    pub fn SDL_LoadWAV_RW(
        src: *mut SDL_RWops,
        freesrc: ::std::os::raw::c_int,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> *mut SDL_AudioSpec;
}
extern "C" {
    #[doc = "  This function frees data previously allocated with SDL_LoadWAV_RW()"]
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
    #[doc = "  This function takes a source format and rate and a destination format"]
    #[doc = "  and rate, and initializes the \\c cvt structure with information needed"]
    #[doc = "  by SDL_ConvertAudio() to convert a buffer of audio data from one format"]
    #[doc = "  to the other. An unsupported format causes an error and -1 will be returned."]
    #[doc = ""]
    #[doc = "  \\return 0 if no conversion is needed, 1 if the audio filter is set up,"]
    #[doc = "  or -1 on error."]
    pub fn SDL_BuildAudioCVT(
        cvt: *mut SDL_AudioCVT,
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: ::std::os::raw::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Once you have initialized the \\c cvt structure using SDL_BuildAudioCVT(),"]
    #[doc = "  created an audio buffer \\c cvt->buf, and filled it with \\c cvt->len bytes of"]
    #[doc = "  audio data in the source format, this function will convert it in-place"]
    #[doc = "  to the desired format."]
    #[doc = ""]
    #[doc = "  The data conversion may expand the size of the audio data, so the buffer"]
    #[doc = "  \\c cvt->buf should be allocated after the \\c cvt structure is initialized by"]
    #[doc = "  SDL_BuildAudioCVT(), and should be \\c cvt->len*cvt->len_mult bytes long."]
    #[doc = ""]
    #[doc = "  \\return 0 on success or -1 if \\c cvt->buf is NULL."]
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_AudioStream {
    _unused: [u8; 0],
}
pub type SDL_AudioStream = _SDL_AudioStream;
extern "C" {
    #[doc = "  Create a new audio stream"]
    #[doc = ""]
    #[doc = "  \\param src_format The format of the source audio"]
    #[doc = "  \\param src_channels The number of channels of the source audio"]
    #[doc = "  \\param src_rate The sampling rate of the source audio"]
    #[doc = "  \\param dst_format The format of the desired audio output"]
    #[doc = "  \\param dst_channels The number of channels of the desired audio output"]
    #[doc = "  \\param dst_rate The sampling rate of the desired audio output"]
    #[doc = "  \\return 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_AudioStreamPut"]
    #[doc = "  \\sa SDL_AudioStreamGet"]
    #[doc = "  \\sa SDL_AudioStreamAvailable"]
    #[doc = "  \\sa SDL_AudioStreamFlush"]
    #[doc = "  \\sa SDL_AudioStreamClear"]
    #[doc = "  \\sa SDL_FreeAudioStream"]
    pub fn SDL_NewAudioStream(
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: ::std::os::raw::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: ::std::os::raw::c_int,
    ) -> *mut SDL_AudioStream;
}
extern "C" {
    #[doc = "  Add data to be converted/resampled to the stream"]
    #[doc = ""]
    #[doc = "  \\param stream The stream the audio data is being added to"]
    #[doc = "  \\param buf A pointer to the audio data to add"]
    #[doc = "  \\param len The number of bytes to write to the stream"]
    #[doc = "  \\return 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_NewAudioStream"]
    #[doc = "  \\sa SDL_AudioStreamGet"]
    #[doc = "  \\sa SDL_AudioStreamAvailable"]
    #[doc = "  \\sa SDL_AudioStreamFlush"]
    #[doc = "  \\sa SDL_AudioStreamClear"]
    #[doc = "  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamPut(
        stream: *mut SDL_AudioStream,
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get converted/resampled data from the stream"]
    #[doc = ""]
    #[doc = "  \\param stream The stream the audio is being requested from"]
    #[doc = "  \\param buf A buffer to fill with audio data"]
    #[doc = "  \\param len The maximum number of bytes to fill"]
    #[doc = "  \\return The number of bytes read from the stream, or -1 on error"]
    #[doc = ""]
    #[doc = "  \\sa SDL_NewAudioStream"]
    #[doc = "  \\sa SDL_AudioStreamPut"]
    #[doc = "  \\sa SDL_AudioStreamAvailable"]
    #[doc = "  \\sa SDL_AudioStreamFlush"]
    #[doc = "  \\sa SDL_AudioStreamClear"]
    #[doc = "  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamGet(
        stream: *mut SDL_AudioStream,
        buf: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of converted/resampled bytes available. The stream may be"]
    #[doc = "  buffering data behind the scenes until it has enough to resample"]
    #[doc = "  correctly, so this number might be lower than what you expect, or even"]
    #[doc = "  be zero. Add more data or flush the stream if you need the data now."]
    #[doc = ""]
    #[doc = "  \\sa SDL_NewAudioStream"]
    #[doc = "  \\sa SDL_AudioStreamPut"]
    #[doc = "  \\sa SDL_AudioStreamGet"]
    #[doc = "  \\sa SDL_AudioStreamFlush"]
    #[doc = "  \\sa SDL_AudioStreamClear"]
    #[doc = "  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamAvailable(stream: *mut SDL_AudioStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the stream that you're done sending data, and anything being buffered"]
    #[doc = "  should be converted/resampled and made available immediately."]
    #[doc = ""]
    #[doc = " It is legal to add more data to a stream after flushing, but there will"]
    #[doc = "  be audio gaps in the output. Generally this is intended to signal the"]
    #[doc = "  end of input, so the complete output becomes available."]
    #[doc = ""]
    #[doc = "  \\sa SDL_NewAudioStream"]
    #[doc = "  \\sa SDL_AudioStreamPut"]
    #[doc = "  \\sa SDL_AudioStreamGet"]
    #[doc = "  \\sa SDL_AudioStreamAvailable"]
    #[doc = "  \\sa SDL_AudioStreamClear"]
    #[doc = "  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamFlush(stream: *mut SDL_AudioStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Clear any pending data in the stream without converting it"]
    #[doc = ""]
    #[doc = "  \\sa SDL_NewAudioStream"]
    #[doc = "  \\sa SDL_AudioStreamPut"]
    #[doc = "  \\sa SDL_AudioStreamGet"]
    #[doc = "  \\sa SDL_AudioStreamAvailable"]
    #[doc = "  \\sa SDL_AudioStreamFlush"]
    #[doc = "  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamClear(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = " Free an audio stream"]
    #[doc = ""]
    #[doc = "  \\sa SDL_NewAudioStream"]
    #[doc = "  \\sa SDL_AudioStreamPut"]
    #[doc = "  \\sa SDL_AudioStreamGet"]
    #[doc = "  \\sa SDL_AudioStreamAvailable"]
    #[doc = "  \\sa SDL_AudioStreamFlush"]
    #[doc = "  \\sa SDL_AudioStreamClear"]
    pub fn SDL_FreeAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = "  This takes two audio buffers of the playing audio format and mixes"]
    #[doc = "  them, performing addition, volume adjustment, and overflow clipping."]
    #[doc = "  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME"]
    #[doc = "  for full audio volume.  Note this does not change hardware volume."]
    #[doc = "  This is provided for convenience -- you can mix your own audio data."]
    pub fn SDL_MixAudio(
        dst: *mut Uint8,
        src: *const Uint8,
        len: Uint32,
        volume: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  This works like SDL_MixAudio(), but you specify the audio format instead of"]
    #[doc = "  using the format of audio device 1. Thus it can be used when no audio"]
    #[doc = "  device is open at all."]
    pub fn SDL_MixAudioFormat(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  Queue more audio on non-callback devices."]
    #[doc = ""]
    #[doc = "  (If you are looking to retrieve queued audio from a non-callback capture"]
    #[doc = "  device, you want SDL_DequeueAudio() instead. This will return -1 to"]
    #[doc = "  signify an error if you use it with capture devices.)"]
    #[doc = ""]
    #[doc = "  SDL offers two ways to feed audio to the device: you can either supply a"]
    #[doc = "  callback that SDL triggers with some frequency to obtain more audio"]
    #[doc = "  (pull method), or you can supply no callback, and then SDL will expect"]
    #[doc = "  you to supply data at regular intervals (push method) with this function."]
    #[doc = ""]
    #[doc = "  There are no limits on the amount of data you can queue, short of"]
    #[doc = "  exhaustion of address space. Queued data will drain to the device as"]
    #[doc = "  necessary without further intervention from you. If the device needs"]
    #[doc = "  audio but there is not enough queued, it will play silence to make up"]
    #[doc = "  the difference. This means you will have skips in your audio playback"]
    #[doc = "  if you aren't routinely queueing sufficient data."]
    #[doc = ""]
    #[doc = "  This function copies the supplied data, so you are safe to free it when"]
    #[doc = "  the function returns. This function is thread-safe, but queueing to the"]
    #[doc = "  same device from two threads at once does not promise which buffer will"]
    #[doc = "  be queued first."]
    #[doc = ""]
    #[doc = "  You may not queue audio on a device that is using an application-supplied"]
    #[doc = "  callback; doing so returns an error. You have to use the audio callback"]
    #[doc = "  or queue audio with this function, but not both."]
    #[doc = ""]
    #[doc = "  You should not call SDL_LockAudio() on the device before queueing; SDL"]
    #[doc = "  handles locking internally for this function."]
    #[doc = ""]
    #[doc = "  \\param dev The device ID to which we will queue audio."]
    #[doc = "  \\param data The data to queue to the device for later playback."]
    #[doc = "  \\param len The number of bytes (not samples!) to which (data) points."]
    #[doc = "  \\return 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetQueuedAudioSize"]
    #[doc = "  \\sa SDL_ClearQueuedAudio"]
    pub fn SDL_QueueAudio(
        dev: SDL_AudioDeviceID,
        data: *const ::std::os::raw::c_void,
        len: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Dequeue more audio on non-callback devices."]
    #[doc = ""]
    #[doc = "  (If you are looking to queue audio for output on a non-callback playback"]
    #[doc = "  device, you want SDL_QueueAudio() instead. This will always return 0"]
    #[doc = "  if you use it with playback devices.)"]
    #[doc = ""]
    #[doc = "  SDL offers two ways to retrieve audio from a capture device: you can"]
    #[doc = "  either supply a callback that SDL triggers with some frequency as the"]
    #[doc = "  device records more audio data, (push method), or you can supply no"]
    #[doc = "  callback, and then SDL will expect you to retrieve data at regular"]
    #[doc = "  intervals (pull method) with this function."]
    #[doc = ""]
    #[doc = "  There are no limits on the amount of data you can queue, short of"]
    #[doc = "  exhaustion of address space. Data from the device will keep queuing as"]
    #[doc = "  necessary without further intervention from you. This means you will"]
    #[doc = "  eventually run out of memory if you aren't routinely dequeueing data."]
    #[doc = ""]
    #[doc = "  Capture devices will not queue data when paused; if you are expecting"]
    #[doc = "  to not need captured audio for some length of time, use"]
    #[doc = "  SDL_PauseAudioDevice() to stop the capture device from queueing more"]
    #[doc = "  data. This can be useful during, say, level loading times. When"]
    #[doc = "  unpaused, capture devices will start queueing data from that point,"]
    #[doc = "  having flushed any capturable data available while paused."]
    #[doc = ""]
    #[doc = "  This function is thread-safe, but dequeueing from the same device from"]
    #[doc = "  two threads at once does not promise which thread will dequeued data"]
    #[doc = "  first."]
    #[doc = ""]
    #[doc = "  You may not dequeue audio from a device that is using an"]
    #[doc = "  application-supplied callback; doing so returns an error. You have to use"]
    #[doc = "  the audio callback, or dequeue audio with this function, but not both."]
    #[doc = ""]
    #[doc = "  You should not call SDL_LockAudio() on the device before queueing; SDL"]
    #[doc = "  handles locking internally for this function."]
    #[doc = ""]
    #[doc = "  \\param dev The device ID from which we will dequeue audio."]
    #[doc = "  \\param data A pointer into where audio data should be copied."]
    #[doc = "  \\param len The number of bytes (not samples!) to which (data) points."]
    #[doc = "  \\return number of bytes dequeued, which could be less than requested."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetQueuedAudioSize"]
    #[doc = "  \\sa SDL_ClearQueuedAudio"]
    pub fn SDL_DequeueAudio(
        dev: SDL_AudioDeviceID,
        data: *mut ::std::os::raw::c_void,
        len: Uint32,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  Get the number of bytes of still-queued audio."]
    #[doc = ""]
    #[doc = "  For playback device:"]
    #[doc = ""]
    #[doc = "    This is the number of bytes that have been queued for playback with"]
    #[doc = "    SDL_QueueAudio(), but have not yet been sent to the hardware. This"]
    #[doc = "    number may shrink at any time, so this only informs of pending data."]
    #[doc = ""]
    #[doc = "    Once we've sent it to the hardware, this function can not decide the"]
    #[doc = "    exact byte boundary of what has been played. It's possible that we just"]
    #[doc = "    gave the hardware several kilobytes right before you called this"]
    #[doc = "    function, but it hasn't played any of it yet, or maybe half of it, etc."]
    #[doc = ""]
    #[doc = "  For capture devices:"]
    #[doc = ""]
    #[doc = "    This is the number of bytes that have been captured by the device and"]
    #[doc = "    are waiting for you to dequeue. This number may grow at any time, so"]
    #[doc = "    this only informs of the lower-bound of available data."]
    #[doc = ""]
    #[doc = "  You may not queue audio on a device that is using an application-supplied"]
    #[doc = "  callback; calling this function on such a device always returns 0."]
    #[doc = "  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use"]
    #[doc = "  the audio callback, but not both."]
    #[doc = ""]
    #[doc = "  You should not call SDL_LockAudio() on the device before querying; SDL"]
    #[doc = "  handles locking internally for this function."]
    #[doc = ""]
    #[doc = "  \\param dev The device ID of which we will query queued audio size."]
    #[doc = "  \\return Number of bytes (not samples!) of queued audio."]
    #[doc = ""]
    #[doc = "  \\sa SDL_QueueAudio"]
    #[doc = "  \\sa SDL_ClearQueuedAudio"]
    pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
    #[doc = "  Drop any queued audio data. For playback devices, this is any queued data"]
    #[doc = "  still waiting to be submitted to the hardware. For capture devices, this"]
    #[doc = "  is any data that was queued by the device that hasn't yet been dequeued by"]
    #[doc = "  the application."]
    #[doc = ""]
    #[doc = "  Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For"]
    #[doc = "  playback devices, the hardware will start playing silence if more audio"]
    #[doc = "  isn't queued. Unpaused capture devices will start filling the queue again"]
    #[doc = "  as soon as they have more data available (which, depending on the state"]
    #[doc = "  of the hardware and the thread, could be before this function call"]
    #[doc = "  returns!)."]
    #[doc = ""]
    #[doc = "  This will not prevent playback of queued audio that's already been sent"]
    #[doc = "  to the hardware, as we can not undo that, so expect there to be some"]
    #[doc = "  fraction of a second of audio that might still be heard. This can be"]
    #[doc = "  useful if you want to, say, drop any pending music during a level change"]
    #[doc = "  in your game."]
    #[doc = ""]
    #[doc = "  You may not queue audio on a device that is using an application-supplied"]
    #[doc = "  callback; calling this function on such a device is always a no-op."]
    #[doc = "  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use"]
    #[doc = "  the audio callback, but not both."]
    #[doc = ""]
    #[doc = "  You should not call SDL_LockAudio() on the device before clearing the"]
    #[doc = "  queue; SDL handles locking internally for this function."]
    #[doc = ""]
    #[doc = "  This function always succeeds and thus returns void."]
    #[doc = ""]
    #[doc = "  \\param dev The device ID of which to clear the audio queue."]
    #[doc = ""]
    #[doc = "  \\sa SDL_QueueAudio"]
    #[doc = "  \\sa SDL_GetQueuedAudioSize"]
    pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_LockAudio();
}
extern "C" {
    pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_UnlockAudio();
}
extern "C" {
    pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = "  This function shuts down audio processing and closes the audio device."]
    pub fn SDL_CloseAudio();
}
extern "C" {
    pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " \\brief Put UTF-8 text into the clipboard"]
    #[doc = ""]
    #[doc = " \\sa SDL_GetClipboardText()"]
    pub fn SDL_SetClipboardText(text: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()"]
    #[doc = ""]
    #[doc = " \\sa SDL_SetClipboardText()"]
    pub fn SDL_GetClipboardText() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty"]
    #[doc = ""]
    #[doc = " \\sa SDL_GetClipboardText()"]
    pub fn SDL_HasClipboardText() -> SDL_bool;
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub const _MM_CMPINT_ENUM__MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_ENUM__MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = u32;
pub const _MM_PERM_ENUM__MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_ENUM__MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_ENUM__MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_ENUM__MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_ENUM__MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_ENUM__MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_ENUM__MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_ENUM__MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_ENUM__MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_ENUM__MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_ENUM__MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_ENUM__MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_ENUM__MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_ENUM__MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_ENUM__MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_ENUM__MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ENUM__MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ENUM__MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ENUM__MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ENUM__MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ENUM__MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ENUM__MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ENUM__MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ENUM__MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ENUM__MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ENUM__MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ENUM__MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ENUM__MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ENUM__MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ENUM__MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ENUM__MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ENUM__MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ENUM__MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ENUM__MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ENUM__MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ENUM__MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ENUM__MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ENUM__MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ENUM__MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ENUM__MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ENUM__MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ENUM__MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ENUM__MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ENUM__MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ENUM__MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ENUM__MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ENUM__MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ENUM__MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ENUM__MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ENUM__MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ENUM__MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ENUM__MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ENUM__MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ENUM__MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ENUM__MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ENUM__MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ENUM__MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ENUM__MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ENUM__MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ENUM__MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ENUM__MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ENUM__MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ENUM__MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ENUM__MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_ENUM__MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_ENUM__MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_ENUM__MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_ENUM__MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_ENUM__MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_ENUM__MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_ENUM__MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_ENUM__MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_ENUM__MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_ENUM__MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_ENUM__MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_ENUM__MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_ENUM__MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_ENUM__MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_ENUM__MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_ENUM__MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_ENUM__MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_ENUM__MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_ENUM__MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_ENUM__MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_ENUM__MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_ENUM__MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_ENUM__MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_ENUM__MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_ENUM__MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_ENUM__MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_ENUM__MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_ENUM__MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_ENUM__MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_ENUM__MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_ENUM__MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_ENUM__MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_ENUM__MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_ENUM__MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_ENUM__MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_ENUM__MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_ENUM__MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_ENUM__MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_ENUM__MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_ENUM__MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_ENUM__MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_ENUM__MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_ENUM__MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_ENUM__MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_ENUM__MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_ENUM__MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_ENUM__MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_ENUM__MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_ENUM__MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_ENUM__MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_ENUM__MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_ENUM__MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_ENUM__MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_ENUM__MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_ENUM__MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_ENUM__MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_ENUM__MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_ENUM__MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_ENUM__MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_ENUM__MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_ENUM__MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_ENUM__MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_ENUM__MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_ENUM__MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_ENUM__MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_ENUM__MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_ENUM__MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_ENUM__MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_ENUM__MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_ENUM__MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_ENUM__MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_ENUM__MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_ENUM__MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_ENUM__MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_ENUM__MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_ENUM__MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_ENUM__MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_ENUM__MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_ENUM__MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_ENUM__MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_ENUM__MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_ENUM__MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_ENUM__MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_ENUM__MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_ENUM__MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_ENUM__MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_ENUM__MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_ENUM__MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_ENUM__MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_ENUM__MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_ENUM__MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_ENUM__MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_ENUM__MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_ENUM__MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_ENUM__MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_ENUM__MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_ENUM__MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_ENUM__MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_ENUM__MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_ENUM__MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_ENUM__MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_ENUM__MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_ENUM__MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_ENUM__MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_ENUM__MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_ENUM__MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_ENUM__MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_ENUM__MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_ENUM__MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_ENUM__MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_ENUM__MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_ENUM__MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_ENUM__MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_ENUM__MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_ENUM__MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_ENUM__MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_ENUM__MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_ENUM__MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_ENUM__MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_ENUM__MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_ENUM__MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_ENUM__MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_ENUM__MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_ENUM__MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_ENUM__MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_ENUM__MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_ENUM__MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_ENUM__MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_ENUM__MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_ENUM__MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_ENUM__MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_ENUM__MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_ENUM__MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_ENUM__MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_ENUM__MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_ENUM__MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_ENUM__MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_ENUM__MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_ENUM__MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_ENUM__MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_ENUM__MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_ENUM__MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_ENUM__MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_ENUM__MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_ENUM__MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_ENUM__MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_ENUM__MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_ENUM__MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_ENUM__MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_ENUM__MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_ENUM__MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_ENUM__MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_ENUM__MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_ENUM__MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_ENUM__MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_ENUM__MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_ENUM__MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_ENUM__MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_ENUM__MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_ENUM__MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_ENUM__MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_ENUM__MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_ENUM__MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_ENUM__MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_ENUM__MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_ENUM__MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_ENUM__MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_ENUM__MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_ENUM__MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_ENUM__MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_ENUM__MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_ENUM__MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_ENUM__MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_ENUM__MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_ENUM__MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_ENUM__MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_ENUM__MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_ENUM__MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_ENUM__MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_ENUM__MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_ENUM__MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_ENUM__MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_ENUM__MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_ENUM__MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_ENUM__MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_ENUM__MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_ENUM__MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_ENUM__MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_ENUM__MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_ENUM__MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_ENUM__MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_ENUM__MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = u32;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = u32;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = u32;
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __m512bh = [::std::os::raw::c_short; 32usize];
pub type __m256bh = [::std::os::raw::c_short; 16usize];
pub type __bfloat16 = ::std::os::raw::c_ushort;
pub type __m128bh = [::std::os::raw::c_short; 8usize];
extern "C" {
    #[doc = "  This function returns the number of CPU cores available."]
    pub fn SDL_GetCPUCount() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This function returns the L1 cache line size of the CPU"]
    #[doc = ""]
    #[doc = "  This is useful for determining multi-threaded structure padding"]
    #[doc = "  or SIMD prefetch sizes."]
    pub fn SDL_GetCPUCacheLineSize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has the RDTSC instruction."]
    pub fn SDL_HasRDTSC() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AltiVec features."]
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has MMX features."]
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has 3DNow! features."]
    pub fn SDL_Has3DNow() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE features."]
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE2 features."]
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE3 features."]
    pub fn SDL_HasSSE3() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE4.1 features."]
    pub fn SDL_HasSSE41() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE4.2 features."]
    pub fn SDL_HasSSE42() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AVX features."]
    pub fn SDL_HasAVX() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AVX2 features."]
    pub fn SDL_HasAVX2() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AVX-512F (foundation) features."]
    pub fn SDL_HasAVX512F() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has ARM SIMD (ARMv6) features."]
    pub fn SDL_HasARMSIMD() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has NEON (ARM SIMD) features."]
    pub fn SDL_HasNEON() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns the amount of RAM configured in the system, in MB."]
    pub fn SDL_GetSystemRAM() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Report the alignment this system needs for SIMD allocations."]
    #[doc = ""]
    #[doc = " This will return the minimum number of bytes to which a pointer must be"]
    #[doc = "  aligned to be compatible with SIMD instructions on the current machine."]
    #[doc = "  For example, if the machine supports SSE only, it will return 16, but if"]
    #[doc = "  it supports AVX-512F, it'll return 64 (etc). This only reports values for"]
    #[doc = "  instruction sets SDL knows about, so if your SDL build doesn't have"]
    #[doc = "  SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and"]
    #[doc = "  not 64 for the AVX-512 instructions that exist but SDL doesn't know about."]
    #[doc = "  Plan accordingly."]
    pub fn SDL_SIMDGetAlignment() -> size_t;
}
extern "C" {
    #[doc = " \\brief Allocate memory in a SIMD-friendly way."]
    #[doc = ""]
    #[doc = " This will allocate a block of memory that is suitable for use with SIMD"]
    #[doc = "  instructions. Specifically, it will be properly aligned and padded for"]
    #[doc = "  the system's supported vector instructions."]
    #[doc = ""]
    #[doc = " The memory returned will be padded such that it is safe to read or write"]
    #[doc = "  an incomplete vector at the end of the memory block. This can be useful"]
    #[doc = "  so you don't have to drop back to a scalar fallback at the end of your"]
    #[doc = "  SIMD processing loop to deal with the final elements without overflowing"]
    #[doc = "  the allocated buffer."]
    #[doc = ""]
    #[doc = " You must free this memory with SDL_FreeSIMD(), not free() or SDL_free()"]
    #[doc = "  or delete[], etc."]
    #[doc = ""]
    #[doc = " Note that SDL will only deal with SIMD instruction sets it is aware of;"]
    #[doc = "  for example, SDL 2.0.8 knows that SSE wants 16-byte vectors"]
    #[doc = "  (SDL_HasSSE()), and AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't"]
    #[doc = "  know that AVX-512 wants 64. To be clear: if you can't decide to use an"]
    #[doc = "  instruction set with an SDL_Has*() function, don't use that instruction"]
    #[doc = "  set with memory allocated through here."]
    #[doc = ""]
    #[doc = " SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't"]
    #[doc = "  out of memory."]
    #[doc = ""]
    #[doc = "  \\param len The length, in bytes, of the block to allocated. The actual"]
    #[doc = "             allocated block might be larger due to padding, etc."]
    #[doc = " \\return Pointer to newly-allocated block, NULL if out of memory."]
    #[doc = ""]
    #[doc = " \\sa SDL_SIMDAlignment"]
    #[doc = " \\sa SDL_SIMDFree"]
    pub fn SDL_SIMDAlloc(len: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Deallocate memory obtained from SDL_SIMDAlloc"]
    #[doc = ""]
    #[doc = " It is not valid to use this function on a pointer from anything but"]
    #[doc = "  SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,"]
    #[doc = "  SDL_malloc, memalign, new[], etc."]
    #[doc = ""]
    #[doc = " However, SDL_SIMDFree(NULL) is a legal no-op."]
    #[doc = ""]
    #[doc = " \\sa SDL_SIMDAlloc"]
    pub fn SDL_SIMDFree(ptr: *mut ::std::os::raw::c_void);
}
pub const SDL_PixelType_SDL_PIXELTYPE_UNKNOWN: SDL_PixelType = 0;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX1: SDL_PixelType = 1;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX4: SDL_PixelType = 2;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX8: SDL_PixelType = 3;
pub const SDL_PixelType_SDL_PIXELTYPE_PACKED8: SDL_PixelType = 4;
pub const SDL_PixelType_SDL_PIXELTYPE_PACKED16: SDL_PixelType = 5;
pub const SDL_PixelType_SDL_PIXELTYPE_PACKED32: SDL_PixelType = 6;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYU8: SDL_PixelType = 7;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYU16: SDL_PixelType = 8;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYU32: SDL_PixelType = 9;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYF16: SDL_PixelType = 10;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYF32: SDL_PixelType = 11;
#[doc = " Pixel type."]
pub type SDL_PixelType = u32;
pub const SDL_BitmapOrder_SDL_BITMAPORDER_NONE: SDL_BitmapOrder = 0;
pub const SDL_BitmapOrder_SDL_BITMAPORDER_4321: SDL_BitmapOrder = 1;
pub const SDL_BitmapOrder_SDL_BITMAPORDER_1234: SDL_BitmapOrder = 2;
#[doc = " Bitmap pixel order, high bit -> low bit."]
pub type SDL_BitmapOrder = u32;
pub const SDL_PackedOrder_SDL_PACKEDORDER_NONE: SDL_PackedOrder = 0;
pub const SDL_PackedOrder_SDL_PACKEDORDER_XRGB: SDL_PackedOrder = 1;
pub const SDL_PackedOrder_SDL_PACKEDORDER_RGBX: SDL_PackedOrder = 2;
pub const SDL_PackedOrder_SDL_PACKEDORDER_ARGB: SDL_PackedOrder = 3;
pub const SDL_PackedOrder_SDL_PACKEDORDER_RGBA: SDL_PackedOrder = 4;
pub const SDL_PackedOrder_SDL_PACKEDORDER_XBGR: SDL_PackedOrder = 5;
pub const SDL_PackedOrder_SDL_PACKEDORDER_BGRX: SDL_PackedOrder = 6;
pub const SDL_PackedOrder_SDL_PACKEDORDER_ABGR: SDL_PackedOrder = 7;
pub const SDL_PackedOrder_SDL_PACKEDORDER_BGRA: SDL_PackedOrder = 8;
#[doc = " Packed component order, high bit -> low bit."]
pub type SDL_PackedOrder = u32;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_NONE: SDL_ArrayOrder = 0;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_RGB: SDL_ArrayOrder = 1;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_RGBA: SDL_ArrayOrder = 2;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_ARGB: SDL_ArrayOrder = 3;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_BGR: SDL_ArrayOrder = 4;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_BGRA: SDL_ArrayOrder = 5;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_ABGR: SDL_ArrayOrder = 6;
#[doc = " Array component order, low byte -> high byte."]
pub type SDL_ArrayOrder = u32;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_NONE: SDL_PackedLayout = 0;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_332: SDL_PackedLayout = 1;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_4444: SDL_PackedLayout = 2;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_1555: SDL_PackedLayout = 3;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_5551: SDL_PackedLayout = 4;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_565: SDL_PackedLayout = 5;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_8888: SDL_PackedLayout = 6;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_2101010: SDL_PackedLayout = 7;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_1010102: SDL_PackedLayout = 8;
#[doc = " Packed component layout."]
pub type SDL_PackedLayout = u32;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_UNKNOWN: SDL_PixelFormatEnum = 0;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX1LSB: SDL_PixelFormatEnum = 286261504;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX1MSB: SDL_PixelFormatEnum = 287310080;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX4LSB: SDL_PixelFormatEnum = 303039488;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX4MSB: SDL_PixelFormatEnum = 304088064;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX8: SDL_PixelFormatEnum = 318769153;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB332: SDL_PixelFormatEnum = 336660481;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB444: SDL_PixelFormatEnum = 353504258;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR444: SDL_PixelFormatEnum = 357698562;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB555: SDL_PixelFormatEnum = 353570562;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR555: SDL_PixelFormatEnum = 357764866;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB4444: SDL_PixelFormatEnum = 355602434;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA4444: SDL_PixelFormatEnum = 356651010;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR4444: SDL_PixelFormatEnum = 359796738;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA4444: SDL_PixelFormatEnum = 360845314;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB1555: SDL_PixelFormatEnum = 355667970;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA5551: SDL_PixelFormatEnum = 356782082;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR1555: SDL_PixelFormatEnum = 359862274;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA5551: SDL_PixelFormatEnum = 360976386;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB565: SDL_PixelFormatEnum = 353701890;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR565: SDL_PixelFormatEnum = 357896194;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB24: SDL_PixelFormatEnum = 386930691;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR24: SDL_PixelFormatEnum = 390076419;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB888: SDL_PixelFormatEnum = 370546692;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBX8888: SDL_PixelFormatEnum = 371595268;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR888: SDL_PixelFormatEnum = 374740996;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRX8888: SDL_PixelFormatEnum = 375789572;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB8888: SDL_PixelFormatEnum = 372645892;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA8888: SDL_PixelFormatEnum = 373694468;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR8888: SDL_PixelFormatEnum = 376840196;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA8888: SDL_PixelFormatEnum = 377888772;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB2101010: SDL_PixelFormatEnum = 372711428;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA32: SDL_PixelFormatEnum = 376840196;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB32: SDL_PixelFormatEnum = 377888772;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA32: SDL_PixelFormatEnum = 372645892;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR32: SDL_PixelFormatEnum = 373694468;
#[doc = "< Planar mode: Y + V + U  (3 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_YV12: SDL_PixelFormatEnum = 842094169;
#[doc = "< Planar mode: Y + U + V  (3 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_IYUV: SDL_PixelFormatEnum = 1448433993;
#[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_YUY2: SDL_PixelFormatEnum = 844715353;
#[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_UYVY: SDL_PixelFormatEnum = 1498831189;
#[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_YVYU: SDL_PixelFormatEnum = 1431918169;
#[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_NV12: SDL_PixelFormatEnum = 842094158;
#[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_NV21: SDL_PixelFormatEnum = 825382478;
#[doc = "< Android video texture format"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_EXTERNAL_OES: SDL_PixelFormatEnum = 542328143;
pub type SDL_PixelFormatEnum = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Color>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_Color))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Color>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_Color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Palette {
    pub ncolors: ::std::os::raw::c_int,
    pub colors: *mut SDL_Color,
    pub version: Uint32,
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Palette>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Palette))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Palette))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Palette>())).ncolors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Palette>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Palette>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Palette>())).refcount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = "  \\note Everything in the pixel format structure is read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PixelFormat {
    pub format: Uint32,
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub refcount: ::std::os::raw::c_int,
    pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    assert_eq!(
        ::std::mem::size_of::<SDL_PixelFormat>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_PixelFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).palette as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).BitsPerPixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BitsPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).BytesPerPixel as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BytesPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).padding as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Rmask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Gmask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Bmask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Amask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Rloss as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Gloss as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Bloss as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Aloss as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Aloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Rshift as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Gshift as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Bshift as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Ashift as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Ashift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).refcount as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " \\brief Get the human readable name of a pixel format"]
    pub fn SDL_GetPixelFormatName(format: Uint32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Convert one of the enumerated pixel formats to a bpp and RGBA masks."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible."]
    #[doc = ""]
    #[doc = "  \\sa SDL_MasksToPixelFormatEnum()"]
    pub fn SDL_PixelFormatEnumToMasks(
        format: Uint32,
        bpp: *mut ::std::os::raw::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Convert a bpp and RGBA masks to an enumerated pixel format."]
    #[doc = ""]
    #[doc = "  \\return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion"]
    #[doc = "          wasn't possible."]
    #[doc = ""]
    #[doc = "  \\sa SDL_PixelFormatEnumToMasks()"]
    pub fn SDL_MasksToPixelFormatEnum(
        bpp: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Create an SDL_PixelFormat structure from a pixel format enum."]
    pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
    #[doc = "  \\brief Free an SDL_PixelFormat structure."]
    pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
    #[doc = "  \\brief Create a palette structure with the specified number of color"]
    #[doc = "         entries."]
    #[doc = ""]
    #[doc = "  \\return A new palette, or NULL if there wasn't enough memory."]
    #[doc = ""]
    #[doc = "  \\note The palette entries are initialized to white."]
    #[doc = ""]
    #[doc = "  \\sa SDL_FreePalette()"]
    pub fn SDL_AllocPalette(ncolors: ::std::os::raw::c_int) -> *mut SDL_Palette;
}
extern "C" {
    #[doc = "  \\brief Set the palette for a pixel format structure."]
    pub fn SDL_SetPixelFormatPalette(
        format: *mut SDL_PixelFormat,
        palette: *mut SDL_Palette,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set a range of colors in a palette."]
    #[doc = ""]
    #[doc = "  \\param palette    The palette to modify."]
    #[doc = "  \\param colors     An array of colors to copy into the palette."]
    #[doc = "  \\param firstcolor The index of the first palette entry to modify."]
    #[doc = "  \\param ncolors    The number of entries to modify."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if not all of the colors could be set."]
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: ::std::os::raw::c_int,
        ncolors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Free a palette created with SDL_AllocPalette()."]
    #[doc = ""]
    #[doc = "  \\sa SDL_AllocPalette()"]
    pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
    #[doc = "  \\brief Maps an RGB triple to an opaque pixel value for a given pixel format."]
    #[doc = ""]
    #[doc = "  \\sa SDL_MapRGBA"]
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Maps an RGBA quadruple to a pixel value for a given pixel format."]
    #[doc = ""]
    #[doc = "  \\sa SDL_MapRGB"]
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormat,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Get the RGB components from a pixel of the specified format."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetRGBA"]
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
extern "C" {
    #[doc = "  \\brief Get the RGBA components from a pixel of the specified format."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetRGB"]
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
extern "C" {
    #[doc = "  \\brief Calculate a 256 entry gamma ramp for a gamma value."]
    pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
#[doc = "  \\brief  The structure that defines a point (integer)"]
#[doc = ""]
#[doc = "  \\sa SDL_EnclosePoints"]
#[doc = "  \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Point>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_Point))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Point>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Point))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Point>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Point>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief  The structure that defines a point (floating point)"]
#[doc = ""]
#[doc = "  \\sa SDL_EnclosePoints"]
#[doc = "  \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FPoint {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_FPoint() {
    assert_eq!(
        ::std::mem::size_of::<SDL_FPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_FPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_FPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_FPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief A rectangle, with the origin at the upper left (integer)."]
#[doc = ""]
#[doc = "  \\sa SDL_RectEmpty"]
#[doc = "  \\sa SDL_RectEquals"]
#[doc = "  \\sa SDL_HasIntersection"]
#[doc = "  \\sa SDL_IntersectRect"]
#[doc = "  \\sa SDL_UnionRect"]
#[doc = "  \\sa SDL_EnclosePoints"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(h)
        )
    );
}
#[doc = "  \\brief A rectangle, with the origin at the upper left (floating point)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FRect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_SDL_FRect() {
    assert_eq!(
        ::std::mem::size_of::<SDL_FRect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_FRect))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_FRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_FRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_FRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_FRect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_FRect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Determine whether two rectangles intersect."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Calculate the intersection of two rectangles."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    pub fn SDL_IntersectRect(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Calculate the union of two rectangles."]
    pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Calculate a minimal rectangle enclosing a set of points"]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if any points were within the clipping rect"]
    pub fn SDL_EnclosePoints(
        points: *const SDL_Point,
        count: ::std::os::raw::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Calculate the intersection of a rectangle and line segment."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    pub fn SDL_IntersectRectAndLine(
        rect: *const SDL_Rect,
        X1: *mut ::std::os::raw::c_int,
        Y1: *mut ::std::os::raw::c_int,
        X2: *mut ::std::os::raw::c_int,
        Y2: *mut ::std::os::raw::c_int,
    ) -> SDL_bool;
}
#[doc = "< no blending"]
#[doc = "dstRGBA = srcRGBA"]
pub const SDL_BlendMode_SDL_BLENDMODE_NONE: SDL_BlendMode = 0;
#[doc = "< alpha blending"]
#[doc = "dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))"]
#[doc = "dstA = srcA + (dstA * (1-srcA))"]
pub const SDL_BlendMode_SDL_BLENDMODE_BLEND: SDL_BlendMode = 1;
#[doc = "< additive blending"]
#[doc = "dstRGB = (srcRGB * srcA) + dstRGB"]
#[doc = "dstA = dstA"]
pub const SDL_BlendMode_SDL_BLENDMODE_ADD: SDL_BlendMode = 2;
#[doc = "< color modulate"]
#[doc = "dstRGB = srcRGB * dstRGB"]
#[doc = "dstA = dstA"]
pub const SDL_BlendMode_SDL_BLENDMODE_MOD: SDL_BlendMode = 4;
#[doc = "< color multiply"]
#[doc = "dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))"]
#[doc = "dstA = (srcA * dstA) + (dstA * (1-srcA))"]
pub const SDL_BlendMode_SDL_BLENDMODE_MUL: SDL_BlendMode = 8;
pub const SDL_BlendMode_SDL_BLENDMODE_INVALID: SDL_BlendMode = 2147483647;
#[doc = "  \\brief The blend mode used in SDL_RenderCopy() and drawing operations."]
pub type SDL_BlendMode = u32;
#[doc = "< dst + src: supported by all renderers"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_ADD: SDL_BlendOperation = 1;
#[doc = "< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_SUBTRACT: SDL_BlendOperation = 2;
#[doc = "< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_REV_SUBTRACT: SDL_BlendOperation = 3;
#[doc = "< min(dst, src) : supported by D3D11"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_MINIMUM: SDL_BlendOperation = 4;
#[doc = "< max(dst, src) : supported by D3D11"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_MAXIMUM: SDL_BlendOperation = 5;
#[doc = "  \\brief The blend operation used when combining source and destination pixel components"]
pub type SDL_BlendOperation = u32;
#[doc = "< 0, 0, 0, 0"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ZERO: SDL_BlendFactor = 1;
#[doc = "< 1, 1, 1, 1"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE: SDL_BlendFactor = 2;
#[doc = "< srcR, srcG, srcB, srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_COLOR: SDL_BlendFactor = 3;
#[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR: SDL_BlendFactor = 4;
#[doc = "< srcA, srcA, srcA, srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_ALPHA: SDL_BlendFactor = 5;
#[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: SDL_BlendFactor = 6;
#[doc = "< dstR, dstG, dstB, dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_COLOR: SDL_BlendFactor = 7;
#[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR: SDL_BlendFactor = 8;
#[doc = "< dstA, dstA, dstA, dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_ALPHA: SDL_BlendFactor = 9;
#[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA: SDL_BlendFactor = 10;
#[doc = "  \\brief The normalized factor used to multiply pixel components"]
pub type SDL_BlendFactor = u32;
extern "C" {
    #[doc = "  \\brief Create a custom blend mode, which may or may not be supported by a given renderer"]
    #[doc = ""]
    #[doc = "  \\param srcColorFactor source color factor"]
    #[doc = "  \\param dstColorFactor destination color factor"]
    #[doc = "  \\param colorOperation color operation"]
    #[doc = "  \\param srcAlphaFactor source alpha factor"]
    #[doc = "  \\param dstAlphaFactor destination alpha factor"]
    #[doc = "  \\param alphaOperation alpha operation"]
    #[doc = ""]
    #[doc = "  The result of the blend mode operation will be:"]
    #[doc = "      dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor"]
    #[doc = "  and"]
    #[doc = "      dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor"]
    pub fn SDL_ComposeCustomBlendMode(
        srcColorFactor: SDL_BlendFactor,
        dstColorFactor: SDL_BlendFactor,
        colorOperation: SDL_BlendOperation,
        srcAlphaFactor: SDL_BlendFactor,
        dstAlphaFactor: SDL_BlendFactor,
        alphaOperation: SDL_BlendOperation,
    ) -> SDL_BlendMode;
}
#[doc = " \\brief A collection of pixels used in software blitting."]
#[doc = ""]
#[doc = " \\note  This structure should be treated as read-only, except for \\c pixels,"]
#[doc = "        which, if not NULL, contains the raw pixel data for the surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Surface {
    #[doc = "< Read-only"]
    pub flags: Uint32,
    #[doc = "< Read-only"]
    pub format: *mut SDL_PixelFormat,
    #[doc = "< Read-only"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< Read-only"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< Read-only"]
    pub pitch: ::std::os::raw::c_int,
    #[doc = "< Read-write"]
    pub pixels: *mut ::std::os::raw::c_void,
    #[doc = "< Read-write"]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Read-only"]
    pub locked: ::std::os::raw::c_int,
    #[doc = "< Read-only"]
    pub lock_data: *mut ::std::os::raw::c_void,
    #[doc = "< Read-only"]
    pub clip_rect: SDL_Rect,
    #[doc = "< Private"]
    pub map: *mut SDL_BlitMap,
    #[doc = "< Read-mostly"]
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Surface>(),
        96usize,
        concat!("Size of: ", stringify!(SDL_Surface))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Surface>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Surface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).pitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).pixels as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).userdata as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).locked as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).lock_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(lock_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).clip_rect as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(clip_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).map as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).refcount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = " \\brief The type of function used for surface blitting functions."]
pub type SDL_blit = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "< Full range JPEG"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_JPEG: SDL_YUV_CONVERSION_MODE = 0;
#[doc = "< BT.601 (the default)"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_BT601: SDL_YUV_CONVERSION_MODE = 1;
#[doc = "< BT.709"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_BT709: SDL_YUV_CONVERSION_MODE = 2;
#[doc = "< BT.601 for SD content, BT.709 for HD content"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_AUTOMATIC: SDL_YUV_CONVERSION_MODE = 3;
#[doc = " \\brief The formula used for converting between YUV and RGB"]
pub type SDL_YUV_CONVERSION_MODE = u32;
extern "C" {
    #[doc = "  Allocate and free an RGB surface."]
    #[doc = ""]
    #[doc = "  If the depth is 4 or 8 bits, an empty palette is allocated for the surface."]
    #[doc = "  If the depth is greater than 8 bits, the pixel format is set using the"]
    #[doc = "  flags '[RGB]mask'."]
    #[doc = ""]
    #[doc = "  If the function runs out of memory, it will return NULL."]
    #[doc = ""]
    #[doc = "  \\param flags The \\c flags are obsolete and should be set to 0."]
    #[doc = "  \\param width The width in pixels of the surface to create."]
    #[doc = "  \\param height The height in pixels of the surface to create."]
    #[doc = "  \\param depth The depth in bits of the surface to create."]
    #[doc = "  \\param Rmask The red mask of the surface to create."]
    #[doc = "  \\param Gmask The green mask of the surface to create."]
    #[doc = "  \\param Bmask The blue mask of the surface to create."]
    #[doc = "  \\param Amask The alpha mask of the surface to create."]
    pub fn SDL_CreateRGBSurface(
        flags: Uint32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceWithFormat(
        flags: Uint32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceFrom(
        pixels: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceWithFormatFrom(
        pixels: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = "  \\brief Set the palette used by a surface."]
    #[doc = ""]
    #[doc = "  \\return 0, or -1 if the surface format doesn't use a palette."]
    #[doc = ""]
    #[doc = "  \\note A single palette can be shared with many surfaces."]
    pub fn SDL_SetSurfacePalette(
        surface: *mut SDL_Surface,
        palette: *mut SDL_Palette,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets up a surface for directly accessing the pixels."]
    #[doc = ""]
    #[doc = "  Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write"]
    #[doc = "  to and read from \\c surface->pixels, using the pixel format stored in"]
    #[doc = "  \\c surface->format.  Once you are done accessing the surface, you should"]
    #[doc = "  use SDL_UnlockSurface() to release it."]
    #[doc = ""]
    #[doc = "  Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates"]
    #[doc = "  to 0, then you can read and write to the surface at any time, and the"]
    #[doc = "  pixel format of the surface will not change."]
    #[doc = ""]
    #[doc = "  No operating system or library calls should be made between lock/unlock"]
    #[doc = "  pairs, as critical system locks may be held during this time."]
    #[doc = ""]
    #[doc = "  SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked."]
    #[doc = ""]
    #[doc = "  \\sa SDL_UnlockSurface()"]
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\sa SDL_LockSurface()"]
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = "  Load a surface from a seekable SDL data stream (memory or file)."]
    #[doc = ""]
    #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
    #[doc = ""]
    #[doc = "  The new surface should be freed with SDL_FreeSurface()."]
    #[doc = ""]
    #[doc = "  \\return the new surface, or NULL if there was an error."]
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: ::std::os::raw::c_int) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = "  Save a surface to a seekable SDL data stream (memory or file)."]
    #[doc = ""]
    #[doc = "  Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the"]
    #[doc = "  BMP directly. Other RGB formats with 8-bit or higher get converted to a"]
    #[doc = "  24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit"]
    #[doc = "  surface before they are saved. YUV and paletted 1-bit and 4-bit formats are"]
    #[doc = "  not supported."]
    #[doc = ""]
    #[doc = "  If \\c freedst is non-zero, the stream will be closed after being written."]
    #[doc = ""]
    #[doc = "  \\return 0 if successful or -1 if there was an error."]
    pub fn SDL_SaveBMP_RW(
        surface: *mut SDL_Surface,
        dst: *mut SDL_RWops,
        freedst: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the RLE acceleration hint for a surface."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid"]
    #[doc = ""]
    #[doc = "  \\note If RLE is enabled, colorkey and alpha blending blits are much faster,"]
    #[doc = "        but the surface must be locked before directly accessing the pixels."]
    pub fn SDL_SetSurfaceRLE(
        surface: *mut SDL_Surface,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the color key (transparent pixel) in a blittable surface."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to update"]
    #[doc = "  \\param flag Non-zero to enable colorkey and 0 to disable colorkey"]
    #[doc = "  \\param key The transparent pixel in the native surface format"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid"]
    #[doc = ""]
    #[doc = "  You can pass SDL_RLEACCEL to enable RLE accelerated blits."]
    pub fn SDL_SetColorKey(
        surface: *mut SDL_Surface,
        flag: ::std::os::raw::c_int,
        key: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Returns whether the surface has a color key"]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key"]
    pub fn SDL_HasColorKey(surface: *mut SDL_Surface) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Gets the color key (transparent pixel) in a blittable surface."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to update"]
    #[doc = "  \\param key A pointer filled in with the transparent pixel in the native"]
    #[doc = "             surface format"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid or colorkey is not"]
    #[doc = "          enabled."]
    pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional color value used in blit operations."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to update."]
    #[doc = "  \\param r The red color value multiplied into blit operations."]
    #[doc = "  \\param g The green color value multiplied into blit operations."]
    #[doc = "  \\param b The blue color value multiplied into blit operations."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetSurfaceColorMod()"]
    pub fn SDL_SetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional color value used in blit operations."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to query."]
    #[doc = "  \\param r A pointer filled in with the current red color value."]
    #[doc = "  \\param g A pointer filled in with the current green color value."]
    #[doc = "  \\param b A pointer filled in with the current blue color value."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetSurfaceColorMod()"]
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional alpha value used in blit operations."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to update."]
    #[doc = "  \\param alpha The alpha value multiplied into blit operations."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetSurfaceAlphaMod()"]
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional alpha value used in blit operations."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to query."]
    #[doc = "  \\param alpha A pointer filled in with the current alpha value."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetSurfaceAlphaMod()"]
    pub fn SDL_GetSurfaceAlphaMod(
        surface: *mut SDL_Surface,
        alpha: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the blend mode used for blit operations."]
    #[doc = ""]
    #[doc = "  \\param surface The surface to update."]
    #[doc = "  \\param blendMode ::SDL_BlendMode to use for blit blending."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the parameters are not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetSurfaceBlendMode()"]
    pub fn SDL_SetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the blend mode used for blit operations."]
    #[doc = ""]
    #[doc = "  \\param surface   The surface to query."]
    #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetSurfaceBlendMode()"]
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Sets the clipping rectangle for the destination surface in a blit."]
    #[doc = ""]
    #[doc = "  If the clip rectangle is NULL, clipping will be disabled."]
    #[doc = ""]
    #[doc = "  If the clip rectangle doesn't intersect the surface, the function will"]
    #[doc = "  return SDL_FALSE and blits will be completely clipped.  Otherwise the"]
    #[doc = "  function returns SDL_TRUE and blits to the surface will be clipped to"]
    #[doc = "  the intersection of the surface area and the clipping rectangle."]
    #[doc = ""]
    #[doc = "  Note that blits are automatically clipped to the edges of the source"]
    #[doc = "  and destination surfaces."]
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = "  Gets the clipping rectangle for the destination surface in a blit."]
    #[doc = ""]
    #[doc = "  \\c rect must be a pointer to a valid rectangle which will be filled"]
    #[doc = "  with the correct values."]
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = "  Creates a new surface of the specified format, and then copies and maps"]
    #[doc = "  the given surface to it so the blit of the converted surface will be as"]
    #[doc = "  fast as possible.  If this function fails, it returns NULL."]
    #[doc = ""]
    #[doc = "  The \\c flags parameter is passed to SDL_CreateRGBSurface() and has those"]
    #[doc = "  semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and"]
    #[doc = "  SDL will try to RLE accelerate colorkey and alpha blits in the resulting"]
    #[doc = "  surface."]
    pub fn SDL_ConvertSurface(
        src: *mut SDL_Surface,
        fmt: *const SDL_PixelFormat,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_ConvertSurfaceFormat(
        src: *mut SDL_Surface,
        pixel_format: Uint32,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " \\brief Copy a block of pixels of one format to another format"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if there was an error"]
    pub fn SDL_ConvertPixels(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        src_format: Uint32,
        src: *const ::std::os::raw::c_void,
        src_pitch: ::std::os::raw::c_int,
        dst_format: Uint32,
        dst: *mut ::std::os::raw::c_void,
        dst_pitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Performs a fast fill of the given rectangle with \\c color."]
    #[doc = ""]
    #[doc = "  If \\c rect is NULL, the whole surface will be filled with \\c color."]
    #[doc = ""]
    #[doc = "  The color should be a pixel of the format used by the surface, and"]
    #[doc = "  can be generated by the SDL_MapRGB() function."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error."]
    pub fn SDL_FillRect(
        dst: *mut SDL_Surface,
        rect: *const SDL_Rect,
        color: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_FillRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: ::std::os::raw::c_int,
        color: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This is the public blit function, SDL_BlitSurface(), and it performs"]
    #[doc = "  rectangle validation and clipping before passing it to SDL_LowerBlit()"]
    pub fn SDL_UpperBlit(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This is a semi-private blit function and it performs low-level surface"]
    #[doc = "  blitting only."]
    pub fn SDL_LowerBlit(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Perform a fast, low quality, stretch blit between two surfaces of the"]
    #[doc = "         same pixel format."]
    #[doc = ""]
    #[doc = "  \\note This function uses a static buffer, and is not thread-safe."]
    pub fn SDL_SoftStretch(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This is the public scaled blit function, SDL_BlitScaled(), and it performs"]
    #[doc = "  rectangle validation and clipping before passing it to SDL_LowerBlitScaled()"]
    pub fn SDL_UpperBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This is a semi-private blit function and it performs low-level surface"]
    #[doc = "  scaled blitting only."]
    pub fn SDL_LowerBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the YUV conversion mode"]
    pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE);
}
extern "C" {
    #[doc = "  \\brief Get the YUV conversion mode"]
    pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE;
}
extern "C" {
    #[doc = "  \\brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC"]
    pub fn SDL_GetYUVConversionModeForResolution(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SDL_YUV_CONVERSION_MODE;
}
#[doc = "  \\brief  The structure that defines a display mode"]
#[doc = ""]
#[doc = "  \\sa SDL_GetNumDisplayModes()"]
#[doc = "  \\sa SDL_GetDisplayMode()"]
#[doc = "  \\sa SDL_GetDesktopDisplayMode()"]
#[doc = "  \\sa SDL_GetCurrentDisplayMode()"]
#[doc = "  \\sa SDL_GetClosestDisplayMode()"]
#[doc = "  \\sa SDL_SetWindowDisplayMode()"]
#[doc = "  \\sa SDL_GetWindowDisplayMode()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayMode {
    #[doc = "< pixel format"]
    pub format: Uint32,
    #[doc = "< width, in screen coordinates"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< height, in screen coordinates"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< refresh rate (or zero for unspecified)"]
    pub refresh_rate: ::std::os::raw::c_int,
    #[doc = "< driver-specific data, initialize to 0"]
    pub driverdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DisplayMode>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DisplayMode>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayMode>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayMode>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayMode>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayMode>())).refresh_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(refresh_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayMode>())).driverdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(driverdata)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
#[doc = "< fullscreen window"]
pub const SDL_WindowFlags_SDL_WINDOW_FULLSCREEN: SDL_WindowFlags = 1;
#[doc = "< window usable with OpenGL context"]
pub const SDL_WindowFlags_SDL_WINDOW_OPENGL: SDL_WindowFlags = 2;
#[doc = "< window is visible"]
pub const SDL_WindowFlags_SDL_WINDOW_SHOWN: SDL_WindowFlags = 4;
#[doc = "< window is not visible"]
pub const SDL_WindowFlags_SDL_WINDOW_HIDDEN: SDL_WindowFlags = 8;
#[doc = "< no window decoration"]
pub const SDL_WindowFlags_SDL_WINDOW_BORDERLESS: SDL_WindowFlags = 16;
#[doc = "< window can be resized"]
pub const SDL_WindowFlags_SDL_WINDOW_RESIZABLE: SDL_WindowFlags = 32;
#[doc = "< window is minimized"]
pub const SDL_WindowFlags_SDL_WINDOW_MINIMIZED: SDL_WindowFlags = 64;
#[doc = "< window is maximized"]
pub const SDL_WindowFlags_SDL_WINDOW_MAXIMIZED: SDL_WindowFlags = 128;
#[doc = "< window has grabbed input focus"]
pub const SDL_WindowFlags_SDL_WINDOW_INPUT_GRABBED: SDL_WindowFlags = 256;
#[doc = "< window has input focus"]
pub const SDL_WindowFlags_SDL_WINDOW_INPUT_FOCUS: SDL_WindowFlags = 512;
#[doc = "< window has mouse focus"]
pub const SDL_WindowFlags_SDL_WINDOW_MOUSE_FOCUS: SDL_WindowFlags = 1024;
pub const SDL_WindowFlags_SDL_WINDOW_FULLSCREEN_DESKTOP: SDL_WindowFlags = 4097;
#[doc = "< window not created by SDL"]
pub const SDL_WindowFlags_SDL_WINDOW_FOREIGN: SDL_WindowFlags = 2048;
#[doc = "< window should be created in high-DPI mode if supported."]
#[doc = "On macOS NSHighResolutionCapable must be set true in the"]
#[doc = "application's Info.plist for this to have any effect."]
pub const SDL_WindowFlags_SDL_WINDOW_ALLOW_HIGHDPI: SDL_WindowFlags = 8192;
#[doc = "< window has mouse captured (unrelated to INPUT_GRABBED)"]
pub const SDL_WindowFlags_SDL_WINDOW_MOUSE_CAPTURE: SDL_WindowFlags = 16384;
#[doc = "< window should always be above others"]
pub const SDL_WindowFlags_SDL_WINDOW_ALWAYS_ON_TOP: SDL_WindowFlags = 32768;
#[doc = "< window should not be added to the taskbar"]
pub const SDL_WindowFlags_SDL_WINDOW_SKIP_TASKBAR: SDL_WindowFlags = 65536;
#[doc = "< window should be treated as a utility window"]
pub const SDL_WindowFlags_SDL_WINDOW_UTILITY: SDL_WindowFlags = 131072;
#[doc = "< window should be treated as a tooltip"]
pub const SDL_WindowFlags_SDL_WINDOW_TOOLTIP: SDL_WindowFlags = 262144;
#[doc = "< window should be treated as a popup menu"]
pub const SDL_WindowFlags_SDL_WINDOW_POPUP_MENU: SDL_WindowFlags = 524288;
#[doc = "< window usable for Vulkan surface"]
pub const SDL_WindowFlags_SDL_WINDOW_VULKAN: SDL_WindowFlags = 268435456;
#[doc = "  \\brief The flags on a window"]
#[doc = ""]
#[doc = "  \\sa SDL_GetWindowFlags()"]
pub type SDL_WindowFlags = u32;
#[doc = "< Never used"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_NONE: SDL_WindowEventID = 0;
#[doc = "< Window has been shown"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_SHOWN: SDL_WindowEventID = 1;
#[doc = "< Window has been hidden"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_HIDDEN: SDL_WindowEventID = 2;
#[doc = "< Window has been exposed and should be"]
#[doc = "redrawn"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_EXPOSED: SDL_WindowEventID = 3;
#[doc = "< Window has been moved to data1, data2"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_MOVED: SDL_WindowEventID = 4;
#[doc = "< Window has been resized to data1xdata2"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_RESIZED: SDL_WindowEventID = 5;
#[doc = "< The window size has changed, either as"]
#[doc = "a result of an API call or through the"]
#[doc = "system or user changing the window size."]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_SIZE_CHANGED: SDL_WindowEventID = 6;
#[doc = "< Window has been minimized"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_MINIMIZED: SDL_WindowEventID = 7;
#[doc = "< Window has been maximized"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_MAXIMIZED: SDL_WindowEventID = 8;
#[doc = "< Window has been restored to normal size"]
#[doc = "and position"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_RESTORED: SDL_WindowEventID = 9;
#[doc = "< Window has gained mouse focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_ENTER: SDL_WindowEventID = 10;
#[doc = "< Window has lost mouse focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_LEAVE: SDL_WindowEventID = 11;
#[doc = "< Window has gained keyboard focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_FOCUS_GAINED: SDL_WindowEventID = 12;
#[doc = "< Window has lost keyboard focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_FOCUS_LOST: SDL_WindowEventID = 13;
#[doc = "< The window manager requests that the window be closed"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_CLOSE: SDL_WindowEventID = 14;
#[doc = "< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_TAKE_FOCUS: SDL_WindowEventID = 15;
#[doc = "< Window had a hit test that wasn't SDL_HITTEST_NORMAL."]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_HIT_TEST: SDL_WindowEventID = 16;
#[doc = "  \\brief Event subtype for window events"]
pub type SDL_WindowEventID = u32;
#[doc = "< Never used"]
pub const SDL_DisplayEventID_SDL_DISPLAYEVENT_NONE: SDL_DisplayEventID = 0;
#[doc = "< Display orientation has changed to data1"]
pub const SDL_DisplayEventID_SDL_DISPLAYEVENT_ORIENTATION: SDL_DisplayEventID = 1;
#[doc = "  \\brief Event subtype for display events"]
pub type SDL_DisplayEventID = u32;
#[doc = "< The display orientation can't be determined"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_UNKNOWN: SDL_DisplayOrientation = 0;
#[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_LANDSCAPE: SDL_DisplayOrientation = 1;
#[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_LANDSCAPE_FLIPPED: SDL_DisplayOrientation = 2;
#[doc = "< The display is in portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_PORTRAIT: SDL_DisplayOrientation = 3;
#[doc = "< The display is in portrait mode, upside down"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_PORTRAIT_FLIPPED: SDL_DisplayOrientation = 4;
pub type SDL_DisplayOrientation = u32;
#[doc = "  \\brief An opaque handle to an OpenGL context."]
pub type SDL_GLContext = *mut ::std::os::raw::c_void;
pub const SDL_GLattr_SDL_GL_RED_SIZE: SDL_GLattr = 0;
pub const SDL_GLattr_SDL_GL_GREEN_SIZE: SDL_GLattr = 1;
pub const SDL_GLattr_SDL_GL_BLUE_SIZE: SDL_GLattr = 2;
pub const SDL_GLattr_SDL_GL_ALPHA_SIZE: SDL_GLattr = 3;
pub const SDL_GLattr_SDL_GL_BUFFER_SIZE: SDL_GLattr = 4;
pub const SDL_GLattr_SDL_GL_DOUBLEBUFFER: SDL_GLattr = 5;
pub const SDL_GLattr_SDL_GL_DEPTH_SIZE: SDL_GLattr = 6;
pub const SDL_GLattr_SDL_GL_STENCIL_SIZE: SDL_GLattr = 7;
pub const SDL_GLattr_SDL_GL_ACCUM_RED_SIZE: SDL_GLattr = 8;
pub const SDL_GLattr_SDL_GL_ACCUM_GREEN_SIZE: SDL_GLattr = 9;
pub const SDL_GLattr_SDL_GL_ACCUM_BLUE_SIZE: SDL_GLattr = 10;
pub const SDL_GLattr_SDL_GL_ACCUM_ALPHA_SIZE: SDL_GLattr = 11;
pub const SDL_GLattr_SDL_GL_STEREO: SDL_GLattr = 12;
pub const SDL_GLattr_SDL_GL_MULTISAMPLEBUFFERS: SDL_GLattr = 13;
pub const SDL_GLattr_SDL_GL_MULTISAMPLESAMPLES: SDL_GLattr = 14;
pub const SDL_GLattr_SDL_GL_ACCELERATED_VISUAL: SDL_GLattr = 15;
pub const SDL_GLattr_SDL_GL_RETAINED_BACKING: SDL_GLattr = 16;
pub const SDL_GLattr_SDL_GL_CONTEXT_MAJOR_VERSION: SDL_GLattr = 17;
pub const SDL_GLattr_SDL_GL_CONTEXT_MINOR_VERSION: SDL_GLattr = 18;
pub const SDL_GLattr_SDL_GL_CONTEXT_EGL: SDL_GLattr = 19;
pub const SDL_GLattr_SDL_GL_CONTEXT_FLAGS: SDL_GLattr = 20;
pub const SDL_GLattr_SDL_GL_CONTEXT_PROFILE_MASK: SDL_GLattr = 21;
pub const SDL_GLattr_SDL_GL_SHARE_WITH_CURRENT_CONTEXT: SDL_GLattr = 22;
pub const SDL_GLattr_SDL_GL_FRAMEBUFFER_SRGB_CAPABLE: SDL_GLattr = 23;
pub const SDL_GLattr_SDL_GL_CONTEXT_RELEASE_BEHAVIOR: SDL_GLattr = 24;
pub const SDL_GLattr_SDL_GL_CONTEXT_RESET_NOTIFICATION: SDL_GLattr = 25;
pub const SDL_GLattr_SDL_GL_CONTEXT_NO_ERROR: SDL_GLattr = 26;
#[doc = "  \\brief OpenGL configuration attributes"]
pub type SDL_GLattr = u32;
pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_CORE: SDL_GLprofile = 1;
pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: SDL_GLprofile = 2;
#[doc = "< GLX_CONTEXT_ES2_PROFILE_BIT_EXT"]
pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_ES: SDL_GLprofile = 4;
pub type SDL_GLprofile = u32;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_DEBUG_FLAG: SDL_GLcontextFlag = 1;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: SDL_GLcontextFlag = 2;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: SDL_GLcontextFlag = 4;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: SDL_GLcontextFlag = 8;
pub type SDL_GLcontextFlag = u32;
pub const SDL_GLcontextReleaseFlag_SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: SDL_GLcontextReleaseFlag =
    0;
pub const SDL_GLcontextReleaseFlag_SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: SDL_GLcontextReleaseFlag =
    1;
pub type SDL_GLcontextReleaseFlag = u32;
pub const SDL_GLContextResetNotification_SDL_GL_CONTEXT_RESET_NO_NOTIFICATION:
    SDL_GLContextResetNotification = 0;
pub const SDL_GLContextResetNotification_SDL_GL_CONTEXT_RESET_LOSE_CONTEXT:
    SDL_GLContextResetNotification = 1;
pub type SDL_GLContextResetNotification = u32;
extern "C" {
    #[doc = "  \\brief Get the number of video drivers compiled into SDL"]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetVideoDriver()"]
    pub fn SDL_GetNumVideoDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the name of a built in video driver."]
    #[doc = ""]
    #[doc = "  \\note The video drivers are presented in the order in which they are"]
    #[doc = "        normally checked during initialization."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumVideoDrivers()"]
    pub fn SDL_GetVideoDriver(index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Initialize the video subsystem, optionally specifying a video driver."]
    #[doc = ""]
    #[doc = "  \\param driver_name Initialize a specific driver by name, or NULL for the"]
    #[doc = "                     default video driver."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, -1 on error"]
    #[doc = ""]
    #[doc = "  This function initializes the video subsystem; setting up a connection"]
    #[doc = "  to the window manager, etc, and determines the available display modes"]
    #[doc = "  and pixel formats, but does not initialize a window or graphics mode."]
    #[doc = ""]
    #[doc = "  \\sa SDL_VideoQuit()"]
    pub fn SDL_VideoInit(driver_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Shuts down the video subsystem."]
    #[doc = ""]
    #[doc = "  This function closes all windows, and restores the original video mode."]
    #[doc = ""]
    #[doc = "  \\sa SDL_VideoInit()"]
    pub fn SDL_VideoQuit();
}
extern "C" {
    #[doc = "  \\brief Returns the name of the currently initialized video driver."]
    #[doc = ""]
    #[doc = "  \\return The name of the current video driver or NULL if no driver"]
    #[doc = "          has been initialized"]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumVideoDrivers()"]
    #[doc = "  \\sa SDL_GetVideoDriver()"]
    pub fn SDL_GetCurrentVideoDriver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Returns the number of available video displays."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetDisplayBounds()"]
    pub fn SDL_GetNumVideoDisplays() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the name of a display in UTF-8 encoding"]
    #[doc = ""]
    #[doc = "  \\return The name of a display, or NULL for an invalid display index."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayName(displayIndex: ::std::os::raw::c_int)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the desktop area represented by a display, with the primary"]
    #[doc = "         display located at 0,0"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the index is out of range."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayBounds(
        displayIndex: ::std::os::raw::c_int,
        rect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the usable desktop area represented by a display, with the"]
    #[doc = "         primary display located at 0,0"]
    #[doc = ""]
    #[doc = "  This is the same area as SDL_GetDisplayBounds() reports, but with portions"]
    #[doc = "  reserved by the system removed. For example, on Mac OS X, this subtracts"]
    #[doc = "  the area occupied by the menu bar and dock."]
    #[doc = ""]
    #[doc = "  Setting a window to be fullscreen generally bypasses these unusable areas,"]
    #[doc = "  so these are good guidelines for the maximum space available to a"]
    #[doc = "  non-fullscreen window."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the index is out of range."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetDisplayBounds()"]
    #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayUsableBounds(
        displayIndex: ::std::os::raw::c_int,
        rect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the dots/pixels-per-inch for a display"]
    #[doc = ""]
    #[doc = "  \\note Diagonal, horizontal and vertical DPI can all be optionally"]
    #[doc = "        returned if the parameter is non-NULL."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if no DPI information is available or the index is out of range."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayDPI(
        displayIndex: ::std::os::raw::c_int,
        ddpi: *mut f32,
        hdpi: *mut f32,
        vdpi: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the orientation of a display"]
    #[doc = ""]
    #[doc = "  \\return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayOrientation(displayIndex: ::std::os::raw::c_int)
        -> SDL_DisplayOrientation;
}
extern "C" {
    #[doc = "  \\brief Returns the number of available display modes."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetDisplayMode()"]
    pub fn SDL_GetNumDisplayModes(displayIndex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about a specific display mode."]
    #[doc = ""]
    #[doc = "  \\note The display modes are sorted in this priority:"]
    #[doc = "        \\li bits per pixel -> more colors to fewer colors"]
    #[doc = "        \\li width -> largest to smallest"]
    #[doc = "        \\li height -> largest to smallest"]
    #[doc = "        \\li refresh rate -> highest to lowest"]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumDisplayModes()"]
    pub fn SDL_GetDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        modeIndex: ::std::os::raw::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about the desktop display mode."]
    pub fn SDL_GetDesktopDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about the current display mode."]
    pub fn SDL_GetCurrentDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the closest match to the requested display mode."]
    #[doc = ""]
    #[doc = "  \\param displayIndex The index of display from which mode should be queried."]
    #[doc = "  \\param mode The desired display mode"]
    #[doc = "  \\param closest A pointer to a display mode to be filled in with the closest"]
    #[doc = "                 match of the available display modes."]
    #[doc = ""]
    #[doc = "  \\return The passed in value \\c closest, or NULL if no matching video mode"]
    #[doc = "          was available."]
    #[doc = ""]
    #[doc = "  The available display modes are scanned, and \\c closest is filled in with the"]
    #[doc = "  closest mode matching the requested mode and returned.  The mode format and"]
    #[doc = "  refresh_rate default to the desktop mode if they are 0.  The modes are"]
    #[doc = "  scanned with size being first priority, format being second priority, and"]
    #[doc = "  finally checking the refresh_rate.  If all the available modes are too"]
    #[doc = "  small, then NULL is returned."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetNumDisplayModes()"]
    #[doc = "  \\sa SDL_GetDisplayMode()"]
    pub fn SDL_GetClosestDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        mode: *const SDL_DisplayMode,
        closest: *mut SDL_DisplayMode,
    ) -> *mut SDL_DisplayMode;
}
extern "C" {
    #[doc = "  \\brief Get the display index associated with a window."]
    #[doc = ""]
    #[doc = "  \\return the display index of the display containing the center of the"]
    #[doc = "          window, or -1 on error."]
    pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the display mode used when a fullscreen window is visible."]
    #[doc = ""]
    #[doc = "  By default the window's dimensions and the desktop format and refresh rate"]
    #[doc = "  are used."]
    #[doc = ""]
    #[doc = "  \\param window The window for which the display mode should be set."]
    #[doc = "  \\param mode The mode to use, or NULL for the default mode."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if setting the display mode failed."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowDisplayMode()"]
    #[doc = "  \\sa SDL_SetWindowFullscreen()"]
    pub fn SDL_SetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about the display mode used when a fullscreen"]
    #[doc = "         window is visible."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
    #[doc = "  \\sa SDL_SetWindowFullscreen()"]
    pub fn SDL_GetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the pixel format associated with the window."]
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Create a window with the specified position, dimensions, and flags."]
    #[doc = ""]
    #[doc = "  \\param title The title of the window, in UTF-8 encoding."]
    #[doc = "  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
    #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = "  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
    #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = "  \\param w     The width of the window, in screen coordinates."]
    #[doc = "  \\param h     The height of the window, in screen coordinates."]
    #[doc = "  \\param flags The flags for the window, a mask of any of the following:"]
    #[doc = "               ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,"]
    #[doc = "               ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,"]
    #[doc = "               ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,"]
    #[doc = "               ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,"]
    #[doc = "               ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN."]
    #[doc = ""]
    #[doc = "  \\return The created window, or NULL if window creation failed."]
    #[doc = ""]
    #[doc = "  If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size"]
    #[doc = "  in pixels may differ from its size in screen coordinates on platforms with"]
    #[doc = "  high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query"]
    #[doc = "  the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),"]
    #[doc = "  SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the"]
    #[doc = "  drawable size in pixels."]
    #[doc = ""]
    #[doc = "  If the window is created with any of the SDL_WINDOW_OPENGL or"]
    #[doc = "  SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function"]
    #[doc = "  (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the"]
    #[doc = "  corresponding UnloadLibrary function is called by SDL_DestroyWindow()."]
    #[doc = ""]
    #[doc = "  If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,"]
    #[doc = "  SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail."]
    #[doc = ""]
    #[doc = "  \\note On non-Apple devices, SDL requires you to either not link to the"]
    #[doc = "        Vulkan loader or link to a dynamic library version. This limitation"]
    #[doc = "        may be removed in a future version of SDL."]
    #[doc = ""]
    #[doc = "  \\sa SDL_DestroyWindow()"]
    #[doc = "  \\sa SDL_GL_LoadLibrary()"]
    #[doc = "  \\sa SDL_Vulkan_LoadLibrary()"]
    pub fn SDL_CreateWindow(
        title: *const ::std::os::raw::c_char,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Create an SDL window from an existing native window."]
    #[doc = ""]
    #[doc = "  \\param data A pointer to driver-dependent window creation data"]
    #[doc = ""]
    #[doc = "  \\return The created window, or NULL if window creation failed."]
    #[doc = ""]
    #[doc = "  \\sa SDL_DestroyWindow()"]
    pub fn SDL_CreateWindowFrom(data: *const ::std::os::raw::c_void) -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get the numeric ID of a window, for logging purposes."]
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Get a window from a stored ID, or NULL if it doesn't exist."]
    pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get the window flags."]
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Set the title of a window, in UTF-8 format."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowTitle()"]
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "  \\brief Get the title of a window, in UTF-8 format."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowTitle()"]
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Set the icon for a window."]
    #[doc = ""]
    #[doc = "  \\param window The window for which the icon should be set."]
    #[doc = "  \\param icon The icon for the window."]
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
    #[doc = "  \\brief Associate an arbitrary named pointer with a window."]
    #[doc = ""]
    #[doc = "  \\param window   The window to associate with the pointer."]
    #[doc = "  \\param name     The name of the pointer."]
    #[doc = "  \\param userdata The associated pointer."]
    #[doc = ""]
    #[doc = "  \\return The previous value associated with 'name'"]
    #[doc = ""]
    #[doc = "  \\note The name is case-sensitive."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowData()"]
    pub fn SDL_SetWindowData(
        window: *mut SDL_Window,
        name: *const ::std::os::raw::c_char,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  \\brief Retrieve the data pointer associated with a window."]
    #[doc = ""]
    #[doc = "  \\param window   The window to query."]
    #[doc = "  \\param name     The name of the pointer."]
    #[doc = ""]
    #[doc = "  \\return The value associated with 'name'"]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowData()"]
    pub fn SDL_GetWindowData(
        window: *mut SDL_Window,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  \\brief Set the position of a window."]
    #[doc = ""]
    #[doc = "  \\param window   The window to reposition."]
    #[doc = "  \\param x        The x coordinate of the window in screen coordinates, or"]
    #[doc = "                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = "  \\param y        The y coordinate of the window in screen coordinates, or"]
    #[doc = "                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = ""]
    #[doc = "  \\note The window coordinate origin is the upper left of the display."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowPosition()"]
    pub fn SDL_SetWindowPosition(
        window: *mut SDL_Window,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the position of a window."]
    #[doc = ""]
    #[doc = "  \\param window   The window to query."]
    #[doc = "  \\param x        Pointer to variable for storing the x position, in screen"]
    #[doc = "                  coordinates. May be NULL."]
    #[doc = "  \\param y        Pointer to variable for storing the y position, in screen"]
    #[doc = "                  coordinates. May be NULL."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowPosition()"]
    pub fn SDL_GetWindowPosition(
        window: *mut SDL_Window,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the size of a window's client area."]
    #[doc = ""]
    #[doc = "  \\param window   The window to resize."]
    #[doc = "  \\param w        The width of the window, in screen coordinates. Must be >0."]
    #[doc = "  \\param h        The height of the window, in screen coordinates. Must be >0."]
    #[doc = ""]
    #[doc = "  \\note Fullscreen windows automatically match the size of the display mode,"]
    #[doc = "        and you should use SDL_SetWindowDisplayMode() to change their size."]
    #[doc = ""]
    #[doc = "  The window size in screen coordinates may differ from the size in pixels, if"]
    #[doc = "  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with"]
    #[doc = "  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or"]
    #[doc = "  SDL_GetRendererOutputSize() to get the real client area size in pixels."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowSize()"]
    #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
    pub fn SDL_SetWindowSize(
        window: *mut SDL_Window,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the size of a window's client area."]
    #[doc = ""]
    #[doc = "  \\param window   The window to query."]
    #[doc = "  \\param w        Pointer to variable for storing the width, in screen"]
    #[doc = "                  coordinates. May be NULL."]
    #[doc = "  \\param h        Pointer to variable for storing the height, in screen"]
    #[doc = "                  coordinates. May be NULL."]
    #[doc = ""]
    #[doc = "  The window size in screen coordinates may differ from the size in pixels, if"]
    #[doc = "  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with"]
    #[doc = "  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or"]
    #[doc = "  SDL_GetRendererOutputSize() to get the real client area size in pixels."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowSize()"]
    pub fn SDL_GetWindowSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the size of a window's borders (decorations) around the client area."]
    #[doc = ""]
    #[doc = "  \\param window The window to query."]
    #[doc = "  \\param top Pointer to variable for storing the size of the top border. NULL is permitted."]
    #[doc = "  \\param left Pointer to variable for storing the size of the left border. NULL is permitted."]
    #[doc = "  \\param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted."]
    #[doc = "  \\param right Pointer to variable for storing the size of the right border. NULL is permitted."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if getting this information is not supported."]
    #[doc = ""]
    #[doc = "  \\note if this function fails (returns -1), the size values will be"]
    #[doc = "        initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as"]
    #[doc = "        if the window in question was borderless."]
    pub fn SDL_GetWindowBordersSize(
        window: *mut SDL_Window,
        top: *mut ::std::os::raw::c_int,
        left: *mut ::std::os::raw::c_int,
        bottom: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the minimum size of a window's client area."]
    #[doc = ""]
    #[doc = "  \\param window    The window to set a new minimum size."]
    #[doc = "  \\param min_w     The minimum width of the window, must be >0"]
    #[doc = "  \\param min_h     The minimum height of the window, must be >0"]
    #[doc = ""]
    #[doc = "  \\note You can't change the minimum size of a fullscreen window, it"]
    #[doc = "        automatically matches the size of the display mode."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowMinimumSize()"]
    #[doc = "  \\sa SDL_SetWindowMaximumSize()"]
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: ::std::os::raw::c_int,
        min_h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the minimum size of a window's client area."]
    #[doc = ""]
    #[doc = "  \\param window   The window to query."]
    #[doc = "  \\param w        Pointer to variable for storing the minimum width, may be NULL"]
    #[doc = "  \\param h        Pointer to variable for storing the minimum height, may be NULL"]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowMaximumSize()"]
    #[doc = "  \\sa SDL_SetWindowMinimumSize()"]
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the maximum size of a window's client area."]
    #[doc = ""]
    #[doc = "  \\param window    The window to set a new maximum size."]
    #[doc = "  \\param max_w     The maximum width of the window, must be >0"]
    #[doc = "  \\param max_h     The maximum height of the window, must be >0"]
    #[doc = ""]
    #[doc = "  \\note You can't change the maximum size of a fullscreen window, it"]
    #[doc = "        automatically matches the size of the display mode."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowMaximumSize()"]
    #[doc = "  \\sa SDL_SetWindowMinimumSize()"]
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: ::std::os::raw::c_int,
        max_h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the maximum size of a window's client area."]
    #[doc = ""]
    #[doc = "  \\param window   The window to query."]
    #[doc = "  \\param w        Pointer to variable for storing the maximum width, may be NULL"]
    #[doc = "  \\param h        Pointer to variable for storing the maximum height, may be NULL"]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowMinimumSize()"]
    #[doc = "  \\sa SDL_SetWindowMaximumSize()"]
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the border state of a window."]
    #[doc = ""]
    #[doc = "  This will add or remove the window's SDL_WINDOW_BORDERLESS flag and"]
    #[doc = "  add or remove the border from the actual window. This is a no-op if the"]
    #[doc = "  window's border already matches the requested state."]
    #[doc = ""]
    #[doc = "  \\param window The window of which to change the border state."]
    #[doc = "  \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border."]
    #[doc = ""]
    #[doc = "  \\note You can't change the border state of a fullscreen window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowFlags()"]
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool);
}
extern "C" {
    #[doc = "  \\brief Set the user-resizable state of a window."]
    #[doc = ""]
    #[doc = "  This will add or remove the window's SDL_WINDOW_RESIZABLE flag and"]
    #[doc = "  allow/disallow user resizing of the window. This is a no-op if the"]
    #[doc = "  window's resizable state already matches the requested state."]
    #[doc = ""]
    #[doc = "  \\param window The window of which to change the resizable state."]
    #[doc = "  \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow."]
    #[doc = ""]
    #[doc = "  \\note You can't change the resizable state of a fullscreen window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowFlags()"]
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool);
}
extern "C" {
    #[doc = "  \\brief Show a window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HideWindow()"]
    pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Hide a window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_ShowWindow()"]
    pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Raise a window above other windows and set the input focus."]
    pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Make a window as large as possible."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RestoreWindow()"]
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Minimize a window to an iconic representation."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RestoreWindow()"]
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Restore the size and position of a minimized or maximized window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_MaximizeWindow()"]
    #[doc = "  \\sa SDL_MinimizeWindow()"]
    pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Set a window's fullscreen state."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if setting the display mode failed."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
    #[doc = "  \\sa SDL_GetWindowDisplayMode()"]
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the SDL surface associated with the window."]
    #[doc = ""]
    #[doc = "  \\return The window's framebuffer surface, or NULL on error."]
    #[doc = ""]
    #[doc = "  A new surface will be created with the optimal format for the window,"]
    #[doc = "  if necessary. This surface will be freed when the window is destroyed."]
    #[doc = ""]
    #[doc = "  \\note You may not combine this with 3D or the rendering API on this window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_UpdateWindowSurface()"]
    #[doc = "  \\sa SDL_UpdateWindowSurfaceRects()"]
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = "  \\brief Copy the window surface to the screen."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowSurface()"]
    #[doc = "  \\sa SDL_UpdateWindowSurfaceRects()"]
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a number of rectangles on the window surface to the screen."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowSurface()"]
    #[doc = "  \\sa SDL_UpdateWindowSurface()"]
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set a window's input grab mode."]
    #[doc = ""]
    #[doc = "  \\param window The window for which the input grab mode should be set."]
    #[doc = "  \\param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input."]
    #[doc = ""]
    #[doc = "  If the caller enables a grab while another window is currently grabbed,"]
    #[doc = "  the other window loses its grab in favor of the caller's window."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowGrab()"]
    pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    #[doc = "  \\brief Get a window's input grab mode."]
    #[doc = ""]
    #[doc = "  \\return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowGrab()"]
    pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Get the window that currently has an input grab enabled."]
    #[doc = ""]
    #[doc = "  \\return This returns the window if input is grabbed, and NULL otherwise."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowGrab()"]
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Set the brightness (gamma correction) for a window."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if setting the brightness isn't supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowBrightness()"]
    #[doc = "  \\sa SDL_SetWindowGammaRamp()"]
    pub fn SDL_SetWindowBrightness(
        window: *mut SDL_Window,
        brightness: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the brightness (gamma correction) for a window."]
    #[doc = ""]
    #[doc = "  \\return The last brightness value passed to SDL_SetWindowBrightness()"]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowBrightness()"]
    pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
    #[doc = "  \\brief Set the opacity for a window"]
    #[doc = ""]
    #[doc = "  \\param window The window which will be made transparent or opaque"]
    #[doc = "  \\param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be"]
    #[doc = "                 clamped internally between 0.0f and 1.0f."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if setting the opacity isn't supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowOpacity()"]
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the opacity of a window."]
    #[doc = ""]
    #[doc = "  If transparency isn't supported on this platform, opacity will be reported"]
    #[doc = "  as 1.0f without error."]
    #[doc = ""]
    #[doc = "  \\param window The window in question."]
    #[doc = "  \\param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error (invalid window, etc)."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowOpacity()"]
    pub fn SDL_GetWindowOpacity(
        window: *mut SDL_Window,
        out_opacity: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)"]
    #[doc = ""]
    #[doc = "  \\param modal_window The window that should be modal"]
    #[doc = "  \\param parent_window The parent window"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 otherwise."]
    pub fn SDL_SetWindowModalFor(
        modal_window: *mut SDL_Window,
        parent_window: *mut SDL_Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Explicitly sets input focus to the window."]
    #[doc = ""]
    #[doc = "  You almost certainly want SDL_RaiseWindow() instead of this function. Use"]
    #[doc = "  this with caution, as you might give focus to a window that's completely"]
    #[doc = "  obscured by other windows."]
    #[doc = ""]
    #[doc = "  \\param window The window that should get the input focus"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 otherwise."]
    #[doc = "  \\sa SDL_RaiseWindow()"]
    pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the gamma ramp for a window."]
    #[doc = ""]
    #[doc = "  \\param window The window for which the gamma ramp should be set."]
    #[doc = "  \\param red The translation table for the red channel, or NULL."]
    #[doc = "  \\param green The translation table for the green channel, or NULL."]
    #[doc = "  \\param blue The translation table for the blue channel, or NULL."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if gamma ramps are unsupported."]
    #[doc = ""]
    #[doc = "  Set the gamma translation table for the red, green, and blue channels"]
    #[doc = "  of the video hardware.  Each table is an array of 256 16-bit quantities,"]
    #[doc = "  representing a mapping between the input and output for that channel."]
    #[doc = "  The input is the index into the array, and the output is the 16-bit"]
    #[doc = "  gamma value at that index, scaled to the output color precision."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowGammaRamp()"]
    pub fn SDL_SetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *const Uint16,
        green: *const Uint16,
        blue: *const Uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the gamma ramp for a window."]
    #[doc = ""]
    #[doc = "  \\param window The window from which the gamma ramp should be queried."]
    #[doc = "  \\param red   A pointer to a 256 element array of 16-bit quantities to hold"]
    #[doc = "               the translation table for the red channel, or NULL."]
    #[doc = "  \\param green A pointer to a 256 element array of 16-bit quantities to hold"]
    #[doc = "               the translation table for the green channel, or NULL."]
    #[doc = "  \\param blue  A pointer to a 256 element array of 16-bit quantities to hold"]
    #[doc = "               the translation table for the blue channel, or NULL."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if gamma ramps are unsupported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetWindowGammaRamp()"]
    pub fn SDL_GetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *mut Uint16,
        green: *mut Uint16,
        blue: *mut Uint16,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Region is normal. No special properties."]
pub const SDL_HitTestResult_SDL_HITTEST_NORMAL: SDL_HitTestResult = 0;
#[doc = "< Region can drag entire window."]
pub const SDL_HitTestResult_SDL_HITTEST_DRAGGABLE: SDL_HitTestResult = 1;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPLEFT: SDL_HitTestResult = 2;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOP: SDL_HitTestResult = 3;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPRIGHT: SDL_HitTestResult = 4;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_RIGHT: SDL_HitTestResult = 5;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMRIGHT: SDL_HitTestResult = 6;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOM: SDL_HitTestResult = 7;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMLEFT: SDL_HitTestResult = 8;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_LEFT: SDL_HitTestResult = 9;
#[doc = "  \\brief Possible return values from the SDL_HitTest callback."]
#[doc = ""]
#[doc = "  \\sa SDL_HitTest"]
pub type SDL_HitTestResult = u32;
#[doc = "  \\brief Callback used for hit-testing."]
#[doc = ""]
#[doc = "  \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::std::option::Option<
    unsafe extern "C" fn(
        win: *mut SDL_Window,
        area: *const SDL_Point,
        data: *mut ::std::os::raw::c_void,
    ) -> SDL_HitTestResult,
>;
extern "C" {
    #[doc = "  \\brief Provide a callback that decides if a window region has special properties."]
    #[doc = ""]
    #[doc = "  Normally windows are dragged and resized by decorations provided by the"]
    #[doc = "  system window manager (a title bar, borders, etc), but for some apps, it"]
    #[doc = "  makes sense to drag them from somewhere else inside the window itself; for"]
    #[doc = "  example, one might have a borderless window that wants to be draggable"]
    #[doc = "  from any part, or simulate its own title bar, etc."]
    #[doc = ""]
    #[doc = "  This function lets the app provide a callback that designates pieces of"]
    #[doc = "  a given window as special. This callback is run during event processing"]
    #[doc = "  if we need to tell the OS to treat a region of the window specially; the"]
    #[doc = "  use of this callback is known as \"hit testing.\""]
    #[doc = ""]
    #[doc = "  Mouse input may not be delivered to your application if it is within"]
    #[doc = "  a special area; the OS will often apply that input to moving the window or"]
    #[doc = "  resizing the window and not deliver it to the application."]
    #[doc = ""]
    #[doc = "  Specifying NULL for a callback disables hit-testing. Hit-testing is"]
    #[doc = "  disabled by default."]
    #[doc = ""]
    #[doc = "  Platforms that don't support this functionality will return -1"]
    #[doc = "  unconditionally, even if you're attempting to disable hit-testing."]
    #[doc = ""]
    #[doc = "  Your callback may fire at any time, and its firing does not indicate any"]
    #[doc = "  specific behavior (for example, on Windows, this certainly might fire"]
    #[doc = "  when the OS is deciding whether to drag your window, but it fires for lots"]
    #[doc = "  of other reasons, too, some unrelated to anything you probably care about"]
    #[doc = "  _and when the mouse isn't actually at the location it is testing_)."]
    #[doc = "  Since this can fire at any time, you should try to keep your callback"]
    #[doc = "  efficient, devoid of allocations, etc."]
    #[doc = ""]
    #[doc = "  \\param window The window to set hit-testing on."]
    #[doc = "  \\param callback The callback to call when doing a hit-test."]
    #[doc = "  \\param callback_data An app-defined void pointer passed to the callback."]
    #[doc = "  \\return 0 on success, -1 on error (including unsupported)."]
    pub fn SDL_SetWindowHitTest(
        window: *mut SDL_Window,
        callback: SDL_HitTest,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Destroy a window."]
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Returns whether the screensaver is currently enabled (default off)."]
    #[doc = ""]
    #[doc = "  \\sa SDL_EnableScreenSaver()"]
    #[doc = "  \\sa SDL_DisableScreenSaver()"]
    pub fn SDL_IsScreenSaverEnabled() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Allow the screen to be blanked by a screensaver"]
    #[doc = ""]
    #[doc = "  \\sa SDL_IsScreenSaverEnabled()"]
    #[doc = "  \\sa SDL_DisableScreenSaver()"]
    pub fn SDL_EnableScreenSaver();
}
extern "C" {
    #[doc = "  \\brief Prevent the screen from being blanked by a screensaver"]
    #[doc = ""]
    #[doc = "  \\sa SDL_IsScreenSaverEnabled()"]
    #[doc = "  \\sa SDL_EnableScreenSaver()"]
    pub fn SDL_DisableScreenSaver();
}
extern "C" {
    #[doc = "  \\brief Dynamically load an OpenGL library."]
    #[doc = ""]
    #[doc = "  \\param path The platform dependent OpenGL library name, or NULL to open the"]
    #[doc = "              default OpenGL library."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the library couldn't be loaded."]
    #[doc = ""]
    #[doc = "  This should be done after initializing the video driver, but before"]
    #[doc = "  creating any OpenGL windows.  If no OpenGL library is loaded, the default"]
    #[doc = "  library will be loaded upon creation of the first OpenGL window."]
    #[doc = ""]
    #[doc = "  \\note If you do this, you need to retrieve all of the GL functions used in"]
    #[doc = "        your program from the dynamic library using SDL_GL_GetProcAddress()."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GL_GetProcAddress()"]
    #[doc = "  \\sa SDL_GL_UnloadLibrary()"]
    pub fn SDL_GL_LoadLibrary(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the address of an OpenGL function."]
    pub fn SDL_GL_GetProcAddress(
        proc_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  \\brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary()."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GL_LoadLibrary()"]
    pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
    #[doc = "  \\brief Return true if an OpenGL extension is supported for the current"]
    #[doc = "         context."]
    pub fn SDL_GL_ExtensionSupported(extension: *const ::std::os::raw::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Reset all previously set OpenGL context attributes to their default values"]
    pub fn SDL_GL_ResetAttributes();
}
extern "C" {
    #[doc = "  \\brief Set an OpenGL window attribute before window creation."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the attribute could not be set."]
    pub fn SDL_GL_SetAttribute(
        attr: SDL_GLattr,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the actual value for an attribute from the current context."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the attribute could not be retrieved."]
    #[doc = "          The integer at \\c value will be modified in either case."]
    pub fn SDL_GL_GetAttribute(
        attr: SDL_GLattr,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Create an OpenGL context for use with an OpenGL window, and make it"]
    #[doc = "         current."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GL_DeleteContext()"]
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
    #[doc = "  \\brief Set up an OpenGL context for rendering into an OpenGL window."]
    #[doc = ""]
    #[doc = "  \\note The context must have been created with a compatible window."]
    pub fn SDL_GL_MakeCurrent(
        window: *mut SDL_Window,
        context: SDL_GLContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the currently active OpenGL window."]
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get the currently active OpenGL context."]
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
    #[doc = "  \\brief Get the size of a window's underlying drawable in pixels (for use"]
    #[doc = "         with glViewport)."]
    #[doc = ""]
    #[doc = "  \\param window   Window from which the drawable size should be queried"]
    #[doc = "  \\param w        Pointer to variable for storing the width in pixels, may be NULL"]
    #[doc = "  \\param h        Pointer to variable for storing the height in pixels, may be NULL"]
    #[doc = ""]
    #[doc = " This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI"]
    #[doc = " drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a"]
    #[doc = " platform with high-DPI support (Apple calls this \"Retina\"), and not disabled"]
    #[doc = " by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetWindowSize()"]
    #[doc = "  \\sa SDL_CreateWindow()"]
    pub fn SDL_GL_GetDrawableSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the swap interval for the current OpenGL context."]
    #[doc = ""]
    #[doc = "  \\param interval 0 for immediate updates, 1 for updates synchronized with the"]
    #[doc = "                  vertical retrace. If the system supports it, you may"]
    #[doc = "                  specify -1 to allow late swaps to happen immediately"]
    #[doc = "                  instead of waiting for the next retrace."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if setting the swap interval is not supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GL_GetSwapInterval()"]
    pub fn SDL_GL_SetSwapInterval(interval: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the swap interval for the current OpenGL context."]
    #[doc = ""]
    #[doc = "  \\return 0 if there is no vertical retrace synchronization, 1 if the buffer"]
    #[doc = "          swap is synchronized with the vertical retrace, and -1 if late"]
    #[doc = "          swaps happen immediately instead of waiting for the next retrace."]
    #[doc = "          If the system can't determine the swap interval, or there isn't a"]
    #[doc = "          valid current context, this will return 0 as a safe default."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GL_SetSwapInterval()"]
    pub fn SDL_GL_GetSwapInterval() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Swap the OpenGL buffers for a window, if double-buffering is"]
    #[doc = "        supported."]
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Delete an OpenGL context."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GL_CreateContext()"]
    pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
pub const SDL_Scancode_SDL_SCANCODE_UNKNOWN: SDL_Scancode = 0;
pub const SDL_Scancode_SDL_SCANCODE_A: SDL_Scancode = 4;
pub const SDL_Scancode_SDL_SCANCODE_B: SDL_Scancode = 5;
pub const SDL_Scancode_SDL_SCANCODE_C: SDL_Scancode = 6;
pub const SDL_Scancode_SDL_SCANCODE_D: SDL_Scancode = 7;
pub const SDL_Scancode_SDL_SCANCODE_E: SDL_Scancode = 8;
pub const SDL_Scancode_SDL_SCANCODE_F: SDL_Scancode = 9;
pub const SDL_Scancode_SDL_SCANCODE_G: SDL_Scancode = 10;
pub const SDL_Scancode_SDL_SCANCODE_H: SDL_Scancode = 11;
pub const SDL_Scancode_SDL_SCANCODE_I: SDL_Scancode = 12;
pub const SDL_Scancode_SDL_SCANCODE_J: SDL_Scancode = 13;
pub const SDL_Scancode_SDL_SCANCODE_K: SDL_Scancode = 14;
pub const SDL_Scancode_SDL_SCANCODE_L: SDL_Scancode = 15;
pub const SDL_Scancode_SDL_SCANCODE_M: SDL_Scancode = 16;
pub const SDL_Scancode_SDL_SCANCODE_N: SDL_Scancode = 17;
pub const SDL_Scancode_SDL_SCANCODE_O: SDL_Scancode = 18;
pub const SDL_Scancode_SDL_SCANCODE_P: SDL_Scancode = 19;
pub const SDL_Scancode_SDL_SCANCODE_Q: SDL_Scancode = 20;
pub const SDL_Scancode_SDL_SCANCODE_R: SDL_Scancode = 21;
pub const SDL_Scancode_SDL_SCANCODE_S: SDL_Scancode = 22;
pub const SDL_Scancode_SDL_SCANCODE_T: SDL_Scancode = 23;
pub const SDL_Scancode_SDL_SCANCODE_U: SDL_Scancode = 24;
pub const SDL_Scancode_SDL_SCANCODE_V: SDL_Scancode = 25;
pub const SDL_Scancode_SDL_SCANCODE_W: SDL_Scancode = 26;
pub const SDL_Scancode_SDL_SCANCODE_X: SDL_Scancode = 27;
pub const SDL_Scancode_SDL_SCANCODE_Y: SDL_Scancode = 28;
pub const SDL_Scancode_SDL_SCANCODE_Z: SDL_Scancode = 29;
pub const SDL_Scancode_SDL_SCANCODE_1: SDL_Scancode = 30;
pub const SDL_Scancode_SDL_SCANCODE_2: SDL_Scancode = 31;
pub const SDL_Scancode_SDL_SCANCODE_3: SDL_Scancode = 32;
pub const SDL_Scancode_SDL_SCANCODE_4: SDL_Scancode = 33;
pub const SDL_Scancode_SDL_SCANCODE_5: SDL_Scancode = 34;
pub const SDL_Scancode_SDL_SCANCODE_6: SDL_Scancode = 35;
pub const SDL_Scancode_SDL_SCANCODE_7: SDL_Scancode = 36;
pub const SDL_Scancode_SDL_SCANCODE_8: SDL_Scancode = 37;
pub const SDL_Scancode_SDL_SCANCODE_9: SDL_Scancode = 38;
pub const SDL_Scancode_SDL_SCANCODE_0: SDL_Scancode = 39;
pub const SDL_Scancode_SDL_SCANCODE_RETURN: SDL_Scancode = 40;
pub const SDL_Scancode_SDL_SCANCODE_ESCAPE: SDL_Scancode = 41;
pub const SDL_Scancode_SDL_SCANCODE_BACKSPACE: SDL_Scancode = 42;
pub const SDL_Scancode_SDL_SCANCODE_TAB: SDL_Scancode = 43;
pub const SDL_Scancode_SDL_SCANCODE_SPACE: SDL_Scancode = 44;
pub const SDL_Scancode_SDL_SCANCODE_MINUS: SDL_Scancode = 45;
pub const SDL_Scancode_SDL_SCANCODE_EQUALS: SDL_Scancode = 46;
pub const SDL_Scancode_SDL_SCANCODE_LEFTBRACKET: SDL_Scancode = 47;
pub const SDL_Scancode_SDL_SCANCODE_RIGHTBRACKET: SDL_Scancode = 48;
#[doc = "< Located at the lower left of the return"]
#[doc = "   key on ISO keyboards and at the right end"]
#[doc = "   of the QWERTY row on ANSI keyboards."]
#[doc = "   Produces REVERSE SOLIDUS (backslash) and"]
#[doc = "   VERTICAL LINE in a US layout, REVERSE"]
#[doc = "   SOLIDUS and VERTICAL LINE in a UK Mac"]
#[doc = "   layout, NUMBER SIGN and TILDE in a UK"]
#[doc = "   Windows layout, DOLLAR SIGN and POUND SIGN"]
#[doc = "   in a Swiss German layout, NUMBER SIGN and"]
#[doc = "   APOSTROPHE in a German layout, GRAVE"]
#[doc = "   ACCENT and POUND SIGN in a French Mac"]
#[doc = "   layout, and ASTERISK and MICRO SIGN in a"]
#[doc = "   French Windows layout."]
pub const SDL_Scancode_SDL_SCANCODE_BACKSLASH: SDL_Scancode = 49;
#[doc = "< ISO USB keyboards actually use this code"]
#[doc = "   instead of 49 for the same key, but all"]
#[doc = "   OSes I've seen treat the two codes"]
#[doc = "   identically. So, as an implementor, unless"]
#[doc = "   your keyboard generates both of those"]
#[doc = "   codes and your OS treats them differently,"]
#[doc = "   you should generate SDL_SCANCODE_BACKSLASH"]
#[doc = "   instead of this code. As a user, you"]
#[doc = "   should not rely on this code because SDL"]
#[doc = "   will never generate it with most (all?)"]
#[doc = "   keyboards."]
pub const SDL_Scancode_SDL_SCANCODE_NONUSHASH: SDL_Scancode = 50;
pub const SDL_Scancode_SDL_SCANCODE_SEMICOLON: SDL_Scancode = 51;
pub const SDL_Scancode_SDL_SCANCODE_APOSTROPHE: SDL_Scancode = 52;
#[doc = "< Located in the top left corner (on both ANSI"]
#[doc = "   and ISO keyboards). Produces GRAVE ACCENT and"]
#[doc = "   TILDE in a US Windows layout and in US and UK"]
#[doc = "   Mac layouts on ANSI keyboards, GRAVE ACCENT"]
#[doc = "   and NOT SIGN in a UK Windows layout, SECTION"]
#[doc = "   SIGN and PLUS-MINUS SIGN in US and UK Mac"]
#[doc = "   layouts on ISO keyboards, SECTION SIGN and"]
#[doc = "   DEGREE SIGN in a Swiss German layout (Mac:"]
#[doc = "   only on ISO keyboards), CIRCUMFLEX ACCENT and"]
#[doc = "   DEGREE SIGN in a German layout (Mac: only on"]
#[doc = "   ISO keyboards), SUPERSCRIPT TWO and TILDE in a"]
#[doc = "   French Windows layout, COMMERCIAL AT and"]
#[doc = "   NUMBER SIGN in a French Mac layout on ISO"]
#[doc = "   keyboards, and LESS-THAN SIGN and GREATER-THAN"]
#[doc = "   SIGN in a Swiss German, German, or French Mac"]
#[doc = "   layout on ANSI keyboards."]
pub const SDL_Scancode_SDL_SCANCODE_GRAVE: SDL_Scancode = 53;
pub const SDL_Scancode_SDL_SCANCODE_COMMA: SDL_Scancode = 54;
pub const SDL_Scancode_SDL_SCANCODE_PERIOD: SDL_Scancode = 55;
pub const SDL_Scancode_SDL_SCANCODE_SLASH: SDL_Scancode = 56;
pub const SDL_Scancode_SDL_SCANCODE_CAPSLOCK: SDL_Scancode = 57;
pub const SDL_Scancode_SDL_SCANCODE_F1: SDL_Scancode = 58;
pub const SDL_Scancode_SDL_SCANCODE_F2: SDL_Scancode = 59;
pub const SDL_Scancode_SDL_SCANCODE_F3: SDL_Scancode = 60;
pub const SDL_Scancode_SDL_SCANCODE_F4: SDL_Scancode = 61;
pub const SDL_Scancode_SDL_SCANCODE_F5: SDL_Scancode = 62;
pub const SDL_Scancode_SDL_SCANCODE_F6: SDL_Scancode = 63;
pub const SDL_Scancode_SDL_SCANCODE_F7: SDL_Scancode = 64;
pub const SDL_Scancode_SDL_SCANCODE_F8: SDL_Scancode = 65;
pub const SDL_Scancode_SDL_SCANCODE_F9: SDL_Scancode = 66;
pub const SDL_Scancode_SDL_SCANCODE_F10: SDL_Scancode = 67;
pub const SDL_Scancode_SDL_SCANCODE_F11: SDL_Scancode = 68;
pub const SDL_Scancode_SDL_SCANCODE_F12: SDL_Scancode = 69;
pub const SDL_Scancode_SDL_SCANCODE_PRINTSCREEN: SDL_Scancode = 70;
pub const SDL_Scancode_SDL_SCANCODE_SCROLLLOCK: SDL_Scancode = 71;
pub const SDL_Scancode_SDL_SCANCODE_PAUSE: SDL_Scancode = 72;
#[doc = "< insert on PC, help on some Mac keyboards (but"]
#[doc = "does send code 73, not 117)"]
pub const SDL_Scancode_SDL_SCANCODE_INSERT: SDL_Scancode = 73;
pub const SDL_Scancode_SDL_SCANCODE_HOME: SDL_Scancode = 74;
pub const SDL_Scancode_SDL_SCANCODE_PAGEUP: SDL_Scancode = 75;
pub const SDL_Scancode_SDL_SCANCODE_DELETE: SDL_Scancode = 76;
pub const SDL_Scancode_SDL_SCANCODE_END: SDL_Scancode = 77;
pub const SDL_Scancode_SDL_SCANCODE_PAGEDOWN: SDL_Scancode = 78;
pub const SDL_Scancode_SDL_SCANCODE_RIGHT: SDL_Scancode = 79;
pub const SDL_Scancode_SDL_SCANCODE_LEFT: SDL_Scancode = 80;
pub const SDL_Scancode_SDL_SCANCODE_DOWN: SDL_Scancode = 81;
pub const SDL_Scancode_SDL_SCANCODE_UP: SDL_Scancode = 82;
#[doc = "< num lock on PC, clear on Mac keyboards"]
pub const SDL_Scancode_SDL_SCANCODE_NUMLOCKCLEAR: SDL_Scancode = 83;
pub const SDL_Scancode_SDL_SCANCODE_KP_DIVIDE: SDL_Scancode = 84;
pub const SDL_Scancode_SDL_SCANCODE_KP_MULTIPLY: SDL_Scancode = 85;
pub const SDL_Scancode_SDL_SCANCODE_KP_MINUS: SDL_Scancode = 86;
pub const SDL_Scancode_SDL_SCANCODE_KP_PLUS: SDL_Scancode = 87;
pub const SDL_Scancode_SDL_SCANCODE_KP_ENTER: SDL_Scancode = 88;
pub const SDL_Scancode_SDL_SCANCODE_KP_1: SDL_Scancode = 89;
pub const SDL_Scancode_SDL_SCANCODE_KP_2: SDL_Scancode = 90;
pub const SDL_Scancode_SDL_SCANCODE_KP_3: SDL_Scancode = 91;
pub const SDL_Scancode_SDL_SCANCODE_KP_4: SDL_Scancode = 92;
pub const SDL_Scancode_SDL_SCANCODE_KP_5: SDL_Scancode = 93;
pub const SDL_Scancode_SDL_SCANCODE_KP_6: SDL_Scancode = 94;
pub const SDL_Scancode_SDL_SCANCODE_KP_7: SDL_Scancode = 95;
pub const SDL_Scancode_SDL_SCANCODE_KP_8: SDL_Scancode = 96;
pub const SDL_Scancode_SDL_SCANCODE_KP_9: SDL_Scancode = 97;
pub const SDL_Scancode_SDL_SCANCODE_KP_0: SDL_Scancode = 98;
pub const SDL_Scancode_SDL_SCANCODE_KP_PERIOD: SDL_Scancode = 99;
#[doc = "< This is the additional key that ISO"]
#[doc = "   keyboards have over ANSI ones,"]
#[doc = "   located between left shift and Y."]
#[doc = "   Produces GRAVE ACCENT and TILDE in a"]
#[doc = "   US or UK Mac layout, REVERSE SOLIDUS"]
#[doc = "   (backslash) and VERTICAL LINE in a"]
#[doc = "   US or UK Windows layout, and"]
#[doc = "   LESS-THAN SIGN and GREATER-THAN SIGN"]
#[doc = "   in a Swiss German, German, or French"]
#[doc = "   layout."]
pub const SDL_Scancode_SDL_SCANCODE_NONUSBACKSLASH: SDL_Scancode = 100;
#[doc = "< windows contextual menu, compose"]
pub const SDL_Scancode_SDL_SCANCODE_APPLICATION: SDL_Scancode = 101;
#[doc = "< The USB document says this is a status flag,"]
#[doc = "   not a physical key - but some Mac keyboards"]
#[doc = "   do have a power key."]
pub const SDL_Scancode_SDL_SCANCODE_POWER: SDL_Scancode = 102;
pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALS: SDL_Scancode = 103;
pub const SDL_Scancode_SDL_SCANCODE_F13: SDL_Scancode = 104;
pub const SDL_Scancode_SDL_SCANCODE_F14: SDL_Scancode = 105;
pub const SDL_Scancode_SDL_SCANCODE_F15: SDL_Scancode = 106;
pub const SDL_Scancode_SDL_SCANCODE_F16: SDL_Scancode = 107;
pub const SDL_Scancode_SDL_SCANCODE_F17: SDL_Scancode = 108;
pub const SDL_Scancode_SDL_SCANCODE_F18: SDL_Scancode = 109;
pub const SDL_Scancode_SDL_SCANCODE_F19: SDL_Scancode = 110;
pub const SDL_Scancode_SDL_SCANCODE_F20: SDL_Scancode = 111;
pub const SDL_Scancode_SDL_SCANCODE_F21: SDL_Scancode = 112;
pub const SDL_Scancode_SDL_SCANCODE_F22: SDL_Scancode = 113;
pub const SDL_Scancode_SDL_SCANCODE_F23: SDL_Scancode = 114;
pub const SDL_Scancode_SDL_SCANCODE_F24: SDL_Scancode = 115;
pub const SDL_Scancode_SDL_SCANCODE_EXECUTE: SDL_Scancode = 116;
pub const SDL_Scancode_SDL_SCANCODE_HELP: SDL_Scancode = 117;
pub const SDL_Scancode_SDL_SCANCODE_MENU: SDL_Scancode = 118;
pub const SDL_Scancode_SDL_SCANCODE_SELECT: SDL_Scancode = 119;
pub const SDL_Scancode_SDL_SCANCODE_STOP: SDL_Scancode = 120;
#[doc = "< redo"]
pub const SDL_Scancode_SDL_SCANCODE_AGAIN: SDL_Scancode = 121;
pub const SDL_Scancode_SDL_SCANCODE_UNDO: SDL_Scancode = 122;
pub const SDL_Scancode_SDL_SCANCODE_CUT: SDL_Scancode = 123;
pub const SDL_Scancode_SDL_SCANCODE_COPY: SDL_Scancode = 124;
pub const SDL_Scancode_SDL_SCANCODE_PASTE: SDL_Scancode = 125;
pub const SDL_Scancode_SDL_SCANCODE_FIND: SDL_Scancode = 126;
pub const SDL_Scancode_SDL_SCANCODE_MUTE: SDL_Scancode = 127;
pub const SDL_Scancode_SDL_SCANCODE_VOLUMEUP: SDL_Scancode = 128;
pub const SDL_Scancode_SDL_SCANCODE_VOLUMEDOWN: SDL_Scancode = 129;
pub const SDL_Scancode_SDL_SCANCODE_KP_COMMA: SDL_Scancode = 133;
pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALSAS400: SDL_Scancode = 134;
#[doc = "< used on Asian keyboards, see"]
#[doc = "footnotes in USB doc"]
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL1: SDL_Scancode = 135;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL2: SDL_Scancode = 136;
#[doc = "< Yen"]
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL3: SDL_Scancode = 137;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL4: SDL_Scancode = 138;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL5: SDL_Scancode = 139;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL6: SDL_Scancode = 140;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL7: SDL_Scancode = 141;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL8: SDL_Scancode = 142;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL9: SDL_Scancode = 143;
#[doc = "< Hangul/English toggle"]
pub const SDL_Scancode_SDL_SCANCODE_LANG1: SDL_Scancode = 144;
#[doc = "< Hanja conversion"]
pub const SDL_Scancode_SDL_SCANCODE_LANG2: SDL_Scancode = 145;
#[doc = "< Katakana"]
pub const SDL_Scancode_SDL_SCANCODE_LANG3: SDL_Scancode = 146;
#[doc = "< Hiragana"]
pub const SDL_Scancode_SDL_SCANCODE_LANG4: SDL_Scancode = 147;
#[doc = "< Zenkaku/Hankaku"]
pub const SDL_Scancode_SDL_SCANCODE_LANG5: SDL_Scancode = 148;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG6: SDL_Scancode = 149;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG7: SDL_Scancode = 150;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG8: SDL_Scancode = 151;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG9: SDL_Scancode = 152;
#[doc = "< Erase-Eaze"]
pub const SDL_Scancode_SDL_SCANCODE_ALTERASE: SDL_Scancode = 153;
pub const SDL_Scancode_SDL_SCANCODE_SYSREQ: SDL_Scancode = 154;
pub const SDL_Scancode_SDL_SCANCODE_CANCEL: SDL_Scancode = 155;
pub const SDL_Scancode_SDL_SCANCODE_CLEAR: SDL_Scancode = 156;
pub const SDL_Scancode_SDL_SCANCODE_PRIOR: SDL_Scancode = 157;
pub const SDL_Scancode_SDL_SCANCODE_RETURN2: SDL_Scancode = 158;
pub const SDL_Scancode_SDL_SCANCODE_SEPARATOR: SDL_Scancode = 159;
pub const SDL_Scancode_SDL_SCANCODE_OUT: SDL_Scancode = 160;
pub const SDL_Scancode_SDL_SCANCODE_OPER: SDL_Scancode = 161;
pub const SDL_Scancode_SDL_SCANCODE_CLEARAGAIN: SDL_Scancode = 162;
pub const SDL_Scancode_SDL_SCANCODE_CRSEL: SDL_Scancode = 163;
pub const SDL_Scancode_SDL_SCANCODE_EXSEL: SDL_Scancode = 164;
pub const SDL_Scancode_SDL_SCANCODE_KP_00: SDL_Scancode = 176;
pub const SDL_Scancode_SDL_SCANCODE_KP_000: SDL_Scancode = 177;
pub const SDL_Scancode_SDL_SCANCODE_THOUSANDSSEPARATOR: SDL_Scancode = 178;
pub const SDL_Scancode_SDL_SCANCODE_DECIMALSEPARATOR: SDL_Scancode = 179;
pub const SDL_Scancode_SDL_SCANCODE_CURRENCYUNIT: SDL_Scancode = 180;
pub const SDL_Scancode_SDL_SCANCODE_CURRENCYSUBUNIT: SDL_Scancode = 181;
pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTPAREN: SDL_Scancode = 182;
pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTPAREN: SDL_Scancode = 183;
pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTBRACE: SDL_Scancode = 184;
pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTBRACE: SDL_Scancode = 185;
pub const SDL_Scancode_SDL_SCANCODE_KP_TAB: SDL_Scancode = 186;
pub const SDL_Scancode_SDL_SCANCODE_KP_BACKSPACE: SDL_Scancode = 187;
pub const SDL_Scancode_SDL_SCANCODE_KP_A: SDL_Scancode = 188;
pub const SDL_Scancode_SDL_SCANCODE_KP_B: SDL_Scancode = 189;
pub const SDL_Scancode_SDL_SCANCODE_KP_C: SDL_Scancode = 190;
pub const SDL_Scancode_SDL_SCANCODE_KP_D: SDL_Scancode = 191;
pub const SDL_Scancode_SDL_SCANCODE_KP_E: SDL_Scancode = 192;
pub const SDL_Scancode_SDL_SCANCODE_KP_F: SDL_Scancode = 193;
pub const SDL_Scancode_SDL_SCANCODE_KP_XOR: SDL_Scancode = 194;
pub const SDL_Scancode_SDL_SCANCODE_KP_POWER: SDL_Scancode = 195;
pub const SDL_Scancode_SDL_SCANCODE_KP_PERCENT: SDL_Scancode = 196;
pub const SDL_Scancode_SDL_SCANCODE_KP_LESS: SDL_Scancode = 197;
pub const SDL_Scancode_SDL_SCANCODE_KP_GREATER: SDL_Scancode = 198;
pub const SDL_Scancode_SDL_SCANCODE_KP_AMPERSAND: SDL_Scancode = 199;
pub const SDL_Scancode_SDL_SCANCODE_KP_DBLAMPERSAND: SDL_Scancode = 200;
pub const SDL_Scancode_SDL_SCANCODE_KP_VERTICALBAR: SDL_Scancode = 201;
pub const SDL_Scancode_SDL_SCANCODE_KP_DBLVERTICALBAR: SDL_Scancode = 202;
pub const SDL_Scancode_SDL_SCANCODE_KP_COLON: SDL_Scancode = 203;
pub const SDL_Scancode_SDL_SCANCODE_KP_HASH: SDL_Scancode = 204;
pub const SDL_Scancode_SDL_SCANCODE_KP_SPACE: SDL_Scancode = 205;
pub const SDL_Scancode_SDL_SCANCODE_KP_AT: SDL_Scancode = 206;
pub const SDL_Scancode_SDL_SCANCODE_KP_EXCLAM: SDL_Scancode = 207;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSTORE: SDL_Scancode = 208;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMRECALL: SDL_Scancode = 209;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMCLEAR: SDL_Scancode = 210;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMADD: SDL_Scancode = 211;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSUBTRACT: SDL_Scancode = 212;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMMULTIPLY: SDL_Scancode = 213;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMDIVIDE: SDL_Scancode = 214;
pub const SDL_Scancode_SDL_SCANCODE_KP_PLUSMINUS: SDL_Scancode = 215;
pub const SDL_Scancode_SDL_SCANCODE_KP_CLEAR: SDL_Scancode = 216;
pub const SDL_Scancode_SDL_SCANCODE_KP_CLEARENTRY: SDL_Scancode = 217;
pub const SDL_Scancode_SDL_SCANCODE_KP_BINARY: SDL_Scancode = 218;
pub const SDL_Scancode_SDL_SCANCODE_KP_OCTAL: SDL_Scancode = 219;
pub const SDL_Scancode_SDL_SCANCODE_KP_DECIMAL: SDL_Scancode = 220;
pub const SDL_Scancode_SDL_SCANCODE_KP_HEXADECIMAL: SDL_Scancode = 221;
pub const SDL_Scancode_SDL_SCANCODE_LCTRL: SDL_Scancode = 224;
pub const SDL_Scancode_SDL_SCANCODE_LSHIFT: SDL_Scancode = 225;
#[doc = "< alt, option"]
pub const SDL_Scancode_SDL_SCANCODE_LALT: SDL_Scancode = 226;
#[doc = "< windows, command (apple), meta"]
pub const SDL_Scancode_SDL_SCANCODE_LGUI: SDL_Scancode = 227;
pub const SDL_Scancode_SDL_SCANCODE_RCTRL: SDL_Scancode = 228;
pub const SDL_Scancode_SDL_SCANCODE_RSHIFT: SDL_Scancode = 229;
#[doc = "< alt gr, option"]
pub const SDL_Scancode_SDL_SCANCODE_RALT: SDL_Scancode = 230;
#[doc = "< windows, command (apple), meta"]
pub const SDL_Scancode_SDL_SCANCODE_RGUI: SDL_Scancode = 231;
#[doc = "< I'm not sure if this is really not covered"]
#[doc = "   by any of the above, but since there's a"]
#[doc = "   special KMOD_MODE for it I'm adding it here"]
pub const SDL_Scancode_SDL_SCANCODE_MODE: SDL_Scancode = 257;
pub const SDL_Scancode_SDL_SCANCODE_AUDIONEXT: SDL_Scancode = 258;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOPREV: SDL_Scancode = 259;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOSTOP: SDL_Scancode = 260;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOPLAY: SDL_Scancode = 261;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOMUTE: SDL_Scancode = 262;
pub const SDL_Scancode_SDL_SCANCODE_MEDIASELECT: SDL_Scancode = 263;
pub const SDL_Scancode_SDL_SCANCODE_WWW: SDL_Scancode = 264;
pub const SDL_Scancode_SDL_SCANCODE_MAIL: SDL_Scancode = 265;
pub const SDL_Scancode_SDL_SCANCODE_CALCULATOR: SDL_Scancode = 266;
pub const SDL_Scancode_SDL_SCANCODE_COMPUTER: SDL_Scancode = 267;
pub const SDL_Scancode_SDL_SCANCODE_AC_SEARCH: SDL_Scancode = 268;
pub const SDL_Scancode_SDL_SCANCODE_AC_HOME: SDL_Scancode = 269;
pub const SDL_Scancode_SDL_SCANCODE_AC_BACK: SDL_Scancode = 270;
pub const SDL_Scancode_SDL_SCANCODE_AC_FORWARD: SDL_Scancode = 271;
pub const SDL_Scancode_SDL_SCANCODE_AC_STOP: SDL_Scancode = 272;
pub const SDL_Scancode_SDL_SCANCODE_AC_REFRESH: SDL_Scancode = 273;
pub const SDL_Scancode_SDL_SCANCODE_AC_BOOKMARKS: SDL_Scancode = 274;
pub const SDL_Scancode_SDL_SCANCODE_BRIGHTNESSDOWN: SDL_Scancode = 275;
pub const SDL_Scancode_SDL_SCANCODE_BRIGHTNESSUP: SDL_Scancode = 276;
#[doc = "< display mirroring/dual display"]
#[doc = "switch, video mode switch"]
pub const SDL_Scancode_SDL_SCANCODE_DISPLAYSWITCH: SDL_Scancode = 277;
pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMTOGGLE: SDL_Scancode = 278;
pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMDOWN: SDL_Scancode = 279;
pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMUP: SDL_Scancode = 280;
pub const SDL_Scancode_SDL_SCANCODE_EJECT: SDL_Scancode = 281;
pub const SDL_Scancode_SDL_SCANCODE_SLEEP: SDL_Scancode = 282;
pub const SDL_Scancode_SDL_SCANCODE_APP1: SDL_Scancode = 283;
pub const SDL_Scancode_SDL_SCANCODE_APP2: SDL_Scancode = 284;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOREWIND: SDL_Scancode = 285;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOFASTFORWARD: SDL_Scancode = 286;
#[doc = "< not a key, just marks the number of scancodes"]
#[doc = "for array bounds"]
pub const SDL_Scancode_SDL_NUM_SCANCODES: SDL_Scancode = 512;
#[doc = "  \\brief The SDL keyboard scancode representation."]
#[doc = ""]
#[doc = "  Values of this type are used to represent keyboard keys, among other places"]
#[doc = "  in the \\link SDL_Keysym::scancode key.keysym.scancode \\endlink field of the"]
#[doc = "  SDL_Event structure."]
#[doc = ""]
#[doc = "  The values in this enumeration are based on the USB usage page standard:"]
#[doc = "  https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf"]
pub type SDL_Scancode = u32;
#[doc = "  \\brief The SDL virtual key representation."]
#[doc = ""]
#[doc = "  Values of this type are used to represent keyboard keys using the current"]
#[doc = "  layout of the keyboard.  These values include Unicode values representing"]
#[doc = "  the unmodified character that would be generated by pressing the key, or"]
#[doc = "  an SDLK_* constant for those keys that do not generate characters."]
#[doc = ""]
#[doc = "  A special exception is the number keys at the top of the keyboard which"]
#[doc = "  always map to SDLK_0...SDLK_9, regardless of layout."]
pub type SDL_Keycode = Sint32;
pub const SDL_KeyCode_SDLK_UNKNOWN: SDL_KeyCode = 0;
pub const SDL_KeyCode_SDLK_RETURN: SDL_KeyCode = 13;
pub const SDL_KeyCode_SDLK_ESCAPE: SDL_KeyCode = 27;
pub const SDL_KeyCode_SDLK_BACKSPACE: SDL_KeyCode = 8;
pub const SDL_KeyCode_SDLK_TAB: SDL_KeyCode = 9;
pub const SDL_KeyCode_SDLK_SPACE: SDL_KeyCode = 32;
pub const SDL_KeyCode_SDLK_EXCLAIM: SDL_KeyCode = 33;
pub const SDL_KeyCode_SDLK_QUOTEDBL: SDL_KeyCode = 34;
pub const SDL_KeyCode_SDLK_HASH: SDL_KeyCode = 35;
pub const SDL_KeyCode_SDLK_PERCENT: SDL_KeyCode = 37;
pub const SDL_KeyCode_SDLK_DOLLAR: SDL_KeyCode = 36;
pub const SDL_KeyCode_SDLK_AMPERSAND: SDL_KeyCode = 38;
pub const SDL_KeyCode_SDLK_QUOTE: SDL_KeyCode = 39;
pub const SDL_KeyCode_SDLK_LEFTPAREN: SDL_KeyCode = 40;
pub const SDL_KeyCode_SDLK_RIGHTPAREN: SDL_KeyCode = 41;
pub const SDL_KeyCode_SDLK_ASTERISK: SDL_KeyCode = 42;
pub const SDL_KeyCode_SDLK_PLUS: SDL_KeyCode = 43;
pub const SDL_KeyCode_SDLK_COMMA: SDL_KeyCode = 44;
pub const SDL_KeyCode_SDLK_MINUS: SDL_KeyCode = 45;
pub const SDL_KeyCode_SDLK_PERIOD: SDL_KeyCode = 46;
pub const SDL_KeyCode_SDLK_SLASH: SDL_KeyCode = 47;
pub const SDL_KeyCode_SDLK_0: SDL_KeyCode = 48;
pub const SDL_KeyCode_SDLK_1: SDL_KeyCode = 49;
pub const SDL_KeyCode_SDLK_2: SDL_KeyCode = 50;
pub const SDL_KeyCode_SDLK_3: SDL_KeyCode = 51;
pub const SDL_KeyCode_SDLK_4: SDL_KeyCode = 52;
pub const SDL_KeyCode_SDLK_5: SDL_KeyCode = 53;
pub const SDL_KeyCode_SDLK_6: SDL_KeyCode = 54;
pub const SDL_KeyCode_SDLK_7: SDL_KeyCode = 55;
pub const SDL_KeyCode_SDLK_8: SDL_KeyCode = 56;
pub const SDL_KeyCode_SDLK_9: SDL_KeyCode = 57;
pub const SDL_KeyCode_SDLK_COLON: SDL_KeyCode = 58;
pub const SDL_KeyCode_SDLK_SEMICOLON: SDL_KeyCode = 59;
pub const SDL_KeyCode_SDLK_LESS: SDL_KeyCode = 60;
pub const SDL_KeyCode_SDLK_EQUALS: SDL_KeyCode = 61;
pub const SDL_KeyCode_SDLK_GREATER: SDL_KeyCode = 62;
pub const SDL_KeyCode_SDLK_QUESTION: SDL_KeyCode = 63;
pub const SDL_KeyCode_SDLK_AT: SDL_KeyCode = 64;
pub const SDL_KeyCode_SDLK_LEFTBRACKET: SDL_KeyCode = 91;
pub const SDL_KeyCode_SDLK_BACKSLASH: SDL_KeyCode = 92;
pub const SDL_KeyCode_SDLK_RIGHTBRACKET: SDL_KeyCode = 93;
pub const SDL_KeyCode_SDLK_CARET: SDL_KeyCode = 94;
pub const SDL_KeyCode_SDLK_UNDERSCORE: SDL_KeyCode = 95;
pub const SDL_KeyCode_SDLK_BACKQUOTE: SDL_KeyCode = 96;
pub const SDL_KeyCode_SDLK_a: SDL_KeyCode = 97;
pub const SDL_KeyCode_SDLK_b: SDL_KeyCode = 98;
pub const SDL_KeyCode_SDLK_c: SDL_KeyCode = 99;
pub const SDL_KeyCode_SDLK_d: SDL_KeyCode = 100;
pub const SDL_KeyCode_SDLK_e: SDL_KeyCode = 101;
pub const SDL_KeyCode_SDLK_f: SDL_KeyCode = 102;
pub const SDL_KeyCode_SDLK_g: SDL_KeyCode = 103;
pub const SDL_KeyCode_SDLK_h: SDL_KeyCode = 104;
pub const SDL_KeyCode_SDLK_i: SDL_KeyCode = 105;
pub const SDL_KeyCode_SDLK_j: SDL_KeyCode = 106;
pub const SDL_KeyCode_SDLK_k: SDL_KeyCode = 107;
pub const SDL_KeyCode_SDLK_l: SDL_KeyCode = 108;
pub const SDL_KeyCode_SDLK_m: SDL_KeyCode = 109;
pub const SDL_KeyCode_SDLK_n: SDL_KeyCode = 110;
pub const SDL_KeyCode_SDLK_o: SDL_KeyCode = 111;
pub const SDL_KeyCode_SDLK_p: SDL_KeyCode = 112;
pub const SDL_KeyCode_SDLK_q: SDL_KeyCode = 113;
pub const SDL_KeyCode_SDLK_r: SDL_KeyCode = 114;
pub const SDL_KeyCode_SDLK_s: SDL_KeyCode = 115;
pub const SDL_KeyCode_SDLK_t: SDL_KeyCode = 116;
pub const SDL_KeyCode_SDLK_u: SDL_KeyCode = 117;
pub const SDL_KeyCode_SDLK_v: SDL_KeyCode = 118;
pub const SDL_KeyCode_SDLK_w: SDL_KeyCode = 119;
pub const SDL_KeyCode_SDLK_x: SDL_KeyCode = 120;
pub const SDL_KeyCode_SDLK_y: SDL_KeyCode = 121;
pub const SDL_KeyCode_SDLK_z: SDL_KeyCode = 122;
pub const SDL_KeyCode_SDLK_CAPSLOCK: SDL_KeyCode = 1073741881;
pub const SDL_KeyCode_SDLK_F1: SDL_KeyCode = 1073741882;
pub const SDL_KeyCode_SDLK_F2: SDL_KeyCode = 1073741883;
pub const SDL_KeyCode_SDLK_F3: SDL_KeyCode = 1073741884;
pub const SDL_KeyCode_SDLK_F4: SDL_KeyCode = 1073741885;
pub const SDL_KeyCode_SDLK_F5: SDL_KeyCode = 1073741886;
pub const SDL_KeyCode_SDLK_F6: SDL_KeyCode = 1073741887;
pub const SDL_KeyCode_SDLK_F7: SDL_KeyCode = 1073741888;
pub const SDL_KeyCode_SDLK_F8: SDL_KeyCode = 1073741889;
pub const SDL_KeyCode_SDLK_F9: SDL_KeyCode = 1073741890;
pub const SDL_KeyCode_SDLK_F10: SDL_KeyCode = 1073741891;
pub const SDL_KeyCode_SDLK_F11: SDL_KeyCode = 1073741892;
pub const SDL_KeyCode_SDLK_F12: SDL_KeyCode = 1073741893;
pub const SDL_KeyCode_SDLK_PRINTSCREEN: SDL_KeyCode = 1073741894;
pub const SDL_KeyCode_SDLK_SCROLLLOCK: SDL_KeyCode = 1073741895;
pub const SDL_KeyCode_SDLK_PAUSE: SDL_KeyCode = 1073741896;
pub const SDL_KeyCode_SDLK_INSERT: SDL_KeyCode = 1073741897;
pub const SDL_KeyCode_SDLK_HOME: SDL_KeyCode = 1073741898;
pub const SDL_KeyCode_SDLK_PAGEUP: SDL_KeyCode = 1073741899;
pub const SDL_KeyCode_SDLK_DELETE: SDL_KeyCode = 127;
pub const SDL_KeyCode_SDLK_END: SDL_KeyCode = 1073741901;
pub const SDL_KeyCode_SDLK_PAGEDOWN: SDL_KeyCode = 1073741902;
pub const SDL_KeyCode_SDLK_RIGHT: SDL_KeyCode = 1073741903;
pub const SDL_KeyCode_SDLK_LEFT: SDL_KeyCode = 1073741904;
pub const SDL_KeyCode_SDLK_DOWN: SDL_KeyCode = 1073741905;
pub const SDL_KeyCode_SDLK_UP: SDL_KeyCode = 1073741906;
pub const SDL_KeyCode_SDLK_NUMLOCKCLEAR: SDL_KeyCode = 1073741907;
pub const SDL_KeyCode_SDLK_KP_DIVIDE: SDL_KeyCode = 1073741908;
pub const SDL_KeyCode_SDLK_KP_MULTIPLY: SDL_KeyCode = 1073741909;
pub const SDL_KeyCode_SDLK_KP_MINUS: SDL_KeyCode = 1073741910;
pub const SDL_KeyCode_SDLK_KP_PLUS: SDL_KeyCode = 1073741911;
pub const SDL_KeyCode_SDLK_KP_ENTER: SDL_KeyCode = 1073741912;
pub const SDL_KeyCode_SDLK_KP_1: SDL_KeyCode = 1073741913;
pub const SDL_KeyCode_SDLK_KP_2: SDL_KeyCode = 1073741914;
pub const SDL_KeyCode_SDLK_KP_3: SDL_KeyCode = 1073741915;
pub const SDL_KeyCode_SDLK_KP_4: SDL_KeyCode = 1073741916;
pub const SDL_KeyCode_SDLK_KP_5: SDL_KeyCode = 1073741917;
pub const SDL_KeyCode_SDLK_KP_6: SDL_KeyCode = 1073741918;
pub const SDL_KeyCode_SDLK_KP_7: SDL_KeyCode = 1073741919;
pub const SDL_KeyCode_SDLK_KP_8: SDL_KeyCode = 1073741920;
pub const SDL_KeyCode_SDLK_KP_9: SDL_KeyCode = 1073741921;
pub const SDL_KeyCode_SDLK_KP_0: SDL_KeyCode = 1073741922;
pub const SDL_KeyCode_SDLK_KP_PERIOD: SDL_KeyCode = 1073741923;
pub const SDL_KeyCode_SDLK_APPLICATION: SDL_KeyCode = 1073741925;
pub const SDL_KeyCode_SDLK_POWER: SDL_KeyCode = 1073741926;
pub const SDL_KeyCode_SDLK_KP_EQUALS: SDL_KeyCode = 1073741927;
pub const SDL_KeyCode_SDLK_F13: SDL_KeyCode = 1073741928;
pub const SDL_KeyCode_SDLK_F14: SDL_KeyCode = 1073741929;
pub const SDL_KeyCode_SDLK_F15: SDL_KeyCode = 1073741930;
pub const SDL_KeyCode_SDLK_F16: SDL_KeyCode = 1073741931;
pub const SDL_KeyCode_SDLK_F17: SDL_KeyCode = 1073741932;
pub const SDL_KeyCode_SDLK_F18: SDL_KeyCode = 1073741933;
pub const SDL_KeyCode_SDLK_F19: SDL_KeyCode = 1073741934;
pub const SDL_KeyCode_SDLK_F20: SDL_KeyCode = 1073741935;
pub const SDL_KeyCode_SDLK_F21: SDL_KeyCode = 1073741936;
pub const SDL_KeyCode_SDLK_F22: SDL_KeyCode = 1073741937;
pub const SDL_KeyCode_SDLK_F23: SDL_KeyCode = 1073741938;
pub const SDL_KeyCode_SDLK_F24: SDL_KeyCode = 1073741939;
pub const SDL_KeyCode_SDLK_EXECUTE: SDL_KeyCode = 1073741940;
pub const SDL_KeyCode_SDLK_HELP: SDL_KeyCode = 1073741941;
pub const SDL_KeyCode_SDLK_MENU: SDL_KeyCode = 1073741942;
pub const SDL_KeyCode_SDLK_SELECT: SDL_KeyCode = 1073741943;
pub const SDL_KeyCode_SDLK_STOP: SDL_KeyCode = 1073741944;
pub const SDL_KeyCode_SDLK_AGAIN: SDL_KeyCode = 1073741945;
pub const SDL_KeyCode_SDLK_UNDO: SDL_KeyCode = 1073741946;
pub const SDL_KeyCode_SDLK_CUT: SDL_KeyCode = 1073741947;
pub const SDL_KeyCode_SDLK_COPY: SDL_KeyCode = 1073741948;
pub const SDL_KeyCode_SDLK_PASTE: SDL_KeyCode = 1073741949;
pub const SDL_KeyCode_SDLK_FIND: SDL_KeyCode = 1073741950;
pub const SDL_KeyCode_SDLK_MUTE: SDL_KeyCode = 1073741951;
pub const SDL_KeyCode_SDLK_VOLUMEUP: SDL_KeyCode = 1073741952;
pub const SDL_KeyCode_SDLK_VOLUMEDOWN: SDL_KeyCode = 1073741953;
pub const SDL_KeyCode_SDLK_KP_COMMA: SDL_KeyCode = 1073741957;
pub const SDL_KeyCode_SDLK_KP_EQUALSAS400: SDL_KeyCode = 1073741958;
pub const SDL_KeyCode_SDLK_ALTERASE: SDL_KeyCode = 1073741977;
pub const SDL_KeyCode_SDLK_SYSREQ: SDL_KeyCode = 1073741978;
pub const SDL_KeyCode_SDLK_CANCEL: SDL_KeyCode = 1073741979;
pub const SDL_KeyCode_SDLK_CLEAR: SDL_KeyCode = 1073741980;
pub const SDL_KeyCode_SDLK_PRIOR: SDL_KeyCode = 1073741981;
pub const SDL_KeyCode_SDLK_RETURN2: SDL_KeyCode = 1073741982;
pub const SDL_KeyCode_SDLK_SEPARATOR: SDL_KeyCode = 1073741983;
pub const SDL_KeyCode_SDLK_OUT: SDL_KeyCode = 1073741984;
pub const SDL_KeyCode_SDLK_OPER: SDL_KeyCode = 1073741985;
pub const SDL_KeyCode_SDLK_CLEARAGAIN: SDL_KeyCode = 1073741986;
pub const SDL_KeyCode_SDLK_CRSEL: SDL_KeyCode = 1073741987;
pub const SDL_KeyCode_SDLK_EXSEL: SDL_KeyCode = 1073741988;
pub const SDL_KeyCode_SDLK_KP_00: SDL_KeyCode = 1073742000;
pub const SDL_KeyCode_SDLK_KP_000: SDL_KeyCode = 1073742001;
pub const SDL_KeyCode_SDLK_THOUSANDSSEPARATOR: SDL_KeyCode = 1073742002;
pub const SDL_KeyCode_SDLK_DECIMALSEPARATOR: SDL_KeyCode = 1073742003;
pub const SDL_KeyCode_SDLK_CURRENCYUNIT: SDL_KeyCode = 1073742004;
pub const SDL_KeyCode_SDLK_CURRENCYSUBUNIT: SDL_KeyCode = 1073742005;
pub const SDL_KeyCode_SDLK_KP_LEFTPAREN: SDL_KeyCode = 1073742006;
pub const SDL_KeyCode_SDLK_KP_RIGHTPAREN: SDL_KeyCode = 1073742007;
pub const SDL_KeyCode_SDLK_KP_LEFTBRACE: SDL_KeyCode = 1073742008;
pub const SDL_KeyCode_SDLK_KP_RIGHTBRACE: SDL_KeyCode = 1073742009;
pub const SDL_KeyCode_SDLK_KP_TAB: SDL_KeyCode = 1073742010;
pub const SDL_KeyCode_SDLK_KP_BACKSPACE: SDL_KeyCode = 1073742011;
pub const SDL_KeyCode_SDLK_KP_A: SDL_KeyCode = 1073742012;
pub const SDL_KeyCode_SDLK_KP_B: SDL_KeyCode = 1073742013;
pub const SDL_KeyCode_SDLK_KP_C: SDL_KeyCode = 1073742014;
pub const SDL_KeyCode_SDLK_KP_D: SDL_KeyCode = 1073742015;
pub const SDL_KeyCode_SDLK_KP_E: SDL_KeyCode = 1073742016;
pub const SDL_KeyCode_SDLK_KP_F: SDL_KeyCode = 1073742017;
pub const SDL_KeyCode_SDLK_KP_XOR: SDL_KeyCode = 1073742018;
pub const SDL_KeyCode_SDLK_KP_POWER: SDL_KeyCode = 1073742019;
pub const SDL_KeyCode_SDLK_KP_PERCENT: SDL_KeyCode = 1073742020;
pub const SDL_KeyCode_SDLK_KP_LESS: SDL_KeyCode = 1073742021;
pub const SDL_KeyCode_SDLK_KP_GREATER: SDL_KeyCode = 1073742022;
pub const SDL_KeyCode_SDLK_KP_AMPERSAND: SDL_KeyCode = 1073742023;
pub const SDL_KeyCode_SDLK_KP_DBLAMPERSAND: SDL_KeyCode = 1073742024;
pub const SDL_KeyCode_SDLK_KP_VERTICALBAR: SDL_KeyCode = 1073742025;
pub const SDL_KeyCode_SDLK_KP_DBLVERTICALBAR: SDL_KeyCode = 1073742026;
pub const SDL_KeyCode_SDLK_KP_COLON: SDL_KeyCode = 1073742027;
pub const SDL_KeyCode_SDLK_KP_HASH: SDL_KeyCode = 1073742028;
pub const SDL_KeyCode_SDLK_KP_SPACE: SDL_KeyCode = 1073742029;
pub const SDL_KeyCode_SDLK_KP_AT: SDL_KeyCode = 1073742030;
pub const SDL_KeyCode_SDLK_KP_EXCLAM: SDL_KeyCode = 1073742031;
pub const SDL_KeyCode_SDLK_KP_MEMSTORE: SDL_KeyCode = 1073742032;
pub const SDL_KeyCode_SDLK_KP_MEMRECALL: SDL_KeyCode = 1073742033;
pub const SDL_KeyCode_SDLK_KP_MEMCLEAR: SDL_KeyCode = 1073742034;
pub const SDL_KeyCode_SDLK_KP_MEMADD: SDL_KeyCode = 1073742035;
pub const SDL_KeyCode_SDLK_KP_MEMSUBTRACT: SDL_KeyCode = 1073742036;
pub const SDL_KeyCode_SDLK_KP_MEMMULTIPLY: SDL_KeyCode = 1073742037;
pub const SDL_KeyCode_SDLK_KP_MEMDIVIDE: SDL_KeyCode = 1073742038;
pub const SDL_KeyCode_SDLK_KP_PLUSMINUS: SDL_KeyCode = 1073742039;
pub const SDL_KeyCode_SDLK_KP_CLEAR: SDL_KeyCode = 1073742040;
pub const SDL_KeyCode_SDLK_KP_CLEARENTRY: SDL_KeyCode = 1073742041;
pub const SDL_KeyCode_SDLK_KP_BINARY: SDL_KeyCode = 1073742042;
pub const SDL_KeyCode_SDLK_KP_OCTAL: SDL_KeyCode = 1073742043;
pub const SDL_KeyCode_SDLK_KP_DECIMAL: SDL_KeyCode = 1073742044;
pub const SDL_KeyCode_SDLK_KP_HEXADECIMAL: SDL_KeyCode = 1073742045;
pub const SDL_KeyCode_SDLK_LCTRL: SDL_KeyCode = 1073742048;
pub const SDL_KeyCode_SDLK_LSHIFT: SDL_KeyCode = 1073742049;
pub const SDL_KeyCode_SDLK_LALT: SDL_KeyCode = 1073742050;
pub const SDL_KeyCode_SDLK_LGUI: SDL_KeyCode = 1073742051;
pub const SDL_KeyCode_SDLK_RCTRL: SDL_KeyCode = 1073742052;
pub const SDL_KeyCode_SDLK_RSHIFT: SDL_KeyCode = 1073742053;
pub const SDL_KeyCode_SDLK_RALT: SDL_KeyCode = 1073742054;
pub const SDL_KeyCode_SDLK_RGUI: SDL_KeyCode = 1073742055;
pub const SDL_KeyCode_SDLK_MODE: SDL_KeyCode = 1073742081;
pub const SDL_KeyCode_SDLK_AUDIONEXT: SDL_KeyCode = 1073742082;
pub const SDL_KeyCode_SDLK_AUDIOPREV: SDL_KeyCode = 1073742083;
pub const SDL_KeyCode_SDLK_AUDIOSTOP: SDL_KeyCode = 1073742084;
pub const SDL_KeyCode_SDLK_AUDIOPLAY: SDL_KeyCode = 1073742085;
pub const SDL_KeyCode_SDLK_AUDIOMUTE: SDL_KeyCode = 1073742086;
pub const SDL_KeyCode_SDLK_MEDIASELECT: SDL_KeyCode = 1073742087;
pub const SDL_KeyCode_SDLK_WWW: SDL_KeyCode = 1073742088;
pub const SDL_KeyCode_SDLK_MAIL: SDL_KeyCode = 1073742089;
pub const SDL_KeyCode_SDLK_CALCULATOR: SDL_KeyCode = 1073742090;
pub const SDL_KeyCode_SDLK_COMPUTER: SDL_KeyCode = 1073742091;
pub const SDL_KeyCode_SDLK_AC_SEARCH: SDL_KeyCode = 1073742092;
pub const SDL_KeyCode_SDLK_AC_HOME: SDL_KeyCode = 1073742093;
pub const SDL_KeyCode_SDLK_AC_BACK: SDL_KeyCode = 1073742094;
pub const SDL_KeyCode_SDLK_AC_FORWARD: SDL_KeyCode = 1073742095;
pub const SDL_KeyCode_SDLK_AC_STOP: SDL_KeyCode = 1073742096;
pub const SDL_KeyCode_SDLK_AC_REFRESH: SDL_KeyCode = 1073742097;
pub const SDL_KeyCode_SDLK_AC_BOOKMARKS: SDL_KeyCode = 1073742098;
pub const SDL_KeyCode_SDLK_BRIGHTNESSDOWN: SDL_KeyCode = 1073742099;
pub const SDL_KeyCode_SDLK_BRIGHTNESSUP: SDL_KeyCode = 1073742100;
pub const SDL_KeyCode_SDLK_DISPLAYSWITCH: SDL_KeyCode = 1073742101;
pub const SDL_KeyCode_SDLK_KBDILLUMTOGGLE: SDL_KeyCode = 1073742102;
pub const SDL_KeyCode_SDLK_KBDILLUMDOWN: SDL_KeyCode = 1073742103;
pub const SDL_KeyCode_SDLK_KBDILLUMUP: SDL_KeyCode = 1073742104;
pub const SDL_KeyCode_SDLK_EJECT: SDL_KeyCode = 1073742105;
pub const SDL_KeyCode_SDLK_SLEEP: SDL_KeyCode = 1073742106;
pub const SDL_KeyCode_SDLK_APP1: SDL_KeyCode = 1073742107;
pub const SDL_KeyCode_SDLK_APP2: SDL_KeyCode = 1073742108;
pub const SDL_KeyCode_SDLK_AUDIOREWIND: SDL_KeyCode = 1073742109;
pub const SDL_KeyCode_SDLK_AUDIOFASTFORWARD: SDL_KeyCode = 1073742110;
pub type SDL_KeyCode = u32;
pub const SDL_Keymod_KMOD_NONE: SDL_Keymod = 0;
pub const SDL_Keymod_KMOD_LSHIFT: SDL_Keymod = 1;
pub const SDL_Keymod_KMOD_RSHIFT: SDL_Keymod = 2;
pub const SDL_Keymod_KMOD_LCTRL: SDL_Keymod = 64;
pub const SDL_Keymod_KMOD_RCTRL: SDL_Keymod = 128;
pub const SDL_Keymod_KMOD_LALT: SDL_Keymod = 256;
pub const SDL_Keymod_KMOD_RALT: SDL_Keymod = 512;
pub const SDL_Keymod_KMOD_LGUI: SDL_Keymod = 1024;
pub const SDL_Keymod_KMOD_RGUI: SDL_Keymod = 2048;
pub const SDL_Keymod_KMOD_NUM: SDL_Keymod = 4096;
pub const SDL_Keymod_KMOD_CAPS: SDL_Keymod = 8192;
pub const SDL_Keymod_KMOD_MODE: SDL_Keymod = 16384;
pub const SDL_Keymod_KMOD_RESERVED: SDL_Keymod = 32768;
#[doc = " \\brief Enumeration of valid key mods (possibly OR'd together)."]
pub type SDL_Keymod = u32;
#[doc = "  \\brief The SDL keysym structure, used in key events."]
#[doc = ""]
#[doc = "  \\note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Keysym {
    #[doc = "< SDL physical key code - see ::SDL_Scancode for details"]
    pub scancode: SDL_Scancode,
    #[doc = "< SDL virtual key code - see ::SDL_Keycode for details"]
    pub sym: SDL_Keycode,
    #[doc = "< current key modifiers"]
    pub mod_: Uint16,
    pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Keysym>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Keysym>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Keysym>())).scancode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(scancode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Keysym>())).sym as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Keysym>())).mod_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Keysym>())).unused as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Get the window which currently has keyboard focus."]
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get a snapshot of the current state of the keyboard."]
    #[doc = ""]
    #[doc = "  \\param numkeys if non-NULL, receives the length of the returned array."]
    #[doc = ""]
    #[doc = "  \\return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values."]
    #[doc = ""]
    #[doc = "  \\b Example:"]
    #[doc = "  \\code"]
    #[doc = "  const Uint8 *state = SDL_GetKeyboardState(NULL);"]
    #[doc = "  if ( state[SDL_SCANCODE_RETURN] )   {"]
    #[doc = "      printf(\"<RETURN> is pressed.\\n\");"]
    #[doc = "  }"]
    #[doc = "  \\endcode"]
    pub fn SDL_GetKeyboardState(numkeys: *mut ::std::os::raw::c_int) -> *const Uint8;
}
extern "C" {
    #[doc = "  \\brief Get the current key modifier state for the keyboard."]
    pub fn SDL_GetModState() -> SDL_Keymod;
}
extern "C" {
    #[doc = "  \\brief Set the current key modifier state for the keyboard."]
    #[doc = ""]
    #[doc = "  \\note This does not change the keyboard state, only the key modifier flags."]
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
extern "C" {
    #[doc = "  \\brief Get the key code corresponding to the given scancode according"]
    #[doc = "         to the current keyboard layout."]
    #[doc = ""]
    #[doc = "  See ::SDL_Keycode for details."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetKeyName()"]
    pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode) -> SDL_Keycode;
}
extern "C" {
    #[doc = "  \\brief Get the scancode corresponding to the given key code according to the"]
    #[doc = "         current keyboard layout."]
    #[doc = ""]
    #[doc = "  See ::SDL_Scancode for details."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetScancodeName()"]
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode;
}
extern "C" {
    #[doc = "  \\brief Get a human-readable name for a scancode."]
    #[doc = ""]
    #[doc = "  \\return A pointer to the name for the scancode."]
    #[doc = "          If the scancode doesn't have a name, this function returns"]
    #[doc = "          an empty string (\"\")."]
    #[doc = ""]
    #[doc = "  \\sa SDL_Scancode"]
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get a scancode from a human-readable name"]
    #[doc = ""]
    #[doc = "  \\return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized"]
    #[doc = ""]
    #[doc = "  \\sa SDL_Scancode"]
    pub fn SDL_GetScancodeFromName(name: *const ::std::os::raw::c_char) -> SDL_Scancode;
}
extern "C" {
    #[doc = "  \\brief Get a human-readable name for a key."]
    #[doc = ""]
    #[doc = "  \\return A pointer to a UTF-8 string that stays valid at least until the next"]
    #[doc = "          call to this function. If you need it around any longer, you must"]
    #[doc = "          copy it.  If the key doesn't have a name, this function returns an"]
    #[doc = "          empty string (\"\")."]
    #[doc = ""]
    #[doc = "  \\sa SDL_Keycode"]
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get a key code from a human-readable name"]
    #[doc = ""]
    #[doc = "  \\return key code, or SDLK_UNKNOWN if the name wasn't recognized"]
    #[doc = ""]
    #[doc = "  \\sa SDL_Keycode"]
    pub fn SDL_GetKeyFromName(name: *const ::std::os::raw::c_char) -> SDL_Keycode;
}
extern "C" {
    #[doc = "  \\brief Start accepting Unicode text input events."]
    #[doc = "         This function will show the on-screen keyboard if supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_StopTextInput()"]
    #[doc = "  \\sa SDL_SetTextInputRect()"]
    #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
    pub fn SDL_StartTextInput();
}
extern "C" {
    #[doc = "  \\brief Return whether or not Unicode text input events are enabled."]
    #[doc = ""]
    #[doc = "  \\sa SDL_StartTextInput()"]
    #[doc = "  \\sa SDL_StopTextInput()"]
    pub fn SDL_IsTextInputActive() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Stop receiving any text input events."]
    #[doc = "         This function will hide the on-screen keyboard if supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_StartTextInput()"]
    #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
    pub fn SDL_StopTextInput();
}
extern "C" {
    #[doc = "  \\brief Set the rectangle used to type Unicode text inputs."]
    #[doc = "         This is used as a hint for IME and on-screen keyboard placement."]
    #[doc = ""]
    #[doc = "  \\sa SDL_StartTextInput()"]
    pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Returns whether the platform has some screen keyboard support."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if some keyboard support is available else SDL_FALSE."]
    #[doc = ""]
    #[doc = "  \\note Not all screen keyboard functions are supported on all platforms."]
    #[doc = ""]
    #[doc = "  \\sa SDL_IsScreenKeyboardShown()"]
    pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Returns whether the screen keyboard is shown for given window."]
    #[doc = ""]
    #[doc = "  \\param window The window for which screen keyboard should be queried."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if screen keyboard is shown else SDL_FALSE."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
    pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[doc = "< Arrow"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_ARROW: SDL_SystemCursor = 0;
#[doc = "< I-beam"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_IBEAM: SDL_SystemCursor = 1;
#[doc = "< Wait"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAIT: SDL_SystemCursor = 2;
#[doc = "< Crosshair"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_CROSSHAIR: SDL_SystemCursor = 3;
#[doc = "< Small wait cursor (or Wait if not available)"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAITARROW: SDL_SystemCursor = 4;
#[doc = "< Double arrow pointing northwest and southeast"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENWSE: SDL_SystemCursor = 5;
#[doc = "< Double arrow pointing northeast and southwest"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENESW: SDL_SystemCursor = 6;
#[doc = "< Double arrow pointing west and east"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZEWE: SDL_SystemCursor = 7;
#[doc = "< Double arrow pointing north and south"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENS: SDL_SystemCursor = 8;
#[doc = "< Four pointed arrow pointing north, south, east, and west"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZEALL: SDL_SystemCursor = 9;
#[doc = "< Slashed circle or crossbones"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NO: SDL_SystemCursor = 10;
#[doc = "< Hand"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_HAND: SDL_SystemCursor = 11;
pub const SDL_SystemCursor_SDL_NUM_SYSTEM_CURSORS: SDL_SystemCursor = 12;
#[doc = " \\brief Cursor types for SDL_CreateSystemCursor()."]
pub type SDL_SystemCursor = u32;
#[doc = "< The scroll direction is normal"]
pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_NORMAL: SDL_MouseWheelDirection = 0;
#[doc = "< The scroll direction is flipped / natural"]
pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_FLIPPED: SDL_MouseWheelDirection = 1;
#[doc = " \\brief Scroll direction types for the Scroll event"]
pub type SDL_MouseWheelDirection = u32;
extern "C" {
    #[doc = "  \\brief Get the window which currently has mouse focus."]
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Retrieve the current state of the mouse."]
    #[doc = ""]
    #[doc = "  The current button state is returned as a button bitmask, which can"]
    #[doc = "  be tested using the SDL_BUTTON(X) macros, and x and y are set to the"]
    #[doc = "  mouse cursor position relative to the focus window for the currently"]
    #[doc = "  selected mouse.  You can pass NULL for either x or y."]
    pub fn SDL_GetMouseState(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Get the current state of the mouse, in relation to the desktop"]
    #[doc = ""]
    #[doc = "  This works just like SDL_GetMouseState(), but the coordinates will be"]
    #[doc = "  reported relative to the top-left of the desktop. This can be useful if"]
    #[doc = "  you need to track the mouse outside of a specific window and"]
    #[doc = "  SDL_CaptureMouse() doesn't fit your needs. For example, it could be"]
    #[doc = "  useful if you need to track the mouse while dragging a window, where"]
    #[doc = "  coordinates relative to a window might not be in sync at all times."]
    #[doc = ""]
    #[doc = "  \\note SDL_GetMouseState() returns the mouse position as SDL understands"]
    #[doc = "        it from the last pump of the event queue. This function, however,"]
    #[doc = "        queries the OS for the current mouse position, and as such, might"]
    #[doc = "        be a slightly less efficient function. Unless you know what you're"]
    #[doc = "        doing and have a good reason to use this function, you probably want"]
    #[doc = "        SDL_GetMouseState() instead."]
    #[doc = ""]
    #[doc = "  \\param x Returns the current X coord, relative to the desktop. Can be NULL."]
    #[doc = "  \\param y Returns the current Y coord, relative to the desktop. Can be NULL."]
    #[doc = "  \\return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetMouseState"]
    pub fn SDL_GetGlobalMouseState(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Retrieve the relative state of the mouse."]
    #[doc = ""]
    #[doc = "  The current button state is returned as a button bitmask, which can"]
    #[doc = "  be tested using the SDL_BUTTON(X) macros, and x and y are set to the"]
    #[doc = "  mouse deltas since the last call to SDL_GetRelativeMouseState()."]
    pub fn SDL_GetRelativeMouseState(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Moves the mouse to the given position within the window."]
    #[doc = ""]
    #[doc = "  \\param window The window to move the mouse into, or NULL for the current mouse focus"]
    #[doc = "  \\param x The x coordinate within the window"]
    #[doc = "  \\param y The y coordinate within the window"]
    #[doc = ""]
    #[doc = "  \\note This function generates a mouse motion event"]
    pub fn SDL_WarpMouseInWindow(
        window: *mut SDL_Window,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Moves the mouse to the given position in global screen space."]
    #[doc = ""]
    #[doc = "  \\param x The x coordinate"]
    #[doc = "  \\param y The y coordinate"]
    #[doc = "  \\return 0 on success, -1 on error (usually: unsupported by a platform)."]
    #[doc = ""]
    #[doc = "  \\note This function generates a mouse motion event"]
    pub fn SDL_WarpMouseGlobal(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set relative mouse mode."]
    #[doc = ""]
    #[doc = "  \\param enabled Whether or not to enable relative mode"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if relative mode is not supported."]
    #[doc = ""]
    #[doc = "  While the mouse is in relative mode, the cursor is hidden, and the"]
    #[doc = "  driver will try to report continuous motion in the current window."]
    #[doc = "  Only relative motion events will be delivered, the mouse position"]
    #[doc = "  will not change."]
    #[doc = ""]
    #[doc = "  \\note This function will flush any pending mouse motion."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetRelativeMouseMode()"]
    pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Capture the mouse, to track input outside an SDL window."]
    #[doc = ""]
    #[doc = "  \\param enabled Whether or not to enable capturing"]
    #[doc = ""]
    #[doc = "  Capturing enables your app to obtain mouse events globally, instead of"]
    #[doc = "  just within your window. Not all video targets support this function."]
    #[doc = "  When capturing is enabled, the current window will get all mouse events,"]
    #[doc = "  but unlike relative mode, no change is made to the cursor and it is"]
    #[doc = "  not restrained to your window."]
    #[doc = ""]
    #[doc = "  This function may also deny mouse input to other windows--both those in"]
    #[doc = "  your application and others on the system--so you should use this"]
    #[doc = "  function sparingly, and in small bursts. For example, you might want to"]
    #[doc = "  track the mouse while the user is dragging something, until the user"]
    #[doc = "  releases a mouse button. It is not recommended that you capture the mouse"]
    #[doc = "  for long periods of time, such as the entire time your app is running."]
    #[doc = ""]
    #[doc = "  While captured, mouse events still report coordinates relative to the"]
    #[doc = "  current (foreground) window, but those coordinates may be outside the"]
    #[doc = "  bounds of the window (including negative values). Capturing is only"]
    #[doc = "  allowed for the foreground window. If the window loses focus while"]
    #[doc = "  capturing, the capture will be disabled automatically."]
    #[doc = ""]
    #[doc = "  While capturing is enabled, the current window will have the"]
    #[doc = "  SDL_WINDOW_MOUSE_CAPTURE flag set."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if not supported."]
    pub fn SDL_CaptureMouse(enabled: SDL_bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Query whether relative mouse mode is enabled."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetRelativeMouseMode()"]
    pub fn SDL_GetRelativeMouseMode() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Create a cursor, using the specified bitmap data and"]
    #[doc = "         mask (in MSB format)."]
    #[doc = ""]
    #[doc = "  The cursor width must be a multiple of 8 bits."]
    #[doc = ""]
    #[doc = "  The cursor is created in black and white according to the following:"]
    #[doc = "  <table>"]
    #[doc = "  <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>"]
    #[doc = "  <tr><td>  0   </td><td>  1   </td><td> White </td></tr>"]
    #[doc = "  <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>"]
    #[doc = "  <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>"]
    #[doc = "  <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black"]
    #[doc = "                                         if not. </td></tr>"]
    #[doc = "  </table>"]
    #[doc = ""]
    #[doc = "  \\sa SDL_FreeCursor()"]
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hot_x: ::std::os::raw::c_int,
        hot_y: ::std::os::raw::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Create a color cursor."]
    #[doc = ""]
    #[doc = "  \\sa SDL_FreeCursor()"]
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: ::std::os::raw::c_int,
        hot_y: ::std::os::raw::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Create a system cursor."]
    #[doc = ""]
    #[doc = "  \\sa SDL_FreeCursor()"]
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Set the active cursor."]
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = "  \\brief Return the active cursor."]
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Return the default cursor."]
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Frees a cursor created with SDL_CreateCursor() or similar functions."]
    #[doc = ""]
    #[doc = "  \\sa SDL_CreateCursor()"]
    #[doc = "  \\sa SDL_CreateColorCursor()"]
    #[doc = "  \\sa SDL_CreateSystemCursor()"]
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = "  \\brief Toggle whether or not the cursor is shown."]
    #[doc = ""]
    #[doc = "  \\param toggle 1 to show the cursor, 0 to hide it, -1 to query the current"]
    #[doc = "                state."]
    #[doc = ""]
    #[doc = "  \\return 1 if the cursor is shown, or 0 if the cursor is hidden."]
    pub fn SDL_ShowCursor(toggle: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " The joystick structure used to identify an SDL joystick"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
    _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoystickGUID {
    pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoystickGUID>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoystickGUID>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoystickGUID>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoystickGUID),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " This is a unique ID for a joystick for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application. If the joystick is"]
#[doc = " disconnected and reconnected, it will get a new ID."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_JoystickID = Sint32;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_UNKNOWN: SDL_JoystickType = 0;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GAMECONTROLLER: SDL_JoystickType = 1;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_WHEEL: SDL_JoystickType = 2;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_STICK: SDL_JoystickType = 3;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_FLIGHT_STICK: SDL_JoystickType = 4;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DANCE_PAD: SDL_JoystickType = 5;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GUITAR: SDL_JoystickType = 6;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DRUM_KIT: SDL_JoystickType = 7;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_PAD: SDL_JoystickType = 8;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_THROTTLE: SDL_JoystickType = 9;
pub type SDL_JoystickType = u32;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_UNKNOWN: SDL_JoystickPowerLevel = -1;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_EMPTY: SDL_JoystickPowerLevel = 0;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_LOW: SDL_JoystickPowerLevel = 1;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_MEDIUM: SDL_JoystickPowerLevel = 2;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_FULL: SDL_JoystickPowerLevel = 3;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_WIRED: SDL_JoystickPowerLevel = 4;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_MAX: SDL_JoystickPowerLevel = 5;
pub type SDL_JoystickPowerLevel = i32;
extern "C" {
    #[doc = " Locking for multi-threaded access to the joystick API"]
    #[doc = ""]
    #[doc = " If you are using the joystick API or handling events from multiple threads"]
    #[doc = " you should use these locking functions to protect access to the joysticks."]
    #[doc = ""]
    #[doc = " In particular, you are guaranteed that the joystick list won't change, so"]
    #[doc = " the API functions that take a joystick index will be valid, and joystick"]
    #[doc = " and game controller events will not be delivered."]
    pub fn SDL_LockJoysticks();
}
extern "C" {
    pub fn SDL_UnlockJoysticks();
}
extern "C" {
    #[doc = "  Count the number of joysticks attached to the system right now"]
    pub fn SDL_NumJoysticks() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the implementation dependent name of a joystick."]
    #[doc = "  This can be called before any joysticks are opened."]
    #[doc = "  If no name can be found, this function returns NULL."]
    pub fn SDL_JoystickNameForIndex(
        device_index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the player index of a joystick, or -1 if it's not available"]
    #[doc = "  This can be called before any joysticks are opened."]
    pub fn SDL_JoystickGetDevicePlayerIndex(
        device_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Return the GUID for the joystick at this index"]
    #[doc = "  This can be called before any joysticks are opened."]
    pub fn SDL_JoystickGetDeviceGUID(device_index: ::std::os::raw::c_int) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = "  Get the USB vendor ID of a joystick, if available."]
    #[doc = "  This can be called before any joysticks are opened."]
    #[doc = "  If the vendor ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetDeviceVendor(device_index: ::std::os::raw::c_int) -> Uint16;
}
extern "C" {
    #[doc = "  Get the USB product ID of a joystick, if available."]
    #[doc = "  This can be called before any joysticks are opened."]
    #[doc = "  If the product ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetDeviceProduct(device_index: ::std::os::raw::c_int) -> Uint16;
}
extern "C" {
    #[doc = "  Get the product version of a joystick, if available."]
    #[doc = "  This can be called before any joysticks are opened."]
    #[doc = "  If the product version isn't available this function returns 0."]
    pub fn SDL_JoystickGetDeviceProductVersion(device_index: ::std::os::raw::c_int) -> Uint16;
}
extern "C" {
    #[doc = "  Get the type of a joystick, if available."]
    #[doc = "  This can be called before any joysticks are opened."]
    pub fn SDL_JoystickGetDeviceType(device_index: ::std::os::raw::c_int) -> SDL_JoystickType;
}
extern "C" {
    #[doc = "  Get the instance ID of a joystick."]
    #[doc = "  This can be called before any joysticks are opened."]
    #[doc = "  If the index is out of range, this function will return -1."]
    pub fn SDL_JoystickGetDeviceInstanceID(device_index: ::std::os::raw::c_int) -> SDL_JoystickID;
}
extern "C" {
    #[doc = "  Open a joystick for use."]
    #[doc = "  The index passed as an argument refers to the N'th joystick on the system."]
    #[doc = "  This index is not the value which will identify this joystick in future"]
    #[doc = "  joystick events.  The joystick's instance id (::SDL_JoystickID) will be used"]
    #[doc = "  there instead."]
    #[doc = ""]
    #[doc = "  \\return A joystick identifier, or NULL if an error occurred."]
    pub fn SDL_JoystickOpen(device_index: ::std::os::raw::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Return the SDL_Joystick associated with an instance id."]
    pub fn SDL_JoystickFromInstanceID(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Return the SDL_Joystick associated with a player index."]
    pub fn SDL_JoystickFromPlayerIndex(player_index: ::std::os::raw::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = "  Return the name for this currently opened joystick."]
    #[doc = "  If no name can be found, this function returns NULL."]
    pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the player index of an opened joystick, or -1 if it's not available"]
    #[doc = ""]
    #[doc = "  For XInput controllers this returns the XInput user index."]
    pub fn SDL_JoystickGetPlayerIndex(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set the player index of an opened joystick"]
    pub fn SDL_JoystickSetPlayerIndex(
        joystick: *mut SDL_Joystick,
        player_index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  Return the GUID for this opened joystick"]
    pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = "  Get the USB vendor ID of an opened joystick, if available."]
    #[doc = "  If the vendor ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = "  Get the USB product ID of an opened joystick, if available."]
    #[doc = "  If the product ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = "  Get the product version of an opened joystick, if available."]
    #[doc = "  If the product version isn't available this function returns 0."]
    pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = "  Get the type of an opened joystick."]
    pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick) -> SDL_JoystickType;
}
extern "C" {
    #[doc = "  Return a string representation for this guid. pszGUID must point to at least 33 bytes"]
    #[doc = "  (32 for the string plus a NULL terminator)."]
    pub fn SDL_JoystickGetGUIDString(
        guid: SDL_JoystickGUID,
        pszGUID: *mut ::std::os::raw::c_char,
        cbGUID: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  Convert a string into a joystick guid"]
    pub fn SDL_JoystickGetGUIDFromString(
        pchGUID: *const ::std::os::raw::c_char,
    ) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = "  Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not."]
    pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the instance ID of an opened joystick or -1 if the joystick is invalid."]
    pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
    #[doc = "  Get the number of general axis controls on a joystick."]
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the number of trackballs on a joystick."]
    #[doc = ""]
    #[doc = "  Joystick trackballs have only relative motion events associated"]
    #[doc = "  with them and their state cannot be polled."]
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the number of POV hats on a joystick."]
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the number of buttons on a joystick."]
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Update the current state of the open joysticks."]
    #[doc = ""]
    #[doc = "  This is called automatically by the event loop if any joystick"]
    #[doc = "  events are enabled."]
    pub fn SDL_JoystickUpdate();
}
extern "C" {
    #[doc = "  Enable/disable joystick event polling."]
    #[doc = ""]
    #[doc = "  If joystick events are disabled, you must call SDL_JoystickUpdate()"]
    #[doc = "  yourself and check the state of the joystick when you want joystick"]
    #[doc = "  information."]
    #[doc = ""]
    #[doc = "  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
    pub fn SDL_JoystickEventState(state: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the current state of an axis control on a joystick."]
    #[doc = ""]
    #[doc = "  The state is a value ranging from -32768 to 32767."]
    #[doc = ""]
    #[doc = "  The axis indices start at index 0."]
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: ::std::os::raw::c_int) -> Sint16;
}
extern "C" {
    #[doc = "  Get the initial state of an axis control on a joystick."]
    #[doc = ""]
    #[doc = "  The state is a value ranging from -32768 to 32767."]
    #[doc = ""]
    #[doc = "  The axis indices start at index 0."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not."]
    pub fn SDL_JoystickGetAxisInitialState(
        joystick: *mut SDL_Joystick,
        axis: ::std::os::raw::c_int,
        state: *mut Sint16,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the current state of a POV hat on a joystick."]
    #[doc = ""]
    #[doc = "  The hat indices start at index 0."]
    #[doc = ""]
    #[doc = "  \\return The return value is one of the following positions:"]
    #[doc = "           - ::SDL_HAT_CENTERED"]
    #[doc = "           - ::SDL_HAT_UP"]
    #[doc = "           - ::SDL_HAT_RIGHT"]
    #[doc = "           - ::SDL_HAT_DOWN"]
    #[doc = "           - ::SDL_HAT_LEFT"]
    #[doc = "           - ::SDL_HAT_RIGHTUP"]
    #[doc = "           - ::SDL_HAT_RIGHTDOWN"]
    #[doc = "           - ::SDL_HAT_LEFTUP"]
    #[doc = "           - ::SDL_HAT_LEFTDOWN"]
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    #[doc = "  Get the ball axis change since the last poll."]
    #[doc = ""]
    #[doc = "  \\return 0, or -1 if you passed it invalid parameters."]
    #[doc = ""]
    #[doc = "  The ball indices start at index 0."]
    pub fn SDL_JoystickGetBall(
        joystick: *mut SDL_Joystick,
        ball: ::std::os::raw::c_int,
        dx: *mut ::std::os::raw::c_int,
        dy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the current state of a button on a joystick."]
    #[doc = ""]
    #[doc = "  The button indices start at index 0."]
    pub fn SDL_JoystickGetButton(
        joystick: *mut SDL_Joystick,
        button: ::std::os::raw::c_int,
    ) -> Uint8;
}
extern "C" {
    #[doc = "  Trigger a rumble effect"]
    #[doc = "  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling."]
    #[doc = ""]
    #[doc = "  \\param joystick The joystick to vibrate"]
    #[doc = "  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF"]
    #[doc = "  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF"]
    #[doc = "  \\param duration_ms The duration of the rumble effect, in milliseconds"]
    #[doc = ""]
    #[doc = "  \\return 0, or -1 if rumble isn't supported on this joystick"]
    pub fn SDL_JoystickRumble(
        joystick: *mut SDL_Joystick,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Close a joystick previously opened with SDL_JoystickOpen()."]
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
    #[doc = "  Return the battery level of this joystick"]
    pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick) -> SDL_JoystickPowerLevel;
}
#[doc = " The gamecontroller structure used to identify an SDL game controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_GameController {
    _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
pub const SDL_GameControllerType_SDL_CONTROLLER_TYPE_UNKNOWN: SDL_GameControllerType = 0;
pub const SDL_GameControllerType_SDL_CONTROLLER_TYPE_XBOX360: SDL_GameControllerType = 1;
pub const SDL_GameControllerType_SDL_CONTROLLER_TYPE_XBOXONE: SDL_GameControllerType = 2;
pub const SDL_GameControllerType_SDL_CONTROLLER_TYPE_PS3: SDL_GameControllerType = 3;
pub const SDL_GameControllerType_SDL_CONTROLLER_TYPE_PS4: SDL_GameControllerType = 4;
pub const SDL_GameControllerType_SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO: SDL_GameControllerType =
    5;
pub type SDL_GameControllerType = u32;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_NONE: SDL_GameControllerBindType = 0;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_BUTTON: SDL_GameControllerBindType = 1;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_AXIS: SDL_GameControllerBindType = 2;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_HAT: SDL_GameControllerBindType = 3;
pub type SDL_GameControllerBindType = u32;
#[doc = "  Get the SDL joystick layer binding for this controller button/axis mapping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
    pub bindType: SDL_GameControllerBindType,
    pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
    pub button: ::std::os::raw::c_int,
    pub axis: ::std::os::raw::c_int,
    pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
    pub hat: ::std::os::raw::c_int,
    pub hat_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>()))
                .hat_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hat_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).button
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).axis as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).hat as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(hat)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
    assert_eq!(
        ::std::mem::size_of::<SDL_GameControllerButtonBind>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_GameControllerButtonBind>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind>())).bindType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind),
            "::",
            stringify!(bindType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_GameControllerButtonBind>())).value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = "  Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()"]
    #[doc = "  A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt"]
    #[doc = ""]
    #[doc = "  If \\c freerw is non-zero, the stream will be closed after being read."]
    #[doc = ""]
    #[doc = " \\return number of mappings added, -1 on error"]
    pub fn SDL_GameControllerAddMappingsFromRW(
        rw: *mut SDL_RWops,
        freerw: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Add or update an existing mapping configuration"]
    #[doc = ""]
    #[doc = " \\return 1 if mapping is added, 0 if updated, -1 on error"]
    pub fn SDL_GameControllerAddMapping(
        mappingString: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the number of mappings installed"]
    #[doc = ""]
    #[doc = "  \\return the number of mappings"]
    pub fn SDL_GameControllerNumMappings() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the mapping at a particular index."]
    #[doc = ""]
    #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range."]
    pub fn SDL_GameControllerMappingForIndex(
        mapping_index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get a mapping string for a GUID"]
    #[doc = ""]
    #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
    pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get a mapping string for an open GameController"]
    #[doc = ""]
    #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
    pub fn SDL_GameControllerMapping(
        gamecontroller: *mut SDL_GameController,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Is the joystick on this index supported by the game controller interface?"]
    pub fn SDL_IsGameController(joystick_index: ::std::os::raw::c_int) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the implementation dependent name of a game controller."]
    #[doc = "  This can be called before any controllers are opened."]
    #[doc = "  If no name can be found, this function returns NULL."]
    pub fn SDL_GameControllerNameForIndex(
        joystick_index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the type of a game controller."]
    #[doc = "  This can be called before any controllers are opened."]
    pub fn SDL_GameControllerTypeForIndex(
        joystick_index: ::std::os::raw::c_int,
    ) -> SDL_GameControllerType;
}
extern "C" {
    #[doc = "  Get the mapping of a game controller."]
    #[doc = "  This can be called before any controllers are opened."]
    #[doc = ""]
    #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
    pub fn SDL_GameControllerMappingForDeviceIndex(
        joystick_index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Open a game controller for use."]
    #[doc = "  The index passed as an argument refers to the N'th game controller on the system."]
    #[doc = "  This index is not the value which will identify this controller in future"]
    #[doc = "  controller events.  The joystick's instance id (::SDL_JoystickID) will be"]
    #[doc = "  used there instead."]
    #[doc = ""]
    #[doc = "  \\return A controller identifier, or NULL if an error occurred."]
    pub fn SDL_GameControllerOpen(joystick_index: ::std::os::raw::c_int)
        -> *mut SDL_GameController;
}
extern "C" {
    #[doc = " Return the SDL_GameController associated with an instance id."]
    pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = " Return the SDL_GameController associated with a player index."]
    pub fn SDL_GameControllerFromPlayerIndex(
        player_index: ::std::os::raw::c_int,
    ) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = "  Return the name for this currently opened controller"]
    pub fn SDL_GameControllerName(
        gamecontroller: *mut SDL_GameController,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Return the type of this currently opened controller"]
    pub fn SDL_GameControllerGetType(
        gamecontroller: *mut SDL_GameController,
    ) -> SDL_GameControllerType;
}
extern "C" {
    #[doc = "  Get the player index of an opened game controller, or -1 if it's not available"]
    #[doc = ""]
    #[doc = "  For XInput controllers this returns the XInput user index."]
    pub fn SDL_GameControllerGetPlayerIndex(
        gamecontroller: *mut SDL_GameController,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set the player index of an opened game controller"]
    pub fn SDL_GameControllerSetPlayerIndex(
        gamecontroller: *mut SDL_GameController,
        player_index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  Get the USB vendor ID of an opened controller, if available."]
    #[doc = "  If the vendor ID isn't available this function returns 0."]
    pub fn SDL_GameControllerGetVendor(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = "  Get the USB product ID of an opened controller, if available."]
    #[doc = "  If the product ID isn't available this function returns 0."]
    pub fn SDL_GameControllerGetProduct(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = "  Get the product version of an opened controller, if available."]
    #[doc = "  If the product version isn't available this function returns 0."]
    pub fn SDL_GameControllerGetProductVersion(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = "  Returns SDL_TRUE if the controller has been opened and currently connected,"]
    #[doc = "  or SDL_FALSE if it has not."]
    pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the underlying joystick object used by a controller"]
    pub fn SDL_GameControllerGetJoystick(
        gamecontroller: *mut SDL_GameController,
    ) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = "  Enable/disable controller event polling."]
    #[doc = ""]
    #[doc = "  If controller events are disabled, you must call SDL_GameControllerUpdate()"]
    #[doc = "  yourself and check the state of the controller when you want controller"]
    #[doc = "  information."]
    #[doc = ""]
    #[doc = "  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
    pub fn SDL_GameControllerEventState(state: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Update the current state of the open game controllers."]
    #[doc = ""]
    #[doc = "  This is called automatically by the event loop if any game controller"]
    #[doc = "  events are enabled."]
    pub fn SDL_GameControllerUpdate();
}
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_INVALID: SDL_GameControllerAxis = -1;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_LEFTX: SDL_GameControllerAxis = 0;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_LEFTY: SDL_GameControllerAxis = 1;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_RIGHTX: SDL_GameControllerAxis = 2;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_RIGHTY: SDL_GameControllerAxis = 3;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_TRIGGERLEFT: SDL_GameControllerAxis = 4;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_TRIGGERRIGHT: SDL_GameControllerAxis = 5;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_MAX: SDL_GameControllerAxis = 6;
#[doc = "  The list of axes available from a controller"]
#[doc = ""]
#[doc = "  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,"]
#[doc = "  and are centered within ~8000 of zero, though advanced UI will allow users to set"]
#[doc = "  or autodetect the dead zone, which varies between controllers."]
#[doc = ""]
#[doc = "  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX."]
pub type SDL_GameControllerAxis = i32;
extern "C" {
    #[doc = "  turn this string into a axis mapping"]
    pub fn SDL_GameControllerGetAxisFromString(
        pchString: *const ::std::os::raw::c_char,
    ) -> SDL_GameControllerAxis;
}
extern "C" {
    #[doc = "  turn this axis enum into a string mapping"]
    pub fn SDL_GameControllerGetStringForAxis(
        axis: SDL_GameControllerAxis,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
    pub fn SDL_GameControllerGetBindForAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    #[doc = "  Get the current state of an axis control on a game controller."]
    #[doc = ""]
    #[doc = "  The state is a value ranging from -32768 to 32767 (except for the triggers,"]
    #[doc = "  which range from 0 to 32767)."]
    #[doc = ""]
    #[doc = "  The axis indices start at index 0."]
    pub fn SDL_GameControllerGetAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> Sint16;
}
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_INVALID: SDL_GameControllerButton = -1;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_A: SDL_GameControllerButton = 0;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_B: SDL_GameControllerButton = 1;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_X: SDL_GameControllerButton = 2;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_Y: SDL_GameControllerButton = 3;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_BACK: SDL_GameControllerButton = 4;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_GUIDE: SDL_GameControllerButton = 5;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_START: SDL_GameControllerButton = 6;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_LEFTSTICK: SDL_GameControllerButton = 7;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_RIGHTSTICK: SDL_GameControllerButton = 8;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_LEFTSHOULDER: SDL_GameControllerButton = 9;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: SDL_GameControllerButton =
    10;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_UP: SDL_GameControllerButton = 11;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_DOWN: SDL_GameControllerButton = 12;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_LEFT: SDL_GameControllerButton = 13;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_RIGHT: SDL_GameControllerButton = 14;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_MAX: SDL_GameControllerButton = 15;
#[doc = "  The list of buttons available from a controller"]
pub type SDL_GameControllerButton = i32;
extern "C" {
    #[doc = "  turn this string into a button mapping"]
    pub fn SDL_GameControllerGetButtonFromString(
        pchString: *const ::std::os::raw::c_char,
    ) -> SDL_GameControllerButton;
}
extern "C" {
    #[doc = "  turn this button enum into a string mapping"]
    pub fn SDL_GameControllerGetStringForButton(
        button: SDL_GameControllerButton,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
    pub fn SDL_GameControllerGetBindForButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    #[doc = "  Get the current state of a button on a game controller."]
    #[doc = ""]
    #[doc = "  The button indices start at index 0."]
    pub fn SDL_GameControllerGetButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> Uint8;
}
extern "C" {
    #[doc = "  Trigger a rumble effect"]
    #[doc = "  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling."]
    #[doc = ""]
    #[doc = "  \\param gamecontroller The controller to vibrate"]
    #[doc = "  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF"]
    #[doc = "  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF"]
    #[doc = "  \\param duration_ms The duration of the rumble effect, in milliseconds"]
    #[doc = ""]
    #[doc = "  \\return 0, or -1 if rumble isn't supported on this joystick"]
    pub fn SDL_GameControllerRumble(
        gamecontroller: *mut SDL_GameController,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Close a controller previously opened with SDL_GameControllerOpen()."]
    pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INVALID: SDL_TouchDeviceType = -1;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_DIRECT: SDL_TouchDeviceType = 0;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE: SDL_TouchDeviceType = 1;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INDIRECT_RELATIVE: SDL_TouchDeviceType = 2;
pub type SDL_TouchDeviceType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Finger {
    pub id: SDL_FingerID,
    pub x: f32,
    pub y: f32,
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Finger>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Finger))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Finger>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Finger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Finger>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Finger>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Finger>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Finger>())).pressure as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(pressure)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Get the number of registered touch devices."]
    pub fn SDL_GetNumTouchDevices() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the touch ID with the given index, or 0 if the index is invalid."]
    pub fn SDL_GetTouchDevice(index: ::std::os::raw::c_int) -> SDL_TouchID;
}
extern "C" {
    #[doc = " \\brief Get the type of the given touch device."]
    pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType;
}
extern "C" {
    #[doc = "  \\brief Get the number of active fingers for a given touch device."]
    pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the finger object of the given touch, with the given index."]
    pub fn SDL_GetTouchFinger(
        touchID: SDL_TouchID,
        index: ::std::os::raw::c_int,
    ) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
    #[doc = "  \\brief Begin Recording a gesture on the specified touch, or all touches (-1)"]
    #[doc = ""]
    #[doc = ""]
    pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Save all currently loaded Dollar Gesture templates"]
    #[doc = ""]
    #[doc = ""]
    pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Save a currently loaded Dollar Gesture template"]
    #[doc = ""]
    #[doc = ""]
    pub fn SDL_SaveDollarTemplate(
        gestureId: SDL_GestureID,
        dst: *mut SDL_RWops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Load Dollar Gesture templates from a file"]
    #[doc = ""]
    #[doc = ""]
    pub fn SDL_LoadDollarTemplates(
        touchId: SDL_TouchID,
        src: *mut SDL_RWops,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Unused (do not remove)"]
pub const SDL_EventType_SDL_FIRSTEVENT: SDL_EventType = 0;
#[doc = "< User-requested quit"]
pub const SDL_EventType_SDL_QUIT: SDL_EventType = 256;
#[doc = "< The application is being terminated by the OS"]
#[doc = "Called on iOS in applicationWillTerminate()"]
#[doc = "Called on Android in onDestroy()"]
pub const SDL_EventType_SDL_APP_TERMINATING: SDL_EventType = 257;
#[doc = "< The application is low on memory, free memory if possible."]
#[doc = "Called on iOS in applicationDidReceiveMemoryWarning()"]
#[doc = "Called on Android in onLowMemory()"]
pub const SDL_EventType_SDL_APP_LOWMEMORY: SDL_EventType = 258;
#[doc = "< The application is about to enter the background"]
#[doc = "Called on iOS in applicationWillResignActive()"]
#[doc = "Called on Android in onPause()"]
pub const SDL_EventType_SDL_APP_WILLENTERBACKGROUND: SDL_EventType = 259;
#[doc = "< The application did enter the background and may not get CPU for some time"]
#[doc = "Called on iOS in applicationDidEnterBackground()"]
#[doc = "Called on Android in onPause()"]
pub const SDL_EventType_SDL_APP_DIDENTERBACKGROUND: SDL_EventType = 260;
#[doc = "< The application is about to enter the foreground"]
#[doc = "Called on iOS in applicationWillEnterForeground()"]
#[doc = "Called on Android in onResume()"]
pub const SDL_EventType_SDL_APP_WILLENTERFOREGROUND: SDL_EventType = 261;
#[doc = "< The application is now interactive"]
#[doc = "Called on iOS in applicationDidBecomeActive()"]
#[doc = "Called on Android in onResume()"]
pub const SDL_EventType_SDL_APP_DIDENTERFOREGROUND: SDL_EventType = 262;
#[doc = "< Display state change"]
pub const SDL_EventType_SDL_DISPLAYEVENT: SDL_EventType = 336;
#[doc = "< Window state change"]
pub const SDL_EventType_SDL_WINDOWEVENT: SDL_EventType = 512;
#[doc = "< System specific event"]
pub const SDL_EventType_SDL_SYSWMEVENT: SDL_EventType = 513;
#[doc = "< Key pressed"]
pub const SDL_EventType_SDL_KEYDOWN: SDL_EventType = 768;
#[doc = "< Key released"]
pub const SDL_EventType_SDL_KEYUP: SDL_EventType = 769;
#[doc = "< Keyboard text editing (composition)"]
pub const SDL_EventType_SDL_TEXTEDITING: SDL_EventType = 770;
#[doc = "< Keyboard text input"]
pub const SDL_EventType_SDL_TEXTINPUT: SDL_EventType = 771;
#[doc = "< Keymap changed due to a system event such as an"]
#[doc = "input language or keyboard layout change."]
pub const SDL_EventType_SDL_KEYMAPCHANGED: SDL_EventType = 772;
#[doc = "< Mouse moved"]
pub const SDL_EventType_SDL_MOUSEMOTION: SDL_EventType = 1024;
#[doc = "< Mouse button pressed"]
pub const SDL_EventType_SDL_MOUSEBUTTONDOWN: SDL_EventType = 1025;
#[doc = "< Mouse button released"]
pub const SDL_EventType_SDL_MOUSEBUTTONUP: SDL_EventType = 1026;
#[doc = "< Mouse wheel motion"]
pub const SDL_EventType_SDL_MOUSEWHEEL: SDL_EventType = 1027;
#[doc = "< Joystick axis motion"]
pub const SDL_EventType_SDL_JOYAXISMOTION: SDL_EventType = 1536;
#[doc = "< Joystick trackball motion"]
pub const SDL_EventType_SDL_JOYBALLMOTION: SDL_EventType = 1537;
#[doc = "< Joystick hat position change"]
pub const SDL_EventType_SDL_JOYHATMOTION: SDL_EventType = 1538;
#[doc = "< Joystick button pressed"]
pub const SDL_EventType_SDL_JOYBUTTONDOWN: SDL_EventType = 1539;
#[doc = "< Joystick button released"]
pub const SDL_EventType_SDL_JOYBUTTONUP: SDL_EventType = 1540;
#[doc = "< A new joystick has been inserted into the system"]
pub const SDL_EventType_SDL_JOYDEVICEADDED: SDL_EventType = 1541;
#[doc = "< An opened joystick has been removed"]
pub const SDL_EventType_SDL_JOYDEVICEREMOVED: SDL_EventType = 1542;
#[doc = "< Game controller axis motion"]
pub const SDL_EventType_SDL_CONTROLLERAXISMOTION: SDL_EventType = 1616;
#[doc = "< Game controller button pressed"]
pub const SDL_EventType_SDL_CONTROLLERBUTTONDOWN: SDL_EventType = 1617;
#[doc = "< Game controller button released"]
pub const SDL_EventType_SDL_CONTROLLERBUTTONUP: SDL_EventType = 1618;
#[doc = "< A new Game controller has been inserted into the system"]
pub const SDL_EventType_SDL_CONTROLLERDEVICEADDED: SDL_EventType = 1619;
#[doc = "< An opened Game controller has been removed"]
pub const SDL_EventType_SDL_CONTROLLERDEVICEREMOVED: SDL_EventType = 1620;
#[doc = "< The controller mapping was updated"]
pub const SDL_EventType_SDL_CONTROLLERDEVICEREMAPPED: SDL_EventType = 1621;
pub const SDL_EventType_SDL_FINGERDOWN: SDL_EventType = 1792;
pub const SDL_EventType_SDL_FINGERUP: SDL_EventType = 1793;
pub const SDL_EventType_SDL_FINGERMOTION: SDL_EventType = 1794;
pub const SDL_EventType_SDL_DOLLARGESTURE: SDL_EventType = 2048;
pub const SDL_EventType_SDL_DOLLARRECORD: SDL_EventType = 2049;
pub const SDL_EventType_SDL_MULTIGESTURE: SDL_EventType = 2050;
#[doc = "< The clipboard changed"]
pub const SDL_EventType_SDL_CLIPBOARDUPDATE: SDL_EventType = 2304;
#[doc = "< The system requests a file open"]
pub const SDL_EventType_SDL_DROPFILE: SDL_EventType = 4096;
#[doc = "< text/plain drag-and-drop event"]
pub const SDL_EventType_SDL_DROPTEXT: SDL_EventType = 4097;
#[doc = "< A new set of drops is beginning (NULL filename)"]
pub const SDL_EventType_SDL_DROPBEGIN: SDL_EventType = 4098;
#[doc = "< Current set of drops is now complete (NULL filename)"]
pub const SDL_EventType_SDL_DROPCOMPLETE: SDL_EventType = 4099;
#[doc = "< A new audio device is available"]
pub const SDL_EventType_SDL_AUDIODEVICEADDED: SDL_EventType = 4352;
#[doc = "< An audio device has been removed."]
pub const SDL_EventType_SDL_AUDIODEVICEREMOVED: SDL_EventType = 4353;
#[doc = "< A sensor was updated"]
pub const SDL_EventType_SDL_SENSORUPDATE: SDL_EventType = 4608;
#[doc = "< The render targets have been reset and their contents need to be updated"]
pub const SDL_EventType_SDL_RENDER_TARGETS_RESET: SDL_EventType = 8192;
#[doc = "< The device has been reset and all textures need to be recreated"]
pub const SDL_EventType_SDL_RENDER_DEVICE_RESET: SDL_EventType = 8193;
#[doc = " Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,"]
#[doc = "  and should be allocated with SDL_RegisterEvents()"]
pub const SDL_EventType_SDL_USEREVENT: SDL_EventType = 32768;
#[doc = "  This last event is only for bounding internal arrays"]
pub const SDL_EventType_SDL_LASTEVENT: SDL_EventType = 65535;
#[doc = " \\brief The types of events that can be delivered."]
pub type SDL_EventType = u32;
#[doc = "  \\brief Fields shared by every event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_CommonEvent {
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_CommonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_CommonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CommonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CommonEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief Display state change event data (event.display.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayEvent {
    #[doc = "< ::SDL_DISPLAYEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated display index"]
    pub display: Uint32,
    #[doc = "< ::SDL_DisplayEventID"]
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DisplayEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DisplayEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DisplayEvent>())).data1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(data1)
        )
    );
}
#[doc = "  \\brief Window state change event data (event.window.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_WindowEvent {
    #[doc = "< ::SDL_WINDOWEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated window"]
    pub windowID: Uint32,
    #[doc = "< ::SDL_WindowEventID"]
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
    #[doc = "< event dependent data"]
    pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_WindowEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_WindowEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).data1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowEvent>())).data2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[doc = "  \\brief Keyboard button event structure (event.key.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_KeyboardEvent {
    #[doc = "< ::SDL_KEYDOWN or ::SDL_KEYUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< Non-zero if this is a key repeat"]
    pub repeat: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The key that was pressed or released"]
    pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_KeyboardEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_KeyboardEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).repeat as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).keysym as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(keysym)
        )
    );
}
#[doc = "  \\brief Keyboard text editing event structure (event.edit.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextEditingEvent {
    #[doc = "< ::SDL_TEXTEDITING"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The editing text"]
    pub text: [::std::os::raw::c_char; 32usize],
    #[doc = "< The start cursor of selected editing text"]
    pub start: Sint32,
    #[doc = "< The length of selected editing text"]
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_TextEditingEvent>(),
        52usize,
        concat!("Size of: ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_TextEditingEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextEditingEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextEditingEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextEditingEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextEditingEvent>())).text as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextEditingEvent>())).start as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextEditingEvent>())).length as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "  \\brief Keyboard text input event structure (event.text.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextInputEvent {
    #[doc = "< ::SDL_TEXTINPUT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The input text"]
    pub text: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_TextInputEvent>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_TextInputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextInputEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextInputEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextInputEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TextInputEvent>())).text as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(text)
        )
    );
}
#[doc = "  \\brief Mouse motion event structure (event.motion.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    #[doc = "< ::SDL_MOUSEMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The current button state"]
    pub state: Uint32,
    #[doc = "< X coordinate, relative to window"]
    pub x: Sint32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: Sint32,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint32,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseMotionEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseMotionEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).which as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).xrel as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).yrel as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Mouse button event structure (event.button.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    #[doc = "< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The mouse button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< 1 for single-click, 2 for double-click, etc."]
    pub clicks: Uint8,
    pub padding1: Uint8,
    #[doc = "< X coordinate, relative to window"]
    pub x: Sint32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseButtonEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).which as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).button as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).state as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).clicks as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(clicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).padding1 as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief Mouse wheel event structure (event.wheel.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseWheelEvent {
    #[doc = "< ::SDL_MOUSEWHEEL"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
    pub x: Sint32,
    #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
    pub y: Sint32,
    #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
    pub direction: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseWheelEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseWheelEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).which as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).y as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseWheelEvent>())).direction as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(direction)
        )
    );
}
#[doc = "  \\brief Joystick axis motion event structure (event.jaxis.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    #[doc = "< ::SDL_JOYAXISMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick axis index"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).axis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).padding4 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Joystick trackball motion event structure (event.jball.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyBallEvent {
    #[doc = "< ::SDL_JOYBALLMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick trackball index"]
    pub ball: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint16,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyBallEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyBallEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).ball as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(ball)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).xrel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).yrel as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Joystick hat position change event structure (event.jhat.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyHatEvent {
    #[doc = "< ::SDL_JOYHATMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick hat index"]
    pub hat: Uint8,
    #[doc = "< The hat position value."]
    #[doc = "   \\sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP"]
    #[doc = "   \\sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT"]
    #[doc = "   \\sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN"]
    #[doc = ""]
    #[doc = "   Note that zero means the POV is centered."]
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyHatEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyHatEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).hat as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).value as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).padding1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).padding2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick button event structure (event.jbutton.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    #[doc = "< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).button as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).state as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).padding1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).padding2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick device event structure (event.jdevice.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyDeviceEvent {
    #[doc = "< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED event"]
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyDeviceEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyDeviceEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyDeviceEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Game controller axis motion event structure (event.caxis.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ControllerAxisEvent {
    #[doc = "< ::SDL_CONTROLLERAXISMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The controller axis (SDL_GameControllerAxis)"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ControllerAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ControllerAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).axis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).padding1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).padding2 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).padding3 as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerAxisEvent>())).padding4 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Game controller button event structure (event.cbutton.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ControllerButtonEvent {
    #[doc = "< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The controller button (SDL_GameControllerButton)"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ControllerButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ControllerButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).button as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).state as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).padding1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerButtonEvent>())).padding2 as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Controller device event structure (event.cdevice.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ControllerDeviceEvent {
    #[doc = "< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event"]
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ControllerDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ControllerDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerDeviceEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_ControllerDeviceEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ControllerDeviceEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Audio device event structure (event.adevice.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioDeviceEvent {
    #[doc = "< ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event"]
    pub which: Uint32,
    #[doc = "< zero if an output device, non-zero if a capture device."]
    pub iscapture: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioDeviceEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).iscapture as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(iscapture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioDeviceEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding3)
        )
    );
}
#[doc = "  \\brief Touch finger event structure (event.tfinger.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TouchFingerEvent {
    #[doc = "< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub fingerId: SDL_FingerID,
    #[doc = "< Normalized in the range 0...1"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub y: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dx: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dy: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
    #[doc = "< The window underneath the finger, if any"]
    pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_TouchFingerEvent>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_TouchFingerEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).touchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).fingerId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(fingerId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).y as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).dx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).dy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).pressure as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_TouchFingerEvent>())).windowID as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(windowID)
        )
    );
}
#[doc = "  \\brief Multiple Finger Gesture Event (event.mgesture.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MultiGestureEvent {
    #[doc = "< ::SDL_MULTIGESTURE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub dTheta: f32,
    pub dDist: f32,
    pub x: f32,
    pub y: f32,
    pub numFingers: Uint16,
    pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MultiGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MultiGestureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).touchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).dTheta as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(dTheta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).dDist as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(dDist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).y as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).numFingers as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(numFingers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MultiGestureEvent>())).padding as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " \\brief Dollar Gesture Event (event.dgesture.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DollarGestureEvent {
    #[doc = "< ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub gestureId: SDL_GestureID,
    pub numFingers: Uint32,
    pub error: f32,
    #[doc = "< Normalized center of gesture"]
    pub x: f32,
    #[doc = "< Normalized center of gesture"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DollarGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DollarGestureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).touchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).gestureId as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(gestureId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).numFingers as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(numFingers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).error as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).x as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DollarGestureEvent>())).y as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief An event used to request a file open by the system (event.drop.*)"]
#[doc = "         This event is enabled by default, you can disable it with SDL_EventState()."]
#[doc = "  \\note If this event is enabled, you must free the filename in the event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DropEvent {
    #[doc = "< ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The file name, which should be freed with SDL_free(), is NULL on begin/complete"]
    pub file: *mut ::std::os::raw::c_char,
    #[doc = "< The window that was dropped on, if any"]
    pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DropEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DropEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DropEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DropEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DropEvent>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_DropEvent>())).windowID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(windowID)
        )
    );
}
#[doc = "  \\brief Sensor event structure (event.sensor.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SensorEvent {
    #[doc = "< ::SDL_SENSORUPDATE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The instance ID of the sensor"]
    pub which: Sint32,
    #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData()"]
    pub data: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SensorEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SensorEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SensorEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SensorEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SensorEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SensorEvent>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "  \\brief The \"quit requested\" event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_QuitEvent {
    #[doc = "< ::SDL_QUIT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_QuitEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_QuitEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_QuitEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_QuitEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief OS Specific event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_OSEvent {
    #[doc = "< ::SDL_QUIT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_OSEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_OSEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_OSEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_OSEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief A user-defined event type (event.user.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_UserEvent {
    #[doc = "< ::SDL_USEREVENT through ::SDL_LASTEVENT-1"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated window if any"]
    pub windowID: Uint32,
    #[doc = "< User defined event code"]
    pub code: Sint32,
    #[doc = "< User defined data pointer"]
    pub data1: *mut ::std::os::raw::c_void,
    #[doc = "< User defined data pointer"]
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_UserEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_UserEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).code as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).data1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).data2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMmsg {
    _unused: [u8; 0],
}
#[doc = "  \\brief A video driver dependent system event (event.syswm.*)"]
#[doc = "         This event is disabled by default, you can enable it with SDL_EventState()"]
#[doc = ""]
#[doc = "  \\note If you want to use this event, you should include SDL_syswm.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMEvent {
    #[doc = "< ::SDL_SYSWMEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< driver dependent data, defined in SDL_syswm.h"]
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SysWMEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SysWMEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SysWMEvent>())).msg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = "  \\brief General event structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    #[doc = "< Event type, shared with all events"]
    pub type_: Uint32,
    #[doc = "< Common event data"]
    pub common: SDL_CommonEvent,
    #[doc = "< Display event data"]
    pub display: SDL_DisplayEvent,
    #[doc = "< Window event data"]
    pub window: SDL_WindowEvent,
    #[doc = "< Keyboard event data"]
    pub key: SDL_KeyboardEvent,
    #[doc = "< Text editing event data"]
    pub edit: SDL_TextEditingEvent,
    #[doc = "< Text input event data"]
    pub text: SDL_TextInputEvent,
    #[doc = "< Mouse motion event data"]
    pub motion: SDL_MouseMotionEvent,
    #[doc = "< Mouse button event data"]
    pub button: SDL_MouseButtonEvent,
    #[doc = "< Mouse wheel event data"]
    pub wheel: SDL_MouseWheelEvent,
    #[doc = "< Joystick axis event data"]
    pub jaxis: SDL_JoyAxisEvent,
    #[doc = "< Joystick ball event data"]
    pub jball: SDL_JoyBallEvent,
    #[doc = "< Joystick hat event data"]
    pub jhat: SDL_JoyHatEvent,
    #[doc = "< Joystick button event data"]
    pub jbutton: SDL_JoyButtonEvent,
    #[doc = "< Joystick device change event data"]
    pub jdevice: SDL_JoyDeviceEvent,
    #[doc = "< Game Controller axis event data"]
    pub caxis: SDL_ControllerAxisEvent,
    #[doc = "< Game Controller button event data"]
    pub cbutton: SDL_ControllerButtonEvent,
    #[doc = "< Game Controller device event data"]
    pub cdevice: SDL_ControllerDeviceEvent,
    #[doc = "< Audio device event data"]
    pub adevice: SDL_AudioDeviceEvent,
    #[doc = "< Sensor event data"]
    pub sensor: SDL_SensorEvent,
    #[doc = "< Quit request event data"]
    pub quit: SDL_QuitEvent,
    #[doc = "< Custom event data"]
    pub user: SDL_UserEvent,
    #[doc = "< System dependent window event data"]
    pub syswm: SDL_SysWMEvent,
    #[doc = "< Touch finger event data"]
    pub tfinger: SDL_TouchFingerEvent,
    #[doc = "< Gesture event data"]
    pub mgesture: SDL_MultiGestureEvent,
    #[doc = "< Gesture event data"]
    pub dgesture: SDL_DollarGestureEvent,
    #[doc = "< Drag and drop event data"]
    pub drop: SDL_DropEvent,
    pub padding: [Uint8; 56usize],
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Event>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(common)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).window as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).edit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(edit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).button as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).wheel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(wheel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jaxis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jaxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jball as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jball)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jhat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jhat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jdevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jdevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).caxis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(caxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).cbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(cbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).cdevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(cdevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).adevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(adevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).sensor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).quit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).syswm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(syswm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).tfinger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(tfinger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).mgesture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(mgesture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).dgesture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(dgesture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).drop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(padding)
        )
    );
}
pub type SDL_compile_time_assert_SDL_Event = [::std::os::raw::c_int; 1usize];
extern "C" {
    #[doc = "  Pumps the event loop, gathering events from the input devices."]
    #[doc = ""]
    #[doc = "  This function updates the event queue and internal input device state."]
    #[doc = ""]
    #[doc = "  This should only be run in the thread that sets the video mode."]
    pub fn SDL_PumpEvents();
}
pub const SDL_eventaction_SDL_ADDEVENT: SDL_eventaction = 0;
pub const SDL_eventaction_SDL_PEEKEVENT: SDL_eventaction = 1;
pub const SDL_eventaction_SDL_GETEVENT: SDL_eventaction = 2;
pub type SDL_eventaction = u32;
extern "C" {
    #[doc = "  Checks the event queue for messages and optionally returns them."]
    #[doc = ""]
    #[doc = "  If \\c action is ::SDL_ADDEVENT, up to \\c numevents events will be added to"]
    #[doc = "  the back of the event queue."]
    #[doc = ""]
    #[doc = "  If \\c action is ::SDL_PEEKEVENT, up to \\c numevents events at the front"]
    #[doc = "  of the event queue, within the specified minimum and maximum type,"]
    #[doc = "  will be returned and will not be removed from the queue."]
    #[doc = ""]
    #[doc = "  If \\c action is ::SDL_GETEVENT, up to \\c numevents events at the front"]
    #[doc = "  of the event queue, within the specified minimum and maximum type,"]
    #[doc = "  will be returned and will be removed from the queue."]
    #[doc = ""]
    #[doc = "  \\return The number of events actually stored, or -1 if there was an error."]
    #[doc = ""]
    #[doc = "  This function is thread-safe."]
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: ::std::os::raw::c_int,
        action: SDL_eventaction,
        minType: Uint32,
        maxType: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Checks to see if certain event types are in the event queue."]
    pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = "  This function clears events from the event queue"]
    #[doc = "  This function only affects currently queued events. If you want to make"]
    #[doc = "  sure that all pending OS events are flushed, you can call SDL_PumpEvents()"]
    #[doc = "  on the main thread immediately before the flush call."]
    pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
    #[doc = "  \\brief Polls for currently pending events."]
    #[doc = ""]
    #[doc = "  \\return 1 if there are any pending events, or 0 if there are none available."]
    #[doc = ""]
    #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
    #[doc = "               stored in that area."]
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Waits indefinitely for the next available event."]
    #[doc = ""]
    #[doc = "  \\return 1, or 0 if there was an error while waiting for events."]
    #[doc = ""]
    #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
    #[doc = "               stored in that area."]
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Waits until the specified timeout (in milliseconds) for the next"]
    #[doc = "         available event."]
    #[doc = ""]
    #[doc = "  \\return 1, or 0 if there was an error while waiting for events."]
    #[doc = ""]
    #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
    #[doc = "               stored in that area."]
    #[doc = "  \\param timeout The timeout (in milliseconds) to wait for next event."]
    pub fn SDL_WaitEventTimeout(
        event: *mut SDL_Event,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Add an event to the event queue."]
    #[doc = ""]
    #[doc = "  \\return 1 on success, 0 if the event was filtered, or -1 if the event queue"]
    #[doc = "          was full or there was some other error."]
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
pub type SDL_EventFilter = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        event: *mut SDL_Event,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "  Sets up a filter to process all events before they change internal state and"]
    #[doc = "  are posted to the internal event queue."]
    #[doc = ""]
    #[doc = "  The filter is prototyped as:"]
    #[doc = "  \\code"]
    #[doc = "      int SDL_EventFilter(void *userdata, SDL_Event * event);"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = "  If the filter returns 1, then the event will be added to the internal queue."]
    #[doc = "  If it returns 0, then the event will be dropped from the queue, but the"]
    #[doc = "  internal state will still be updated.  This allows selective filtering of"]
    #[doc = "  dynamically arriving events."]
    #[doc = ""]
    #[doc = "  \\warning  Be very careful of what you do in the event filter function, as"]
    #[doc = "            it may run in a different thread!"]
    #[doc = ""]
    #[doc = "  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The"]
    #[doc = "  event filter is only called when the window manager desires to close the"]
    #[doc = "  application window.  If the event filter returns 1, then the window will"]
    #[doc = "  be closed, otherwise the window will remain open if possible."]
    #[doc = ""]
    #[doc = "  If the quit event is generated by an interrupt signal, it will bypass the"]
    #[doc = "  internal queue and be delivered to the application at the next event poll."]
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Return the current event filter - can be used to \"chain\" filters."]
    #[doc = "  If there is no event filter set, this function returns SDL_FALSE."]
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut ::std::os::raw::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  Add a function which is called when an event is added to the queue."]
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Remove an event watch function added with SDL_AddEventWatch()"]
    pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Run the filter function on the current event queue, removing any"]
    #[doc = "  events for which the filter returns 0."]
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  This function allows you to set the state of processing certain events."]
    #[doc = "   - If \\c state is set to ::SDL_IGNORE, that event will be automatically"]
    #[doc = "     dropped from the event queue and will not be filtered."]
    #[doc = "   - If \\c state is set to ::SDL_ENABLE, that event will be processed"]
    #[doc = "     normally."]
    #[doc = "   - If \\c state is set to ::SDL_QUERY, SDL_EventState() will return the"]
    #[doc = "     current processing state of the specified event."]
    pub fn SDL_EventState(type_: Uint32, state: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    #[doc = "  This function allocates a set of user-defined events, and returns"]
    #[doc = "  the beginning event number for that set of events."]
    #[doc = ""]
    #[doc = "  If there aren't enough user-defined events left, this function"]
    #[doc = "  returns (Uint32)-1"]
    pub fn SDL_RegisterEvents(numevents: ::std::os::raw::c_int) -> Uint32;
}
extern "C" {
    #[doc = " \\brief Get the path where the application resides."]
    #[doc = ""]
    #[doc = " Get the \"base path\". This is the directory where the application was run"]
    #[doc = "  from, which is probably the installation directory, and may or may not"]
    #[doc = "  be the process's current working directory."]
    #[doc = ""]
    #[doc = " This returns an absolute path in UTF-8 encoding, and is guaranteed to"]
    #[doc = "  end with a path separator ('\\\\' on Windows, '/' most other places)."]
    #[doc = ""]
    #[doc = " The pointer returned by this function is owned by you. Please call"]
    #[doc = "  SDL_free() on the pointer when you are done with it, or it will be a"]
    #[doc = "  memory leak. This is not necessarily a fast call, though, so you should"]
    #[doc = "  call this once near startup and save the string if you need it."]
    #[doc = ""]
    #[doc = " Some platforms can't determine the application's path, and on other"]
    #[doc = "  platforms, this might be meaningless. In such cases, this function will"]
    #[doc = "  return NULL."]
    #[doc = ""]
    #[doc = "  \\return String of base dir in UTF-8 encoding, or NULL on error."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetPrefPath"]
    pub fn SDL_GetBasePath() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get the user-and-app-specific path where files can be written."]
    #[doc = ""]
    #[doc = " Get the \"pref dir\". This is meant to be where users can write personal"]
    #[doc = "  files (preferences and save games, etc) that are specific to your"]
    #[doc = "  application. This directory is unique per user, per application."]
    #[doc = ""]
    #[doc = " This function will decide the appropriate location in the native filesystem,"]
    #[doc = "  create the directory if necessary, and return a string of the absolute"]
    #[doc = "  path to the directory in UTF-8 encoding."]
    #[doc = ""]
    #[doc = " On Windows, the string might look like:"]
    #[doc = "  \"C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\\""]
    #[doc = ""]
    #[doc = " On Linux, the string might look like:"]
    #[doc = "  \"/home/bob/.local/share/My Program Name/\""]
    #[doc = ""]
    #[doc = " On Mac OS X, the string might look like:"]
    #[doc = "  \"/Users/bob/Library/Application Support/My Program Name/\""]
    #[doc = ""]
    #[doc = " (etc.)"]
    #[doc = ""]
    #[doc = " You specify the name of your organization (if it's not a real organization,"]
    #[doc = "  your name or an Internet domain you own might do) and the name of your"]
    #[doc = "  application. These should be untranslated proper names."]
    #[doc = ""]
    #[doc = " Both the org and app strings may become part of a directory name, so"]
    #[doc = "  please follow these rules:"]
    #[doc = ""]
    #[doc = "    - Try to use the same org string (including case-sensitivity) for"]
    #[doc = "      all your applications that use this function."]
    #[doc = "    - Always use a unique app string for each one, and make sure it never"]
    #[doc = "      changes for an app once you've decided on it."]
    #[doc = "    - Unicode characters are legal, as long as it's UTF-8 encoded, but..."]
    #[doc = "    - ...only use letters, numbers, and spaces. Avoid punctuation like"]
    #[doc = "      \"Game Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient."]
    #[doc = ""]
    #[doc = " This returns an absolute path in UTF-8 encoding, and is guaranteed to"]
    #[doc = "  end with a path separator ('\\\\' on Windows, '/' most other places)."]
    #[doc = ""]
    #[doc = " The pointer returned by this function is owned by you. Please call"]
    #[doc = "  SDL_free() on the pointer when you are done with it, or it will be a"]
    #[doc = "  memory leak. This is not necessarily a fast call, though, so you should"]
    #[doc = "  call this once near startup and save the string if you need it."]
    #[doc = ""]
    #[doc = " You should assume the path returned by this function is the only safe"]
    #[doc = "  place to write files (and that SDL_GetBasePath(), while it might be"]
    #[doc = "  writable, or even the parent of the returned path, aren't where you"]
    #[doc = "  should be writing things)."]
    #[doc = ""]
    #[doc = " Some platforms can't determine the pref path, and on other"]
    #[doc = "  platforms, this might be meaningless. In such cases, this function will"]
    #[doc = "  return NULL."]
    #[doc = ""]
    #[doc = "   \\param org The name of your organization."]
    #[doc = "   \\param app The name of your application."]
    #[doc = "  \\return UTF-8 string of user dir in platform-dependent notation. NULL"]
    #[doc = "          if there's a problem (creating directory failed, etc)."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetBasePath"]
    pub fn SDL_GetPrefPath(
        org: *const ::std::os::raw::c_char,
        app: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = "  \\typedef SDL_Haptic"]
#[doc = ""]
#[doc = "  \\brief The haptic structure used to identify an SDL haptic."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticOpen"]
#[doc = "  \\sa SDL_HapticOpenFromJoystick"]
#[doc = "  \\sa SDL_HapticClose"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Haptic {
    _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
#[doc = "  \\brief Structure that represents a haptic direction."]
#[doc = ""]
#[doc = "  This is the direction where the force comes from,"]
#[doc = "  instead of the direction in which the force is exerted."]
#[doc = ""]
#[doc = "  Directions can be specified by:"]
#[doc = "   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates."]
#[doc = "   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates."]
#[doc = "   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates."]
#[doc = ""]
#[doc = "  Cardinal directions of the haptic device are relative to the positioning"]
#[doc = "  of the device.  North is considered to be away from the user."]
#[doc = ""]
#[doc = "  The following diagram represents the cardinal directions:"]
#[doc = "  \\verbatim"]
#[doc = ".--."]
#[doc = "|__| .-------."]
#[doc = "|=.| |.-----.|"]
#[doc = "|--| ||     ||"]
#[doc = "|  | |'-----'|"]
#[doc = "|__|~')_____('"]
#[doc = "[ COMPUTER ]"]
#[doc = ""]
#[doc = ""]
#[doc = "North (0,-1)"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|"]
#[doc = "(-1,0)  West <----[ HAPTIC ]----> East (1,0)"]
#[doc = "|"]
#[doc = "|"]
#[doc = "v"]
#[doc = "South (0,1)"]
#[doc = ""]
#[doc = ""]
#[doc = "[ USER ]"]
#[doc = "\\|||/"]
#[doc = "(o o)"]
#[doc = "---ooO-(_)-Ooo---"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a"]
#[doc = "  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses"]
#[doc = "  the first \\c dir parameter.  The cardinal directions would be:"]
#[doc = "   - North: 0 (0 degrees)"]
#[doc = "   - East: 9000 (90 degrees)"]
#[doc = "   - South: 18000 (180 degrees)"]
#[doc = "   - West: 27000 (270 degrees)"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions"]
#[doc = "  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses"]
#[doc = "  the first three \\c dir parameters.  The cardinal directions would be:"]
#[doc = "   - North:  0,-1, 0"]
#[doc = "   - East:   1, 0, 0"]
#[doc = "   - South:  0, 1, 0"]
#[doc = "   - West:  -1, 0, 0"]
#[doc = ""]
#[doc = "  The Z axis represents the height of the effect if supported, otherwise"]
#[doc = "  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you"]
#[doc = "  can use any multiple you want, only the direction matters."]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations."]
#[doc = "  The first two \\c dir parameters are used.  The \\c dir parameters are as"]
#[doc = "  follows (all values are in hundredths of degrees):"]
#[doc = "   - Degrees from (1, 0) rotated towards (0, 1)."]
#[doc = "   - Degrees towards (0, 0, 1) (device needs at least 3 axes)."]
#[doc = ""]
#[doc = ""]
#[doc = "  Example of force coming from the south with all encodings (force coming"]
#[doc = "  from the south means the user will have to pull the stick to counteract):"]
#[doc = "  \\code"]
#[doc = "  SDL_HapticDirection direction;"]
#[doc = ""]
#[doc = "  // Cartesian directions"]
#[doc = "  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding."]
#[doc = "  direction.dir[0] = 0; // X position"]
#[doc = "  direction.dir[1] = 1; // Y position"]
#[doc = "  // Assuming the device has 2 axes, we don't need to specify third parameter."]
#[doc = ""]
#[doc = "  // Polar directions"]
#[doc = "  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding."]
#[doc = "  direction.dir[0] = 18000; // Polar only uses first parameter"]
#[doc = ""]
#[doc = "  // Spherical coordinates"]
#[doc = "  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding"]
#[doc = "  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_POLAR"]
#[doc = "  \\sa SDL_HAPTIC_CARTESIAN"]
#[doc = "  \\sa SDL_HAPTIC_SPHERICAL"]
#[doc = "  \\sa SDL_HapticEffect"]
#[doc = "  \\sa SDL_HapticNumAxes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticDirection {
    #[doc = "< The type of encoding."]
    pub type_: Uint8,
    #[doc = "< The encoded direction."]
    pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticDirection>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticDirection>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticDirection>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticDirection>())).dir as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(dir)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Constant effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect."]
#[doc = ""]
#[doc = "  A constant effect applies a constant force in the specified direction"]
#[doc = "  to the joystick."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CONSTANT"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticConstant {
    #[doc = "< ::SDL_HAPTIC_CONSTANT"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Strength of the constant effect."]
    pub level: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticConstant>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticConstant>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).level as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_HapticConstant>())).attack_length as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).attack_level as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).fade_length as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticConstant>())).fade_level as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Periodic effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SINE"]
#[doc = "   - ::SDL_HAPTIC_LEFTRIGHT"]
#[doc = "   - ::SDL_HAPTIC_TRIANGLE"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = ""]
#[doc = "  A periodic effect consists in a wave-shaped effect that repeats itself"]
#[doc = "  over time.  The type determines the shape of the wave and the parameters"]
#[doc = "  determine the dimensions of the wave."]
#[doc = ""]
#[doc = "  Phase is given by hundredth of a degree meaning that giving the phase a value"]
#[doc = "  of 9000 will displace it 25% of its period.  Here are sample values:"]
#[doc = "   -     0: No phase displacement."]
#[doc = "   -  9000: Displaced 25% of its period."]
#[doc = "   - 18000: Displaced 50% of its period."]
#[doc = "   - 27000: Displaced 75% of its period."]
#[doc = "   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred."]
#[doc = ""]
#[doc = "  Examples:"]
#[doc = "  \\verbatim"]
#[doc = "SDL_HAPTIC_SINE"]
#[doc = "__      __      __      __"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SQUARE"]
#[doc = "__    __    __    __    __"]
#[doc = "|  |  |  |  |  |  |  |  |  |"]
#[doc = "|  |__|  |__|  |__|  |__|  |"]
#[doc = ""]
#[doc = "SDL_HAPTIC_TRIANGLE"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHUP"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "\\  |\\  |\\  |\\  |\\  |\\  |\\  |"]
#[doc = "\\ | \\ | \\ | \\ | \\ | \\ | \\ |"]
#[doc = "\\|  \\|  \\|  \\|  \\|  \\|  \\|"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_SINE"]
#[doc = "  \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = "  \\sa SDL_HAPTIC_TRIANGLE"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticPeriodic {
    #[doc = "< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,"]
    #[doc = "::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or"]
    #[doc = "::SDL_HAPTIC_SAWTOOTHDOWN"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Period of the wave."]
    pub period: Uint16,
    #[doc = "< Peak value; if negative, equivalent to 180 degrees extra phase shift."]
    pub magnitude: Sint16,
    #[doc = "< Mean value of the wave."]
    pub offset: Sint16,
    #[doc = "< Positive phase shift given by hundredth of a degree."]
    pub phase: Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticPeriodic>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticPeriodic>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).period as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).magnitude as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(magnitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).offset as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).phase as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_HapticPeriodic>())).attack_length as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).attack_level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).fade_length as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticPeriodic>())).fade_level as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Condition effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SPRING: Effect based on axes position."]
#[doc = "   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity."]
#[doc = "   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration."]
#[doc = "   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement."]
#[doc = ""]
#[doc = "  Direction is handled by condition internals instead of a direction member."]
#[doc = "  The condition effect specific members have three parameters.  The first"]
#[doc = "  refers to the X axis, the second refers to the Y axis and the third"]
#[doc = "  refers to the Z axis.  The right terms refer to the positive side of the"]
#[doc = "  axis and the left terms refer to the negative side of the axis.  Please"]
#[doc = "  refer to the ::SDL_HapticDirection diagram for which side is positive and"]
#[doc = "  which is negative."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticDirection"]
#[doc = "  \\sa SDL_HAPTIC_SPRING"]
#[doc = "  \\sa SDL_HAPTIC_DAMPER"]
#[doc = "  \\sa SDL_HAPTIC_INERTIA"]
#[doc = "  \\sa SDL_HAPTIC_FRICTION"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticCondition {
    #[doc = "< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,"]
    #[doc = "::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect - Not used ATM."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Level when joystick is to the positive side; max 0xFFFF."]
    pub right_sat: [Uint16; 3usize],
    #[doc = "< Level when joystick is to the negative side; max 0xFFFF."]
    pub left_sat: [Uint16; 3usize],
    #[doc = "< How fast to increase the force towards the positive side."]
    pub right_coeff: [Sint16; 3usize],
    #[doc = "< How fast to increase the force towards the negative side."]
    pub left_coeff: [Sint16; 3usize],
    #[doc = "< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered."]
    pub deadband: [Uint16; 3usize],
    #[doc = "< Position of the dead zone."]
    pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticCondition>(),
        68usize,
        concat!("Size of: ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).right_sat as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_sat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).left_sat as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_sat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).right_coeff as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).left_coeff as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).deadband as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(deadband)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCondition>())).center as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(center)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Ramp effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect."]
#[doc = ""]
#[doc = "  The ramp effect starts at start strength and ends at end strength."]
#[doc = "  It augments in linear fashion.  If you use attack and fade with a ramp"]
#[doc = "  the effects get added to the ramp effect making the effect become"]
#[doc = "  quadratic instead of linear."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_RAMP"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticRamp {
    #[doc = "< ::SDL_HAPTIC_RAMP"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Beginning strength level."]
    pub start: Sint16,
    #[doc = "< Ending strength level."]
    pub end: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticRamp>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticRamp>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).start as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).attack_length as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).attack_level as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).fade_length as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticRamp>())).fade_level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = " \\brief A structure containing a template for a Left/Right effect."]
#[doc = ""]
#[doc = " This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect."]
#[doc = ""]
#[doc = " The Left/Right effect is used to explicitly control the large and small"]
#[doc = " motors, commonly found in modern game controllers. The small (right) motor"]
#[doc = " is high frequency, and the large (left) motor is low frequency."]
#[doc = ""]
#[doc = " \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = " \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticLeftRight {
    #[doc = "< ::SDL_HAPTIC_LEFTRIGHT"]
    pub type_: Uint16,
    #[doc = "< Duration of the effect in milliseconds."]
    pub length: Uint32,
    #[doc = "< Control of the large controller motor."]
    pub large_magnitude: Uint16,
    #[doc = "< Control of the small controller motor."]
    pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticLeftRight>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticLeftRight>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticLeftRight>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticLeftRight>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_HapticLeftRight>())).large_magnitude as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(large_magnitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_HapticLeftRight>())).small_magnitude as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(small_magnitude)
        )
    );
}
#[doc = "  \\brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  A custom force feedback effect is much like a periodic effect, where the"]
#[doc = "  application can define its exact shape.  You will have to allocate the"]
#[doc = "  data yourself.  Data should consist of channels * samples Uint16 samples."]
#[doc = ""]
#[doc = "  If channels is one, the effect is rotated using the defined direction."]
#[doc = "  Otherwise it uses the samples in data for the different axes."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CUSTOM"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticCustom {
    #[doc = "< ::SDL_HAPTIC_CUSTOM"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Axes to use, minimum of one."]
    pub channels: Uint8,
    #[doc = "< Sample periods."]
    pub period: Uint16,
    #[doc = "< Amount of samples."]
    pub samples: Uint16,
    #[doc = "< Should contain channels*samples items."]
    pub data: *mut Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticCustom>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).channels as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).period as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).samples as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).attack_length as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).attack_level as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).fade_length as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticCustom>())).fade_level as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief The generic template for any haptic effect."]
#[doc = ""]
#[doc = "  All values max at 32767 (0x7FFF).  Signed values also can be negative."]
#[doc = "  Time values unless specified otherwise are in milliseconds."]
#[doc = ""]
#[doc = "  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767"]
#[doc = "  value.  Neither delay, interval, attack_length nor fade_length support"]
#[doc = "  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends."]
#[doc = ""]
#[doc = "  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of"]
#[doc = "  ::SDL_HAPTIC_INFINITY."]
#[doc = ""]
#[doc = "  Button triggers may not be supported on all devices, it is advised to not"]
#[doc = "  use them if possible.  Buttons start at index 1 instead of index 0 like"]
#[doc = "  the joystick."]
#[doc = ""]
#[doc = "  If both attack_length and fade_level are 0, the envelope is not used,"]
#[doc = "  otherwise both values are used."]
#[doc = ""]
#[doc = "  Common parts:"]
#[doc = "  \\code"]
#[doc = "  // Replay - All effects have this"]
#[doc = "  Uint32 length;        // Duration of effect (ms)."]
#[doc = "  Uint16 delay;         // Delay before starting effect."]
#[doc = ""]
#[doc = "  // Trigger - All effects have this"]
#[doc = "  Uint16 button;        // Button that triggers effect."]
#[doc = "  Uint16 interval;      // How soon before effect can be triggered again."]
#[doc = ""]
#[doc = "  // Envelope - All effects except condition effects have this"]
#[doc = "  Uint16 attack_length; // Duration of the attack (ms)."]
#[doc = "  Uint16 attack_level;  // Level at the start of the attack."]
#[doc = "  Uint16 fade_length;   // Duration of the fade out (ms)."]
#[doc = "  Uint16 fade_level;    // Level at the end of the fade."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = ""]
#[doc = "  Here we have an example of a constant effect evolution in time:"]
#[doc = "  \\verbatim"]
#[doc = "Strength"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|    effect level -->  _________________"]
#[doc = "|                     /                 \\"]
#[doc = "|                    /                   \\"]
#[doc = "|                   /                     \\"]
#[doc = "|                  /                       \\"]
#[doc = "| attack_level --> |                        \\"]
#[doc = "|                  |                        |  <---  fade_level"]
#[doc = "|"]
#[doc = "+--------------------------------------------------> Time"]
#[doc = "[--]                 [---]"]
#[doc = "attack_length        fade_length"]
#[doc = ""]
#[doc = "[------------------][-----------------------]"]
#[doc = "delay               length"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  Note either the attack_level or the fade_level may be above the actual"]
#[doc = "  effect level."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticConstant"]
#[doc = "  \\sa SDL_HapticPeriodic"]
#[doc = "  \\sa SDL_HapticCondition"]
#[doc = "  \\sa SDL_HapticRamp"]
#[doc = "  \\sa SDL_HapticLeftRight"]
#[doc = "  \\sa SDL_HapticCustom"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
    #[doc = "< Effect type."]
    pub type_: Uint16,
    #[doc = "< Constant effect."]
    pub constant: SDL_HapticConstant,
    #[doc = "< Periodic effect."]
    pub periodic: SDL_HapticPeriodic,
    #[doc = "< Condition effect."]
    pub condition: SDL_HapticCondition,
    #[doc = "< Ramp effect."]
    pub ramp: SDL_HapticRamp,
    #[doc = "< Left/Right effect."]
    pub leftright: SDL_HapticLeftRight,
    #[doc = "< Custom effect."]
    pub custom: SDL_HapticCustom,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticEffect>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).constant as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).periodic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).condition as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).ramp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(ramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).leftright as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(leftright)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_HapticEffect>())).custom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(custom)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Count the number of haptic devices attached to the system."]
    #[doc = ""]
    #[doc = "  \\return Number of haptic devices detected on the system."]
    pub fn SDL_NumHaptics() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the implementation dependent name of a haptic device."]
    #[doc = ""]
    #[doc = "  This can be called before any joysticks are opened."]
    #[doc = "  If no name can be found, this function returns NULL."]
    #[doc = ""]
    #[doc = "  \\param device_index Index of the device to get its name."]
    #[doc = "  \\return Name of the device or NULL on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_NumHaptics"]
    pub fn SDL_HapticName(device_index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Opens a haptic device for use."]
    #[doc = ""]
    #[doc = "  The index passed as an argument refers to the N'th haptic device on this"]
    #[doc = "  system."]
    #[doc = ""]
    #[doc = "  When opening a haptic device, its gain will be set to maximum and"]
    #[doc = "  autocenter will be disabled.  To modify these values use"]
    #[doc = "  SDL_HapticSetGain() and SDL_HapticSetAutocenter()."]
    #[doc = ""]
    #[doc = "  \\param device_index Index of the device to open."]
    #[doc = "  \\return Device identifier or NULL on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticIndex"]
    #[doc = "  \\sa SDL_HapticOpenFromMouse"]
    #[doc = "  \\sa SDL_HapticOpenFromJoystick"]
    #[doc = "  \\sa SDL_HapticClose"]
    #[doc = "  \\sa SDL_HapticSetGain"]
    #[doc = "  \\sa SDL_HapticSetAutocenter"]
    #[doc = "  \\sa SDL_HapticPause"]
    #[doc = "  \\sa SDL_HapticStopAll"]
    pub fn SDL_HapticOpen(device_index: ::std::os::raw::c_int) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = "  \\brief Checks if the haptic device at index has been opened."]
    #[doc = ""]
    #[doc = "  \\param device_index Index to check to see if it has been opened."]
    #[doc = "  \\return 1 if it has been opened or 0 if it hasn't."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticOpen"]
    #[doc = "  \\sa SDL_HapticIndex"]
    pub fn SDL_HapticOpened(device_index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Gets the index of a haptic device."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to get the index of."]
    #[doc = "  \\return The index of the haptic device or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticOpen"]
    #[doc = "  \\sa SDL_HapticOpened"]
    pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Gets whether or not the current mouse has haptic capabilities."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticOpenFromMouse"]
    pub fn SDL_MouseIsHaptic() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Tries to open a haptic device from the current mouse."]
    #[doc = ""]
    #[doc = "  \\return The haptic device identifier or NULL on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_MouseIsHaptic"]
    #[doc = "  \\sa SDL_HapticOpen"]
    pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = "  \\brief Checks to see if a joystick has haptic features."]
    #[doc = ""]
    #[doc = "  \\param joystick Joystick to test for haptic capabilities."]
    #[doc = "  \\return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't"]
    #[doc = "          or -1 if an error occurred."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticOpenFromJoystick"]
    pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Opens a haptic device for use from a joystick device."]
    #[doc = ""]
    #[doc = "  You must still close the haptic device separately.  It will not be closed"]
    #[doc = "  with the joystick."]
    #[doc = ""]
    #[doc = "  When opening from a joystick you should first close the haptic device before"]
    #[doc = "  closing the joystick device.  If not, on some implementations the haptic"]
    #[doc = "  device will also get unallocated and you'll be unable to use force feedback"]
    #[doc = "  on that device."]
    #[doc = ""]
    #[doc = "  \\param joystick Joystick to create a haptic device from."]
    #[doc = "  \\return A valid haptic device identifier on success or NULL on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticOpen"]
    #[doc = "  \\sa SDL_HapticClose"]
    pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = "  \\brief Closes a haptic device previously opened with SDL_HapticOpen()."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to close."]
    pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
    #[doc = "  \\brief Returns the number of effects a haptic device can store."]
    #[doc = ""]
    #[doc = "  On some platforms this isn't fully supported, and therefore is an"]
    #[doc = "  approximation.  Always check to see if your created effect was actually"]
    #[doc = "  created and do not rely solely on SDL_HapticNumEffects()."]
    #[doc = ""]
    #[doc = "  \\param haptic The haptic device to query effect max."]
    #[doc = "  \\return The number of effects the haptic device can store or"]
    #[doc = "          -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticNumEffectsPlaying"]
    #[doc = "  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Returns the number of effects a haptic device can play at the same"]
    #[doc = "         time."]
    #[doc = ""]
    #[doc = "  This is not supported on all platforms, but will always return a value."]
    #[doc = "  Added here for the sake of completeness."]
    #[doc = ""]
    #[doc = "  \\param haptic The haptic device to query maximum playing effects."]
    #[doc = "  \\return The number of effects the haptic device can play at the same time"]
    #[doc = "          or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticNumEffects"]
    #[doc = "  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Gets the haptic device's supported features in bitwise manner."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = "  \\code"]
    #[doc = "  if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {"]
    #[doc = "      printf(\"We have constant haptic effect!\\n\");"]
    #[doc = "  }"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = "  \\param haptic The haptic device to query."]
    #[doc = "  \\return Haptic features in bitwise manner (OR'd)."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticNumEffects"]
    #[doc = "  \\sa SDL_HapticEffectSupported"]
    pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "  \\brief Gets the number of haptic axes the device has."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticDirection"]
    pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Checks to see if effect is supported by haptic."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to check on."]
    #[doc = "  \\param effect Effect to check to see if it is supported."]
    #[doc = "  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticQuery"]
    #[doc = "  \\sa SDL_HapticNewEffect"]
    pub fn SDL_HapticEffectSupported(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Creates a new haptic effect on the device."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to create the effect on."]
    #[doc = "  \\param effect Properties of the effect to create."]
    #[doc = "  \\return The identifier of the effect on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticUpdateEffect"]
    #[doc = "  \\sa SDL_HapticRunEffect"]
    #[doc = "  \\sa SDL_HapticDestroyEffect"]
    pub fn SDL_HapticNewEffect(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Updates the properties of an effect."]
    #[doc = ""]
    #[doc = "  Can be used dynamically, although behavior when dynamically changing"]
    #[doc = "  direction may be strange.  Specifically the effect may reupload itself"]
    #[doc = "  and start playing from the start.  You cannot change the type either when"]
    #[doc = "  running SDL_HapticUpdateEffect()."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device that has the effect."]
    #[doc = "  \\param effect Identifier of the effect to update."]
    #[doc = "  \\param data New effect properties to use."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticNewEffect"]
    #[doc = "  \\sa SDL_HapticRunEffect"]
    #[doc = "  \\sa SDL_HapticDestroyEffect"]
    pub fn SDL_HapticUpdateEffect(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
        data: *mut SDL_HapticEffect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Runs the haptic effect on its associated haptic device."]
    #[doc = ""]
    #[doc = "  If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over"]
    #[doc = "  repeating the envelope (attack and fade) every time.  If you only want the"]
    #[doc = "  effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length"]
    #[doc = "  parameter."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to run the effect on."]
    #[doc = "  \\param effect Identifier of the haptic effect to run."]
    #[doc = "  \\param iterations Number of iterations to run the effect. Use"]
    #[doc = "         ::SDL_HAPTIC_INFINITY for infinity."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticStopEffect"]
    #[doc = "  \\sa SDL_HapticDestroyEffect"]
    #[doc = "  \\sa SDL_HapticGetEffectStatus"]
    pub fn SDL_HapticRunEffect(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
        iterations: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Stops the haptic effect on its associated haptic device."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to stop the effect on."]
    #[doc = "  \\param effect Identifier of the effect to stop."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticRunEffect"]
    #[doc = "  \\sa SDL_HapticDestroyEffect"]
    pub fn SDL_HapticStopEffect(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Destroys a haptic effect on the device."]
    #[doc = ""]
    #[doc = "  This will stop the effect if it's running.  Effects are automatically"]
    #[doc = "  destroyed when the device is closed."]
    #[doc = ""]
    #[doc = "  \\param haptic Device to destroy the effect on."]
    #[doc = "  \\param effect Identifier of the effect to destroy."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticNewEffect"]
    pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "  \\brief Gets the status of the current effect on the haptic device."]
    #[doc = ""]
    #[doc = "  Device must support the ::SDL_HAPTIC_STATUS feature."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to query the effect status on."]
    #[doc = "  \\param effect Identifier of the effect to query its status."]
    #[doc = "  \\return 0 if it isn't playing, 1 if it is playing or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticRunEffect"]
    #[doc = "  \\sa SDL_HapticStopEffect"]
    pub fn SDL_HapticGetEffectStatus(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the global gain of the device."]
    #[doc = ""]
    #[doc = "  Device must support the ::SDL_HAPTIC_GAIN feature."]
    #[doc = ""]
    #[doc = "  The user may specify the maximum gain by setting the environment variable"]
    #[doc = "  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to"]
    #[doc = "  SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the"]
    #[doc = "  maximum."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to set the gain on."]
    #[doc = "  \\param gain Value to set the gain to, should be between 0 and 100."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetGain(
        haptic: *mut SDL_Haptic,
        gain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the global autocenter of the device."]
    #[doc = ""]
    #[doc = "  Autocenter should be between 0 and 100.  Setting it to 0 will disable"]
    #[doc = "  autocentering."]
    #[doc = ""]
    #[doc = "  Device must support the ::SDL_HAPTIC_AUTOCENTER feature."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to set autocentering on."]
    #[doc = "  \\param autocenter Value to set autocenter to, 0 disables autocentering."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetAutocenter(
        haptic: *mut SDL_Haptic,
        autocenter: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Pauses a haptic device."]
    #[doc = ""]
    #[doc = "  Device must support the ::SDL_HAPTIC_PAUSE feature.  Call"]
    #[doc = "  SDL_HapticUnpause() to resume playback."]
    #[doc = ""]
    #[doc = "  Do not modify the effects nor add new ones while the device is paused."]
    #[doc = "  That can cause all sorts of weird errors."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to pause."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticUnpause"]
    pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Unpauses a haptic device."]
    #[doc = ""]
    #[doc = "  Call to unpause after SDL_HapticPause()."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to unpause."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticPause"]
    pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Stops all the currently playing effects on a haptic device."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to stop."]
    #[doc = "  \\return 0 on success or -1 on error."]
    pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Checks to see if rumble is supported on a haptic device."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to check to see if it supports rumble."]
    #[doc = "  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticRumbleInit"]
    #[doc = "  \\sa SDL_HapticRumblePlay"]
    #[doc = "  \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Initializes the haptic device for simple rumble playback."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to initialize for simple rumble playback."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticOpen"]
    #[doc = "  \\sa SDL_HapticRumbleSupported"]
    #[doc = "  \\sa SDL_HapticRumblePlay"]
    #[doc = "  \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Runs simple rumble on a haptic device"]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic device to play rumble effect on."]
    #[doc = "  \\param strength Strength of the rumble to play as a 0-1 float value."]
    #[doc = "  \\param length Length of the rumble to play in milliseconds."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticRumbleSupported"]
    #[doc = "  \\sa SDL_HapticRumbleInit"]
    #[doc = "  \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumblePlay(
        haptic: *mut SDL_Haptic,
        strength: f32,
        length: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Stops the simple rumble on a haptic device."]
    #[doc = ""]
    #[doc = "  \\param haptic Haptic to stop the rumble on."]
    #[doc = "  \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_HapticRumbleSupported"]
    #[doc = "  \\sa SDL_HapticRumbleInit"]
    #[doc = "  \\sa SDL_HapticRumblePlay"]
    pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
pub const SDL_HintPriority_SDL_HINT_DEFAULT: SDL_HintPriority = 0;
pub const SDL_HintPriority_SDL_HINT_NORMAL: SDL_HintPriority = 1;
pub const SDL_HintPriority_SDL_HINT_OVERRIDE: SDL_HintPriority = 2;
#[doc = "  \\brief  An enumeration of hint priorities"]
pub type SDL_HintPriority = u32;
extern "C" {
    #[doc = "  \\brief Set a hint with a specific priority"]
    #[doc = ""]
    #[doc = "  The priority controls the behavior when setting a hint that already"]
    #[doc = "  has a value.  Hints will replace existing hints of their priority and"]
    #[doc = "  lower.  Environment variables are considered to have override priority."]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
    pub fn SDL_SetHintWithPriority(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        priority: SDL_HintPriority,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Set a hint with normal priority"]
    #[doc = ""]
    #[doc = "  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
    pub fn SDL_SetHint(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Get a hint"]
    #[doc = ""]
    #[doc = "  \\return The string value of a hint variable."]
    pub fn SDL_GetHint(name: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get a hint"]
    #[doc = ""]
    #[doc = "  \\return The boolean value of a hint variable."]
    pub fn SDL_GetHintBoolean(
        name: *const ::std::os::raw::c_char,
        default_value: SDL_bool,
    ) -> SDL_bool;
}
#[doc = " \\brief type definition of the hint callback function."]
pub type SDL_HintCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        oldValue: *const ::std::os::raw::c_char,
        newValue: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = "  \\brief Add a function to watch a particular hint"]
    #[doc = ""]
    #[doc = "  \\param name The hint to watch"]
    #[doc = "  \\param callback The function to call when the hint value changes"]
    #[doc = "  \\param userdata A pointer to pass to the callback function"]
    pub fn SDL_AddHintCallback(
        name: *const ::std::os::raw::c_char,
        callback: SDL_HintCallback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief Remove a function watching a particular hint"]
    #[doc = ""]
    #[doc = "  \\param name The hint being watched"]
    #[doc = "  \\param callback The function being called when the hint value changes"]
    #[doc = "  \\param userdata A pointer being passed to the callback function"]
    pub fn SDL_DelHintCallback(
        name: *const ::std::os::raw::c_char,
        callback: SDL_HintCallback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief  Clear all hints"]
    #[doc = ""]
    #[doc = "  This function is called during SDL_Quit() to free stored hints."]
    pub fn SDL_ClearHints();
}
extern "C" {
    #[doc = "  This function dynamically loads a shared object and returns a pointer"]
    #[doc = "  to the object handle (or NULL if there was an error)."]
    #[doc = "  The 'sofile' parameter is a system dependent name of the object file."]
    pub fn SDL_LoadObject(sofile: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Given an object handle, this function looks up the address of the"]
    #[doc = "  named function in the shared object and returns it.  This address"]
    #[doc = "  is no longer valid after calling SDL_UnloadObject()."]
    pub fn SDL_LoadFunction(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Unload a shared object from memory."]
    pub fn SDL_UnloadObject(handle: *mut ::std::os::raw::c_void);
}
pub const SDL_LogCategory_SDL_LOG_CATEGORY_APPLICATION: SDL_LogCategory = 0;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_ERROR: SDL_LogCategory = 1;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_ASSERT: SDL_LogCategory = 2;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_SYSTEM: SDL_LogCategory = 3;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_AUDIO: SDL_LogCategory = 4;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_VIDEO: SDL_LogCategory = 5;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RENDER: SDL_LogCategory = 6;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_INPUT: SDL_LogCategory = 7;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_TEST: SDL_LogCategory = 8;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED1: SDL_LogCategory = 9;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED2: SDL_LogCategory = 10;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED3: SDL_LogCategory = 11;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED4: SDL_LogCategory = 12;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED5: SDL_LogCategory = 13;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED6: SDL_LogCategory = 14;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED7: SDL_LogCategory = 15;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED8: SDL_LogCategory = 16;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED9: SDL_LogCategory = 17;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_RESERVED10: SDL_LogCategory = 18;
pub const SDL_LogCategory_SDL_LOG_CATEGORY_CUSTOM: SDL_LogCategory = 19;
#[doc = "  \\brief The predefined log categories"]
#[doc = ""]
#[doc = "  By default the application category is enabled at the INFO level,"]
#[doc = "  the assert category is enabled at the WARN level, test is enabled"]
#[doc = "  at the VERBOSE level and all other categories are enabled at the"]
#[doc = "  CRITICAL level."]
pub type SDL_LogCategory = u32;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_VERBOSE: SDL_LogPriority = 1;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_DEBUG: SDL_LogPriority = 2;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_INFO: SDL_LogPriority = 3;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_WARN: SDL_LogPriority = 4;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_ERROR: SDL_LogPriority = 5;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_CRITICAL: SDL_LogPriority = 6;
pub const SDL_LogPriority_SDL_NUM_LOG_PRIORITIES: SDL_LogPriority = 7;
#[doc = "  \\brief The predefined log priorities"]
pub type SDL_LogPriority = u32;
extern "C" {
    #[doc = "  \\brief Set the priority of all log categories"]
    pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority);
}
extern "C" {
    #[doc = "  \\brief Set the priority of a particular log category"]
    pub fn SDL_LogSetPriority(category: ::std::os::raw::c_int, priority: SDL_LogPriority);
}
extern "C" {
    #[doc = "  \\brief Get the priority of a particular log category"]
    pub fn SDL_LogGetPriority(category: ::std::os::raw::c_int) -> SDL_LogPriority;
}
extern "C" {
    #[doc = "  \\brief Reset all priorities to default."]
    #[doc = ""]
    #[doc = "  \\note This is called in SDL_Quit()."]
    pub fn SDL_LogResetPriorities();
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO"]
    pub fn SDL_Log(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_VERBOSE"]
    pub fn SDL_LogVerbose(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_DEBUG"]
    pub fn SDL_LogDebug(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_INFO"]
    pub fn SDL_LogInfo(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_WARN"]
    pub fn SDL_LogWarn(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_ERROR"]
    pub fn SDL_LogError(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_CRITICAL"]
    pub fn SDL_LogCritical(
        category: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = "  \\brief Log a message with the specified category and priority."]
    pub fn SDL_LogMessage(
        category: ::std::os::raw::c_int,
        priority: SDL_LogPriority,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = "  \\brief Log a message with the specified category and priority."]
    pub fn SDL_LogMessageV(
        category: ::std::os::raw::c_int,
        priority: SDL_LogPriority,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
#[doc = "  \\brief The prototype for the log output function"]
pub type SDL_LogOutputFunction = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        category: ::std::os::raw::c_int,
        priority: SDL_LogPriority,
        message: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = "  \\brief Get the current log output function."]
    pub fn SDL_LogGetOutputFunction(
        callback: *mut SDL_LogOutputFunction,
        userdata: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief This function allows you to replace the default log output"]
    #[doc = "         function with one of your own."]
    pub fn SDL_LogSetOutputFunction(
        callback: SDL_LogOutputFunction,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[doc = "< error dialog"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_ERROR: SDL_MessageBoxFlags = 16;
#[doc = "< warning dialog"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_WARNING: SDL_MessageBoxFlags = 32;
#[doc = "< informational dialog"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_INFORMATION: SDL_MessageBoxFlags = 64;
#[doc = "< buttons placed left to right"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT: SDL_MessageBoxFlags = 128;
#[doc = "< buttons placed right to left"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT: SDL_MessageBoxFlags = 256;
#[doc = " \\brief SDL_MessageBox flags. If supported will display warning icon, etc."]
pub type SDL_MessageBoxFlags = u32;
#[doc = "< Marks the default button when return is hit"]
pub const SDL_MessageBoxButtonFlags_SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT:
    SDL_MessageBoxButtonFlags = 1;
#[doc = "< Marks the default button when escape is hit"]
pub const SDL_MessageBoxButtonFlags_SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT:
    SDL_MessageBoxButtonFlags = 2;
#[doc = " \\brief Flags for SDL_MessageBoxButtonData."]
pub type SDL_MessageBoxButtonFlags = u32;
#[doc = "  \\brief Individual button data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxButtonData {
    #[doc = "< ::SDL_MessageBoxButtonFlags"]
    pub flags: Uint32,
    #[doc = "< User defined button id (value returned via SDL_ShowMessageBox)"]
    pub buttonid: ::std::os::raw::c_int,
    #[doc = "< The UTF-8 button text"]
    pub text: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxButtonData>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxButtonData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxButtonData>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_MessageBoxButtonData>())).buttonid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(buttonid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxButtonData>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " \\brief RGB value used in a message box color scheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxColor {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxColor>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxColor>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxColor>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxColor>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxColor>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(b)
        )
    );
}
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BACKGROUND: SDL_MessageBoxColorType = 0;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_TEXT: SDL_MessageBoxColorType = 1;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_BORDER: SDL_MessageBoxColorType = 2;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND: SDL_MessageBoxColorType =
    3;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED: SDL_MessageBoxColorType = 4;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_MAX: SDL_MessageBoxColorType = 5;
pub type SDL_MessageBoxColorType = u32;
#[doc = " \\brief A set of colors to use for message box dialogs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxColorScheme {
    pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxColorScheme>(),
        15usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxColorScheme>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_MessageBoxColorScheme>())).colors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColorScheme),
            "::",
            stringify!(colors)
        )
    );
}
#[doc = "  \\brief MessageBox structure containing title, text, window, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxData {
    #[doc = "< ::SDL_MessageBoxFlags"]
    pub flags: Uint32,
    #[doc = "< Parent window, can be NULL"]
    pub window: *mut SDL_Window,
    #[doc = "< UTF-8 title"]
    pub title: *const ::std::os::raw::c_char,
    #[doc = "< UTF-8 message text"]
    pub message: *const ::std::os::raw::c_char,
    pub numbuttons: ::std::os::raw::c_int,
    pub buttons: *const SDL_MessageBoxButtonData,
    #[doc = "< ::SDL_MessageBoxColorScheme, can be NULL to use system settings"]
    pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxData>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).title as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).message as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).numbuttons as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(numbuttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).buttons as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MessageBoxData>())).colorScheme as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(colorScheme)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Create a modal message box."]
    #[doc = ""]
    #[doc = "  \\param messageboxdata The SDL_MessageBoxData structure with title, text, etc."]
    #[doc = "  \\param buttonid The pointer to which user id of hit button should be copied."]
    #[doc = ""]
    #[doc = "  \\return -1 on error, otherwise 0 and buttonid contains user id of button"]
    #[doc = "          hit or -1 if dialog was closed."]
    #[doc = ""]
    #[doc = "  \\note This function should be called on the thread that created the parent"]
    #[doc = "        window, or on the main thread if the messagebox has no parent.  It will"]
    #[doc = "        block execution of that thread until the user clicks a button or"]
    #[doc = "        closes the messagebox."]
    pub fn SDL_ShowMessageBox(
        messageboxdata: *const SDL_MessageBoxData,
        buttonid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a simple modal message box"]
    #[doc = ""]
    #[doc = "  \\param flags    ::SDL_MessageBoxFlags"]
    #[doc = "  \\param title    UTF-8 title text"]
    #[doc = "  \\param message  UTF-8 message text"]
    #[doc = "  \\param window   The parent window, or NULL for no parent"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, -1 on error"]
    #[doc = ""]
    #[doc = "  \\sa SDL_ShowMessageBox"]
    pub fn SDL_ShowSimpleMessageBox(
        flags: Uint32,
        title: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        window: *mut SDL_Window,
    ) -> ::std::os::raw::c_int;
}
#[doc = "  \\brief A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS)."]
#[doc = ""]
#[doc = "  \\note This can be cast directly to an NSView or UIView."]
pub type SDL_MetalView = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = "  \\brief Create a CAMetalLayer-backed NSView/UIView and attach it to the"]
    #[doc = "        specified window."]
    #[doc = ""]
    #[doc = "  On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on its"]
    #[doc = "  own. It is up to user code to do that."]
    #[doc = ""]
    #[doc = "  The returned handle can be casted directly to a NSView or UIView, and the"]
    #[doc = "  CAMetalLayer can be accessed from the view's 'layer' property."]
    #[doc = ""]
    #[doc = "  \\code"]
    #[doc = "  SDL_MetalView metalview = SDL_Metal_CreateView(window);"]
    #[doc = "  UIView *uiview = (__bridge UIView *)metalview;"]
    #[doc = "  CAMetalLayer *metallayer = (CAMetalLayer *)uiview.layer;"]
    #[doc = "  // [...]"]
    #[doc = "  SDL_Metal_DestroyView(metalview);"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = "  \\sa SDL_Metal_DestroyView"]
    pub fn SDL_Metal_CreateView(window: *mut SDL_Window) -> SDL_MetalView;
}
extern "C" {
    #[doc = "  \\brief Destroy an existing SDL_MetalView object."]
    #[doc = ""]
    #[doc = "  This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was"]
    #[doc = "  called after SDL_CreateWindow."]
    #[doc = ""]
    #[doc = "  \\sa SDL_Metal_CreateView"]
    pub fn SDL_Metal_DestroyView(view: SDL_MetalView);
}
#[doc = "< cannot determine power status"]
pub const SDL_PowerState_SDL_POWERSTATE_UNKNOWN: SDL_PowerState = 0;
#[doc = "< Not plugged in, running on the battery"]
pub const SDL_PowerState_SDL_POWERSTATE_ON_BATTERY: SDL_PowerState = 1;
#[doc = "< Plugged in, no battery available"]
pub const SDL_PowerState_SDL_POWERSTATE_NO_BATTERY: SDL_PowerState = 2;
#[doc = "< Plugged in, charging battery"]
pub const SDL_PowerState_SDL_POWERSTATE_CHARGING: SDL_PowerState = 3;
#[doc = "< Plugged in, battery charged"]
pub const SDL_PowerState_SDL_POWERSTATE_CHARGED: SDL_PowerState = 4;
#[doc = "  \\brief The basic state for the system's power supply."]
pub type SDL_PowerState = u32;
extern "C" {
    #[doc = "  \\brief Get the current power supply details."]
    #[doc = ""]
    #[doc = "  \\param secs Seconds of battery life left. You can pass a NULL here if"]
    #[doc = "              you don't care. Will return -1 if we can't determine a"]
    #[doc = "              value, or we're not running on a battery."]
    #[doc = ""]
    #[doc = "  \\param pct Percentage of battery life left, between 0 and 100. You can"]
    #[doc = "             pass a NULL here if you don't care. Will return -1 if we"]
    #[doc = "             can't determine a value, or we're not running on a battery."]
    #[doc = ""]
    #[doc = "  \\return The state of the battery (if any)."]
    pub fn SDL_GetPowerInfo(
        secs: *mut ::std::os::raw::c_int,
        pct: *mut ::std::os::raw::c_int,
    ) -> SDL_PowerState;
}
#[doc = "< The renderer is a software fallback"]
pub const SDL_RendererFlags_SDL_RENDERER_SOFTWARE: SDL_RendererFlags = 1;
#[doc = "< The renderer uses hardware"]
#[doc = "acceleration"]
pub const SDL_RendererFlags_SDL_RENDERER_ACCELERATED: SDL_RendererFlags = 2;
#[doc = "< Present is synchronized"]
#[doc = "with the refresh rate"]
pub const SDL_RendererFlags_SDL_RENDERER_PRESENTVSYNC: SDL_RendererFlags = 4;
#[doc = "< The renderer supports"]
#[doc = "rendering to texture"]
pub const SDL_RendererFlags_SDL_RENDERER_TARGETTEXTURE: SDL_RendererFlags = 8;
#[doc = "  \\brief Flags used when creating a rendering context"]
pub type SDL_RendererFlags = u32;
#[doc = "  \\brief Information on the capabilities of a render driver or context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RendererInfo {
    #[doc = "< The name of the renderer"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Supported ::SDL_RendererFlags"]
    pub flags: Uint32,
    #[doc = "< The number of available texture formats"]
    pub num_texture_formats: Uint32,
    #[doc = "< The available texture formats"]
    pub texture_formats: [Uint32; 16usize],
    #[doc = "< The maximum texture width"]
    pub max_texture_width: ::std::os::raw::c_int,
    #[doc = "< The maximum texture height"]
    pub max_texture_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RendererInfo>(),
        88usize,
        concat!("Size of: ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RendererInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RendererInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RendererInfo>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RendererInfo>())).num_texture_formats as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(num_texture_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RendererInfo>())).texture_formats as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(texture_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RendererInfo>())).max_texture_width as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RendererInfo>())).max_texture_height as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_height)
        )
    );
}
#[doc = "< nearest pixel sampling"]
pub const SDL_ScaleMode_SDL_ScaleModeNearest: SDL_ScaleMode = 0;
#[doc = "< linear filtering"]
pub const SDL_ScaleMode_SDL_ScaleModeLinear: SDL_ScaleMode = 1;
#[doc = "< anisotropic filtering"]
pub const SDL_ScaleMode_SDL_ScaleModeBest: SDL_ScaleMode = 2;
#[doc = "  \\brief The scaling mode for a texture."]
pub type SDL_ScaleMode = u32;
#[doc = "< Changes rarely, not lockable"]
pub const SDL_TextureAccess_SDL_TEXTUREACCESS_STATIC: SDL_TextureAccess = 0;
#[doc = "< Changes frequently, lockable"]
pub const SDL_TextureAccess_SDL_TEXTUREACCESS_STREAMING: SDL_TextureAccess = 1;
#[doc = "< Texture can be used as a render target"]
pub const SDL_TextureAccess_SDL_TEXTUREACCESS_TARGET: SDL_TextureAccess = 2;
#[doc = "  \\brief The access pattern allowed for a texture."]
pub type SDL_TextureAccess = u32;
#[doc = "< No modulation"]
pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_NONE: SDL_TextureModulate = 0;
#[doc = "< srcC = srcC * color"]
pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_COLOR: SDL_TextureModulate = 1;
#[doc = "< srcA = srcA * alpha"]
pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_ALPHA: SDL_TextureModulate = 2;
#[doc = "  \\brief The texture channel modulation used in SDL_RenderCopy()."]
pub type SDL_TextureModulate = u32;
#[doc = "< Do not flip"]
pub const SDL_RendererFlip_SDL_FLIP_NONE: SDL_RendererFlip = 0;
#[doc = "< flip horizontally"]
pub const SDL_RendererFlip_SDL_FLIP_HORIZONTAL: SDL_RendererFlip = 1;
#[doc = "< flip vertically"]
pub const SDL_RendererFlip_SDL_FLIP_VERTICAL: SDL_RendererFlip = 2;
#[doc = "  \\brief Flip constants for SDL_RenderCopyEx"]
pub type SDL_RendererFlip = u32;
#[doc = "  \\brief A structure representing rendering state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Renderer {
    _unused: [u8; 0],
}
#[doc = "  \\brief An efficient driver-specific representation of pixel data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Texture {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  \\brief Get the number of 2D rendering drivers available for the current"]
    #[doc = "         display."]
    #[doc = ""]
    #[doc = "  A render driver is a set of code that handles rendering and texture"]
    #[doc = "  management on a particular display.  Normally there is only one, but"]
    #[doc = "  some drivers may have several available with different capabilities."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetRenderDriverInfo()"]
    #[doc = "  \\sa SDL_CreateRenderer()"]
    pub fn SDL_GetNumRenderDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get information about a specific 2D rendering driver for the current"]
    #[doc = "         display."]
    #[doc = ""]
    #[doc = "  \\param index The index of the driver to query information about."]
    #[doc = "  \\param info  A pointer to an SDL_RendererInfo struct to be filled with"]
    #[doc = "               information on the rendering driver."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, -1 if the index was out of range."]
    #[doc = ""]
    #[doc = "  \\sa SDL_CreateRenderer()"]
    pub fn SDL_GetRenderDriverInfo(
        index: ::std::os::raw::c_int,
        info: *mut SDL_RendererInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a window and default renderer"]
    #[doc = ""]
    #[doc = "  \\param width    The width of the window"]
    #[doc = "  \\param height   The height of the window"]
    #[doc = "  \\param window_flags The flags used to create the window"]
    #[doc = "  \\param window   A pointer filled with the window, or NULL on error"]
    #[doc = "  \\param renderer A pointer filled with the renderer, or NULL on error"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_CreateWindowAndRenderer(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        window_flags: Uint32,
        window: *mut *mut SDL_Window,
        renderer: *mut *mut SDL_Renderer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a 2D rendering context for a window."]
    #[doc = ""]
    #[doc = "  \\param window The window where rendering is displayed."]
    #[doc = "  \\param index    The index of the rendering driver to initialize, or -1 to"]
    #[doc = "                  initialize the first one supporting the requested flags."]
    #[doc = "  \\param flags    ::SDL_RendererFlags."]
    #[doc = ""]
    #[doc = "  \\return A valid rendering context or NULL if there was an error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_CreateSoftwareRenderer()"]
    #[doc = "  \\sa SDL_GetRendererInfo()"]
    #[doc = "  \\sa SDL_DestroyRenderer()"]
    pub fn SDL_CreateRenderer(
        window: *mut SDL_Window,
        index: ::std::os::raw::c_int,
        flags: Uint32,
    ) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = "  \\brief Create a 2D software rendering context for a surface."]
    #[doc = ""]
    #[doc = "  \\param surface The surface where rendering is done."]
    #[doc = ""]
    #[doc = "  \\return A valid rendering context or NULL if there was an error."]
    #[doc = ""]
    #[doc = "  \\sa SDL_CreateRenderer()"]
    #[doc = "  \\sa SDL_DestroyRenderer()"]
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = "  \\brief Get the renderer associated with a window."]
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = "  \\brief Get information about a rendering context."]
    pub fn SDL_GetRendererInfo(
        renderer: *mut SDL_Renderer,
        info: *mut SDL_RendererInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the output size in pixels of a rendering context."]
    pub fn SDL_GetRendererOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a texture for a rendering context."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer."]
    #[doc = "  \\param format The format of the texture."]
    #[doc = "  \\param access One of the enumerated values in ::SDL_TextureAccess."]
    #[doc = "  \\param w      The width of the texture in pixels."]
    #[doc = "  \\param h      The height of the texture in pixels."]
    #[doc = ""]
    #[doc = "  \\return The created texture is returned, or NULL if no rendering context was"]
    #[doc = "          active,  the format was unsupported, or the width or height were out"]
    #[doc = "          of range."]
    #[doc = ""]
    #[doc = "  \\note The contents of the texture are not defined at creation."]
    #[doc = ""]
    #[doc = "  \\sa SDL_QueryTexture()"]
    #[doc = "  \\sa SDL_UpdateTexture()"]
    #[doc = "  \\sa SDL_DestroyTexture()"]
    pub fn SDL_CreateTexture(
        renderer: *mut SDL_Renderer,
        format: Uint32,
        access: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = "  \\brief Create a texture from an existing surface."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer."]
    #[doc = "  \\param surface The surface containing pixel data used to fill the texture."]
    #[doc = ""]
    #[doc = "  \\return The created texture is returned, or NULL on error."]
    #[doc = ""]
    #[doc = "  \\note The surface is not modified or freed by this function."]
    #[doc = ""]
    #[doc = "  \\sa SDL_QueryTexture()"]
    #[doc = "  \\sa SDL_DestroyTexture()"]
    pub fn SDL_CreateTextureFromSurface(
        renderer: *mut SDL_Renderer,
        surface: *mut SDL_Surface,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = "  \\brief Query the attributes of a texture"]
    #[doc = ""]
    #[doc = "  \\param texture A texture to be queried."]
    #[doc = "  \\param format  A pointer filled in with the raw format of the texture.  The"]
    #[doc = "                 actual format may differ, but pixel transfers will use this"]
    #[doc = "                 format."]
    #[doc = "  \\param access  A pointer filled in with the actual access to the texture."]
    #[doc = "  \\param w       A pointer filled in with the width of the texture in pixels."]
    #[doc = "  \\param h       A pointer filled in with the height of the texture in pixels."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    pub fn SDL_QueryTexture(
        texture: *mut SDL_Texture,
        format: *mut Uint32,
        access: *mut ::std::os::raw::c_int,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional color value used in render copy operations."]
    #[doc = ""]
    #[doc = "  \\param texture The texture to update."]
    #[doc = "  \\param r       The red color value multiplied into copy operations."]
    #[doc = "  \\param g       The green color value multiplied into copy operations."]
    #[doc = "  \\param b       The blue color value multiplied into copy operations."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid or color modulation"]
    #[doc = "          is not supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetTextureColorMod()"]
    pub fn SDL_SetTextureColorMod(
        texture: *mut SDL_Texture,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional color value used in render copy operations."]
    #[doc = ""]
    #[doc = "  \\param texture The texture to query."]
    #[doc = "  \\param r         A pointer filled in with the current red color value."]
    #[doc = "  \\param g         A pointer filled in with the current green color value."]
    #[doc = "  \\param b         A pointer filled in with the current blue color value."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetTextureColorMod()"]
    pub fn SDL_GetTextureColorMod(
        texture: *mut SDL_Texture,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional alpha value used in render copy operations."]
    #[doc = ""]
    #[doc = "  \\param texture The texture to update."]
    #[doc = "  \\param alpha     The alpha value multiplied into copy operations."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid or alpha modulation"]
    #[doc = "          is not supported."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetTextureAlphaMod()"]
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional alpha value used in render copy operations."]
    #[doc = ""]
    #[doc = "  \\param texture The texture to query."]
    #[doc = "  \\param alpha     A pointer filled in with the current alpha value."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetTextureAlphaMod()"]
    pub fn SDL_GetTextureAlphaMod(
        texture: *mut SDL_Texture,
        alpha: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the blend mode used for texture copy operations."]
    #[doc = ""]
    #[doc = "  \\param texture The texture to update."]
    #[doc = "  \\param blendMode ::SDL_BlendMode to use for texture blending."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid or the blend mode is"]
    #[doc = "          not supported."]
    #[doc = ""]
    #[doc = "  \\note If the blend mode is not supported, the closest supported mode is"]
    #[doc = "        chosen."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetTextureBlendMode()"]
    pub fn SDL_SetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the blend mode used for texture copy operations."]
    #[doc = ""]
    #[doc = "  \\param texture   The texture to query."]
    #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetTextureBlendMode()"]
    pub fn SDL_GetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: *mut SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the scale mode used for texture scale operations."]
    #[doc = ""]
    #[doc = "  \\param texture The texture to update."]
    #[doc = "  \\param scaleMode ::SDL_ScaleMode to use for texture scaling."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\note If the scale mode is not supported, the closest supported mode is"]
    #[doc = "        chosen."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetTextureScaleMode()"]
    pub fn SDL_SetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: SDL_ScaleMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the scale mode used for texture scale operations."]
    #[doc = ""]
    #[doc = "  \\param texture   The texture to query."]
    #[doc = "  \\param scaleMode A pointer filled in with the current scale mode."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetTextureScaleMode()"]
    pub fn SDL_GetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: *mut SDL_ScaleMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Update the given texture rectangle with new pixel data."]
    #[doc = ""]
    #[doc = "  \\param texture   The texture to update"]
    #[doc = "  \\param rect      A pointer to the rectangle of pixels to update, or NULL to"]
    #[doc = "                   update the entire texture."]
    #[doc = "  \\param pixels    The raw pixel data in the format of the texture."]
    #[doc = "  \\param pitch     The number of bytes in a row of pixel data, including padding between lines."]
    #[doc = ""]
    #[doc = "  The pixel data must be in the format of the texture. The pixel format can be"]
    #[doc = "  queried with SDL_QueryTexture."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\note This is a fairly slow function."]
    pub fn SDL_UpdateTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *const ::std::os::raw::c_void,
        pitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data."]
    #[doc = ""]
    #[doc = "  \\param texture   The texture to update"]
    #[doc = "  \\param rect      A pointer to the rectangle of pixels to update, or NULL to"]
    #[doc = "                   update the entire texture."]
    #[doc = "  \\param Yplane    The raw pixel data for the Y plane."]
    #[doc = "  \\param Ypitch    The number of bytes between rows of pixel data for the Y plane."]
    #[doc = "  \\param Uplane    The raw pixel data for the U plane."]
    #[doc = "  \\param Upitch    The number of bytes between rows of pixel data for the U plane."]
    #[doc = "  \\param Vplane    The raw pixel data for the V plane."]
    #[doc = "  \\param Vpitch    The number of bytes between rows of pixel data for the V plane."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = "  \\note You can use SDL_UpdateTexture() as long as your pixel data is"]
    #[doc = "        a contiguous block of Y and U/V planes in the proper order, but"]
    #[doc = "        this function is available if your pixel data is not contiguous."]
    pub fn SDL_UpdateYUVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: ::std::os::raw::c_int,
        Uplane: *const Uint8,
        Upitch: ::std::os::raw::c_int,
        Vplane: *const Uint8,
        Vpitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Lock a portion of the texture for write-only pixel access."]
    #[doc = ""]
    #[doc = "  \\param texture   The texture to lock for access, which was created with"]
    #[doc = "                   ::SDL_TEXTUREACCESS_STREAMING."]
    #[doc = "  \\param rect      A pointer to the rectangle to lock for access. If the rect"]
    #[doc = "                   is NULL, the entire texture will be locked."]
    #[doc = "  \\param pixels    This is filled in with a pointer to the locked pixels,"]
    #[doc = "                   appropriately offset by the locked area."]
    #[doc = "  \\param pitch     This is filled in with the pitch of the locked pixels."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING."]
    #[doc = ""]
    #[doc = "  \\sa SDL_UnlockTexture()"]
    pub fn SDL_LockTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *mut *mut ::std::os::raw::c_void,
        pitch: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Lock a portion of the texture for write-only pixel access."]
    #[doc = "         Expose it as a SDL surface."]
    #[doc = ""]
    #[doc = "  \\param texture   The texture to lock for access, which was created with"]
    #[doc = "                   ::SDL_TEXTUREACCESS_STREAMING."]
    #[doc = "  \\param rect      A pointer to the rectangle to lock for access. If the rect"]
    #[doc = "                   is NULL, the entire texture will be locked."]
    #[doc = "  \\param surface   This is filled in with a SDL surface representing the locked area"]
    #[doc = "                   Surface is freed internally after calling SDL_UnlockTexture or SDL_DestroyTexture."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING."]
    #[doc = ""]
    #[doc = "  \\sa SDL_UnlockTexture()"]
    pub fn SDL_LockTextureToSurface(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        surface: *mut *mut SDL_Surface,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Unlock a texture, uploading the changes to video memory, if needed."]
    #[doc = "         If SDL_LockTextureToSurface() was called for locking, the SDL surface is freed."]
    #[doc = ""]
    #[doc = "  \\sa SDL_LockTexture()"]
    #[doc = "  \\sa SDL_LockTextureToSurface()"]
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = " \\brief Determines whether a window supports the use of render targets"]
    #[doc = ""]
    #[doc = " \\param renderer The renderer that will be checked"]
    #[doc = ""]
    #[doc = " \\return SDL_TRUE if supported, SDL_FALSE if not."]
    pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Set a texture as the current rendering target."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer."]
    #[doc = " \\param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target"]
    #[doc = ""]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetRenderTarget()"]
    pub fn SDL_SetRenderTarget(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current render target or NULL for the default render target."]
    #[doc = ""]
    #[doc = " \\return The current render target"]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetRenderTarget()"]
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = "  \\brief Set device independent resolution for rendering"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which resolution should be set."]
    #[doc = "  \\param w      The width of the logical resolution"]
    #[doc = "  \\param h      The height of the logical resolution"]
    #[doc = ""]
    #[doc = "  This function uses the viewport and scaling functionality to allow a fixed logical"]
    #[doc = "  resolution for rendering, regardless of the actual output resolution.  If the actual"]
    #[doc = "  output resolution doesn't have the same aspect ratio the output rendering will be"]
    #[doc = "  centered within the output display."]
    #[doc = ""]
    #[doc = "  If the output display is a window, mouse events in the window will be filtered"]
    #[doc = "  and scaled so they seem to arrive within the logical resolution."]
    #[doc = ""]
    #[doc = "  \\note If this function results in scaling or subpixel drawing by the"]
    #[doc = "        rendering backend, it will be handled using the appropriate"]
    #[doc = "        quality hints."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetLogicalSize()"]
    #[doc = "  \\sa SDL_RenderSetScale()"]
    #[doc = "  \\sa SDL_RenderSetViewport()"]
    pub fn SDL_RenderSetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get device independent resolution for rendering"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which resolution should be queried."]
    #[doc = "  \\param w      A pointer filled with the width of the logical resolution"]
    #[doc = "  \\param h      A pointer filled with the height of the logical resolution"]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderGetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set whether to force integer scales for resolution-independent rendering"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which integer scaling should be set."]
    #[doc = "  \\param enable   Enable or disable integer scaling"]
    #[doc = ""]
    #[doc = "  This function restricts the logical viewport to integer values - that is, when"]
    #[doc = "  a resolution is between two multiples of a logical size, the viewport size is"]
    #[doc = "  rounded down to the lower multiple."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderSetIntegerScale(
        renderer: *mut SDL_Renderer,
        enable: SDL_bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get whether integer scales are forced for resolution-independent rendering"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which integer scaling should be queried."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderSetIntegerScale()"]
    pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Set the drawing area for rendering on the current target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which the drawing area should be set."]
    #[doc = "  \\param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target."]
    #[doc = ""]
    #[doc = "  The x,y of the viewport rect represents the origin for rendering."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = "  \\note If the window associated with the renderer is resized, the viewport is automatically reset."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetViewport()"]
    #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderSetViewport(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the drawing area for the current target."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderSetViewport()"]
    pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Set the clip rectangle for the current target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which clip rectangle should be set."]
    #[doc = "  \\param rect   A pointer to the rectangle to set as the clip rectangle,"]
    #[doc = "                relative to the viewport, or NULL to disable clipping."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetClipRect()"]
    pub fn SDL_RenderSetClipRect(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the clip rectangle for the current target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which clip rectangle should be queried."]
    #[doc = "  \\param rect   A pointer filled in with the current clip rectangle, or"]
    #[doc = "                an empty rectangle if clipping is disabled."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderSetClipRect()"]
    pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Get whether clipping is enabled on the given renderer."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which clip state should be queried."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetClipRect()"]
    pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Set the drawing scale for rendering on the current target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which the drawing scale should be set."]
    #[doc = "  \\param scaleX The horizontal scaling factor"]
    #[doc = "  \\param scaleY The vertical scaling factor"]
    #[doc = ""]
    #[doc = "  The drawing coordinates are scaled by the x/y scaling factors"]
    #[doc = "  before they are used by the renderer.  This allows resolution"]
    #[doc = "  independent drawing with a single coordinate system."]
    #[doc = ""]
    #[doc = "  \\note If this results in scaling or subpixel drawing by the"]
    #[doc = "        rendering backend, it will be handled using the appropriate"]
    #[doc = "        quality hints.  For best results use integer scaling factors."]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetScale()"]
    #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderSetScale(
        renderer: *mut SDL_Renderer,
        scaleX: f32,
        scaleY: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the drawing scale for the current target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which drawing scale should be queried."]
    #[doc = "  \\param scaleX A pointer filled in with the horizontal scaling factor"]
    #[doc = "  \\param scaleY A pointer filled in with the vertical scaling factor"]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderSetScale()"]
    pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
    #[doc = "  \\brief Set the color used for drawing operations (Rect, Line and Clear)."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which drawing color should be set."]
    #[doc = "  \\param r The red value used to draw on the rendering target."]
    #[doc = "  \\param g The green value used to draw on the rendering target."]
    #[doc = "  \\param b The blue value used to draw on the rendering target."]
    #[doc = "  \\param a The alpha value used to draw on the rendering target, usually"]
    #[doc = "           ::SDL_ALPHA_OPAQUE (255)."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_SetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the color used for drawing operations (Rect, Line and Clear)."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which drawing color should be queried."]
    #[doc = "  \\param r A pointer to the red value used to draw on the rendering target."]
    #[doc = "  \\param g A pointer to the green value used to draw on the rendering target."]
    #[doc = "  \\param b A pointer to the blue value used to draw on the rendering target."]
    #[doc = "  \\param a A pointer to the alpha value used to draw on the rendering target,"]
    #[doc = "           usually ::SDL_ALPHA_OPAQUE (255)."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_GetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the blend mode used for drawing operations (Fill and Line)."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer for which blend mode should be set."]
    #[doc = "  \\param blendMode ::SDL_BlendMode to use for blending."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = "  \\note If the blend mode is not supported, the closest supported mode is"]
    #[doc = "        chosen."]
    #[doc = ""]
    #[doc = "  \\sa SDL_GetRenderDrawBlendMode()"]
    pub fn SDL_SetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the blend mode used for drawing operations."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which blend mode should be queried."]
    #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = "  \\sa SDL_SetRenderDrawBlendMode()"]
    pub fn SDL_GetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: *mut SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Clear the current rendering target with the drawing color"]
    #[doc = ""]
    #[doc = "  This function clears the entire rendering target, ignoring the viewport and"]
    #[doc = "  the clip rectangle."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a point on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw a point."]
    #[doc = "  \\param x The x coordinate of the point."]
    #[doc = "  \\param y The y coordinate of the point."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPoint(
        renderer: *mut SDL_Renderer,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw multiple points on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw multiple points."]
    #[doc = "  \\param points The points to draw"]
    #[doc = "  \\param count The number of points to draw"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPoints(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a line on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw a line."]
    #[doc = "  \\param x1 The x coordinate of the start point."]
    #[doc = "  \\param y1 The y coordinate of the start point."]
    #[doc = "  \\param x2 The x coordinate of the end point."]
    #[doc = "  \\param y2 The y coordinate of the end point."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLine(
        renderer: *mut SDL_Renderer,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a series of connected lines on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw multiple lines."]
    #[doc = "  \\param points The points along the lines"]
    #[doc = "  \\param count The number of points, drawing count-1 lines"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLines(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a rectangle on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw a rectangle."]
    #[doc = "  \\param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRect(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw some number of rectangles on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw multiple rectangles."]
    #[doc = "  \\param rects A pointer to an array of destination rectangles."]
    #[doc = "  \\param count The number of rectangles."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill a rectangle on the current rendering target with the drawing color."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should fill a rectangle."]
    #[doc = "  \\param rect A pointer to the destination rectangle, or NULL for the entire"]
    #[doc = "              rendering target."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRect(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill some number of rectangles on the current rendering target with the drawing color."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should fill multiple rectangles."]
    #[doc = "  \\param rects A pointer to an array of destination rectangles."]
    #[doc = "  \\param count The number of rectangles."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the texture to the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
    #[doc = "  \\param texture The source texture."]
    #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
    #[doc = "                   texture."]
    #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
    #[doc = "                   entire rendering target."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopy(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
    #[doc = "  \\param texture The source texture."]
    #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
    #[doc = "                   texture."]
    #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
    #[doc = "                   entire rendering target."]
    #[doc = "  \\param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction"]
    #[doc = "  \\param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2)."]
    #[doc = "  \\param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopyEx(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
        angle: f64,
        center: *const SDL_Point,
        flip: SDL_RendererFlip,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a point on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw a point."]
    #[doc = "  \\param x The x coordinate of the point."]
    #[doc = "  \\param y The y coordinate of the point."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPointF(
        renderer: *mut SDL_Renderer,
        x: f32,
        y: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw multiple points on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw multiple points."]
    #[doc = "  \\param points The points to draw"]
    #[doc = "  \\param count The number of points to draw"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPointsF(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a line on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw a line."]
    #[doc = "  \\param x1 The x coordinate of the start point."]
    #[doc = "  \\param y1 The y coordinate of the start point."]
    #[doc = "  \\param x2 The x coordinate of the end point."]
    #[doc = "  \\param y2 The y coordinate of the end point."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLineF(
        renderer: *mut SDL_Renderer,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a series of connected lines on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw multiple lines."]
    #[doc = "  \\param points The points along the lines"]
    #[doc = "  \\param count The number of points, drawing count-1 lines"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLinesF(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a rectangle on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw a rectangle."]
    #[doc = "  \\param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRectF(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_FRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw some number of rectangles on the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should draw multiple rectangles."]
    #[doc = "  \\param rects A pointer to an array of destination rectangles."]
    #[doc = "  \\param count The number of rectangles."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRectsF(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill a rectangle on the current rendering target with the drawing color."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should fill a rectangle."]
    #[doc = "  \\param rect A pointer to the destination rectangle, or NULL for the entire"]
    #[doc = "              rendering target."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRectF(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_FRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill some number of rectangles on the current rendering target with the drawing color."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should fill multiple rectangles."]
    #[doc = "  \\param rects A pointer to an array of destination rectangles."]
    #[doc = "  \\param count The number of rectangles."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRectsF(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the texture to the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
    #[doc = "  \\param texture The source texture."]
    #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
    #[doc = "                   texture."]
    #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
    #[doc = "                   entire rendering target."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopyF(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_FRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
    #[doc = "  \\param texture The source texture."]
    #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
    #[doc = "                   texture."]
    #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
    #[doc = "                   entire rendering target."]
    #[doc = "  \\param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction"]
    #[doc = "  \\param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2)."]
    #[doc = "  \\param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopyExF(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_FRect,
        angle: f64,
        center: *const SDL_FPoint,
        flip: SDL_RendererFlip,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Read pixels from the current rendering target."]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer from which pixels should be read."]
    #[doc = "  \\param rect   A pointer to the rectangle to read, or NULL for the entire"]
    #[doc = "                render target."]
    #[doc = "  \\param format The desired format of the pixel data, or 0 to use the format"]
    #[doc = "                of the rendering target"]
    #[doc = "  \\param pixels A pointer to be filled in with the pixel data"]
    #[doc = "  \\param pitch  The pitch of the pixels parameter."]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if pixel reading is not supported."]
    #[doc = ""]
    #[doc = "  \\warning This is a very slow operation, and should not be used frequently."]
    pub fn SDL_RenderReadPixels(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
        format: Uint32,
        pixels: *mut ::std::os::raw::c_void,
        pitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Update the screen with rendering performed."]
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = "  \\brief Destroy the specified texture."]
    #[doc = ""]
    #[doc = "  \\sa SDL_CreateTexture()"]
    #[doc = "  \\sa SDL_CreateTextureFromSurface()"]
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = "  \\brief Destroy the rendering context for a window and free associated"]
    #[doc = "         textures."]
    #[doc = ""]
    #[doc = "  \\sa SDL_CreateRenderer()"]
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = "  \\brief Force the rendering context to flush any pending commands to the"]
    #[doc = "         underlying rendering API."]
    #[doc = ""]
    #[doc = "  You do not need to (and in fact, shouldn't) call this function unless"]
    #[doc = "  you are planning to call into OpenGL/Direct3D/Metal/whatever directly"]
    #[doc = "  in addition to using an SDL_Renderer."]
    #[doc = ""]
    #[doc = "  This is for a very-specific case: if you are using SDL's render API,"]
    #[doc = "  you asked for a specific renderer backend (OpenGL, Direct3D, etc),"]
    #[doc = "  you set SDL_HINT_RENDER_BATCHING to \"1\", and you plan to make"]
    #[doc = "  OpenGL/D3D/whatever calls in addition to SDL render API calls. If all of"]
    #[doc = "  this applies, you should call SDL_RenderFlush() between calls to SDL's"]
    #[doc = "  render API and the low-level API you're using in cooperation."]
    #[doc = ""]
    #[doc = "  In all other cases, you can ignore this function. This is only here to"]
    #[doc = "  get maximum performance out of a specific situation. In all other cases,"]
    #[doc = "  SDL will do the right thing, perhaps at a performance loss."]
    #[doc = ""]
    #[doc = "  This function is first available in SDL 2.0.10, and is not needed in"]
    #[doc = "  2.0.9 and earlier, as earlier versions did not queue rendering commands"]
    #[doc = "  at all, instead flushing them to the OS immediately."]
    pub fn SDL_RenderFlush(renderer: *mut SDL_Renderer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Bind the texture to the current OpenGL/ES/ES2 context for use with"]
    #[doc = "         OpenGL instructions."]
    #[doc = ""]
    #[doc = "  \\param texture  The SDL texture to bind"]
    #[doc = "  \\param texw     A pointer to a float that will be filled with the texture width"]
    #[doc = "  \\param texh     A pointer to a float that will be filled with the texture height"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the operation is not supported"]
    pub fn SDL_GL_BindTexture(
        texture: *mut SDL_Texture,
        texw: *mut f32,
        texh: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Unbind a texture from the current OpenGL/ES/ES2 context."]
    #[doc = ""]
    #[doc = "  \\param texture  The SDL texture to unbind"]
    #[doc = ""]
    #[doc = "  \\return 0 on success, or -1 if the operation is not supported"]
    pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the CAMetalLayer associated with the given Metal renderer"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer to query"]
    #[doc = ""]
    #[doc = "  \\return CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer"]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetMetalCommandEncoder()"]
    pub fn SDL_RenderGetMetalLayer(renderer: *mut SDL_Renderer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  \\brief Get the Metal command encoder for the current frame"]
    #[doc = ""]
    #[doc = "  \\param renderer The renderer to query"]
    #[doc = ""]
    #[doc = "  \\return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer"]
    #[doc = ""]
    #[doc = "  \\sa SDL_RenderGetMetalLayer()"]
    pub fn SDL_RenderGetMetalCommandEncoder(
        renderer: *mut SDL_Renderer,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = "  \\brief SDL_sensor.h"]
#[doc = ""]
#[doc = "  In order to use these functions, SDL_Init() must have been called"]
#[doc = "  with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system"]
#[doc = "  for sensors, and load appropriate drivers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Sensor {
    _unused: [u8; 0],
}
pub type SDL_Sensor = _SDL_Sensor;
#[doc = " This is a unique ID for a sensor for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_SensorID = Sint32;
#[doc = "< Returned for an invalid sensor"]
pub const SDL_SensorType_SDL_SENSOR_INVALID: SDL_SensorType = -1;
#[doc = "< Unknown sensor type"]
pub const SDL_SensorType_SDL_SENSOR_UNKNOWN: SDL_SensorType = 0;
#[doc = "< Accelerometer"]
pub const SDL_SensorType_SDL_SENSOR_ACCEL: SDL_SensorType = 1;
#[doc = "< Gyroscope"]
pub const SDL_SensorType_SDL_SENSOR_GYRO: SDL_SensorType = 2;
pub type SDL_SensorType = i32;
extern "C" {
    #[doc = "  \\brief Count the number of sensors attached to the system right now"]
    pub fn SDL_NumSensors() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the implementation dependent name of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor name, or NULL if device_index is out of range."]
    pub fn SDL_SensorGetDeviceName(
        device_index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the type of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor type, or SDL_SENSOR_INVALID if device_index is out of range."]
    pub fn SDL_SensorGetDeviceType(device_index: ::std::os::raw::c_int) -> SDL_SensorType;
}
extern "C" {
    #[doc = "  \\brief Get the platform dependent type of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor platform dependent type, or -1 if device_index is out of range."]
    pub fn SDL_SensorGetDeviceNonPortableType(
        device_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the instance ID of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor instance ID, or -1 if device_index is out of range."]
    pub fn SDL_SensorGetDeviceInstanceID(device_index: ::std::os::raw::c_int) -> SDL_SensorID;
}
extern "C" {
    #[doc = "  \\brief Open a sensor for use."]
    #[doc = ""]
    #[doc = "  The index passed as an argument refers to the N'th sensor on the system."]
    #[doc = ""]
    #[doc = "  \\return A sensor identifier, or NULL if an error occurred."]
    pub fn SDL_SensorOpen(device_index: ::std::os::raw::c_int) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = " Return the SDL_Sensor associated with an instance id."]
    pub fn SDL_SensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = "  \\brief Get the implementation dependent name of a sensor."]
    #[doc = ""]
    #[doc = "  \\return The sensor name, or NULL if the sensor is NULL."]
    pub fn SDL_SensorGetName(sensor: *mut SDL_Sensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the type of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL."]
    pub fn SDL_SensorGetType(sensor: *mut SDL_Sensor) -> SDL_SensorType;
}
extern "C" {
    #[doc = "  \\brief Get the platform dependent type of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor platform dependent type, or -1 if the sensor is NULL."]
    pub fn SDL_SensorGetNonPortableType(sensor: *mut SDL_Sensor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the instance ID of a sensor."]
    #[doc = ""]
    #[doc = "  This can be called before any sensors are opened."]
    #[doc = ""]
    #[doc = "  \\return The sensor instance ID, or -1 if the sensor is NULL."]
    pub fn SDL_SensorGetInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
    #[doc = "  Get the current state of an opened sensor."]
    #[doc = ""]
    #[doc = "  The number of values and interpretation of the data is sensor dependent."]
    #[doc = ""]
    #[doc = "  \\param sensor The sensor to query"]
    #[doc = "  \\param data A pointer filled with the current sensor state"]
    #[doc = "  \\param num_values The number of values to write to data"]
    #[doc = ""]
    #[doc = "  \\return 0 or -1 if an error occurred."]
    pub fn SDL_SensorGetData(
        sensor: *mut SDL_Sensor,
        data: *mut f32,
        num_values: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Close a sensor previously opened with SDL_SensorOpen()"]
    pub fn SDL_SensorClose(sensor: *mut SDL_Sensor);
}
extern "C" {
    #[doc = "  Update the current state of the open sensors."]
    #[doc = ""]
    #[doc = "  This is called automatically by the event loop if sensor events are enabled."]
    #[doc = ""]
    #[doc = "  This needs to be called from the thread that initialized the sensor subsystem."]
    pub fn SDL_SensorUpdate();
}
extern "C" {
    #[doc = "  \\brief Create a window that can be shaped with the specified position, dimensions, and flags."]
    #[doc = ""]
    #[doc = "  \\param title The title of the window, in UTF-8 encoding."]
    #[doc = "  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
    #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = "  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
    #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = "  \\param w     The width of the window."]
    #[doc = "  \\param h     The height of the window."]
    #[doc = "  \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:"]
    #[doc = "               ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,"]
    #[doc = "               ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,"]
    #[doc = "               ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,"]
    #[doc = "       ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset."]
    #[doc = ""]
    #[doc = "  \\return The window created, or NULL if window creation failed."]
    #[doc = ""]
    #[doc = "  \\sa SDL_DestroyWindow()"]
    pub fn SDL_CreateShapedWindow(
        title: *const ::std::os::raw::c_char,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " \\brief Return whether the given window is a shaped window."]
    #[doc = ""]
    #[doc = " \\param window The window to query for being shaped."]
    #[doc = ""]
    #[doc = " \\return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateShapedWindow"]
    pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool;
}
#[doc = " \\brief The default mode, a binarized alpha cutoff of 1."]
pub const WindowShapeMode_ShapeModeDefault: WindowShapeMode = 0;
#[doc = " \\brief A binarized alpha cutoff with a given integer value."]
pub const WindowShapeMode_ShapeModeBinarizeAlpha: WindowShapeMode = 1;
#[doc = " \\brief A binarized alpha cutoff with a given integer value, but with the opposite comparison."]
pub const WindowShapeMode_ShapeModeReverseBinarizeAlpha: WindowShapeMode = 2;
#[doc = " \\brief A color key is applied."]
pub const WindowShapeMode_ShapeModeColorKey: WindowShapeMode = 3;
#[doc = " \\brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union."]
pub type WindowShapeMode = u32;
#[doc = " \\brief A union containing parameters for shaped windows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
    #[doc = " \\brief A cutoff alpha value for binarization of the window shape's alpha channel."]
    pub binarizationCutoff: Uint8,
    pub colorKey: SDL_Color,
    _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
    assert_eq!(
        ::std::mem::size_of::<SDL_WindowShapeParams>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_WindowShapeParams>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_WindowShapeParams>())).binarizationCutoff as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(binarizationCutoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowShapeParams>())).colorKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(colorKey)
        )
    );
}
#[doc = " \\brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
    #[doc = " \\brief The mode of these window-shape parameters."]
    pub mode: WindowShapeMode,
    #[doc = " \\brief Window-shape parameters."]
    pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
    assert_eq!(
        ::std::mem::size_of::<SDL_WindowShapeMode>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_WindowShapeMode>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowShapeMode>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_WindowShapeMode>())).parameters as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(parameters)
        )
    );
}
extern "C" {
    #[doc = " \\brief Set the shape and parameters of a shaped window."]
    #[doc = ""]
    #[doc = " \\param window The shaped window whose parameters should be set."]
    #[doc = " \\param shape A surface encoding the desired shape for the window."]
    #[doc = " \\param shape_mode The parameters to set for the shaped window."]
    #[doc = ""]
    #[doc = " \\return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW"]
    #[doc = "           if the SDL_Window given does not reference a valid shaped window."]
    #[doc = ""]
    #[doc = " \\sa SDL_WindowShapeMode"]
    #[doc = " \\sa SDL_GetShapedWindowMode."]
    pub fn SDL_SetWindowShape(
        window: *mut SDL_Window,
        shape: *mut SDL_Surface,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the shape parameters of a shaped window."]
    #[doc = ""]
    #[doc = " \\param window The shaped window whose parameters should be retrieved."]
    #[doc = " \\param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape."]
    #[doc = ""]
    #[doc = " \\return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode"]
    #[doc = "           data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if"]
    #[doc = "           the SDL_Window given is a shapeable window currently lacking a shape."]
    #[doc = ""]
    #[doc = " \\sa SDL_WindowShapeMode"]
    #[doc = " \\sa SDL_SetWindowShape"]
    pub fn SDL_GetShapedWindowMode(
        window: *mut SDL_Window,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets the UNIX nice value for a thread, using setpriority() if possible, and RealtimeKit if available."]
    #[doc = ""]
    #[doc = "\\return 0 on success, or -1 on error."]
    pub fn SDL_LinuxSetThreadPriority(
        threadID: Sint64,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Return true if the current device is a tablet."]
    pub fn SDL_IsTablet() -> SDL_bool;
}
extern "C" {
    pub fn SDL_OnApplicationWillTerminate();
}
extern "C" {
    pub fn SDL_OnApplicationDidReceiveMemoryWarning();
}
extern "C" {
    pub fn SDL_OnApplicationWillResignActive();
}
extern "C" {
    pub fn SDL_OnApplicationDidEnterBackground();
}
extern "C" {
    pub fn SDL_OnApplicationWillEnterForeground();
}
extern "C" {
    pub fn SDL_OnApplicationDidBecomeActive();
}
extern "C" {
    #[doc = " \\brief Get the number of milliseconds since the SDL library initialization."]
    #[doc = ""]
    #[doc = " \\note This value wraps if the program runs for more than ~49 days."]
    pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
    #[doc = " \\brief Get the current value of the high resolution counter"]
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
    #[doc = " \\brief Get the count per second of the high resolution counter"]
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
    #[doc = " \\brief Wait a specified number of milliseconds before returning."]
    pub fn SDL_Delay(ms: Uint32);
}
#[doc = "  Function prototype for the timer callback function."]
#[doc = ""]
#[doc = "  The callback function is passed the current timer interval and returns"]
#[doc = "  the next timer interval.  If the returned value is the same as the one"]
#[doc = "  passed in, the periodic alarm continues, otherwise a new alarm is"]
#[doc = "  scheduled.  If the callback returns 0, the periodic alarm is cancelled."]
pub type SDL_TimerCallback = ::std::option::Option<
    unsafe extern "C" fn(interval: Uint32, param: *mut ::std::os::raw::c_void) -> Uint32,
>;
#[doc = " Definition of the timer ID type."]
pub type SDL_TimerID = ::std::os::raw::c_int;
extern "C" {
    #[doc = " \\brief Add a new timer to the pool of timers already running."]
    #[doc = ""]
    #[doc = " \\return A timer ID, or 0 when an error occurs."]
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_TimerCallback,
        param: *mut ::std::os::raw::c_void,
    ) -> SDL_TimerID;
}
extern "C" {
    #[doc = " \\brief Remove a timer knowing its ID."]
    #[doc = ""]
    #[doc = " \\return A boolean value indicating success or failure."]
    #[doc = ""]
    #[doc = " \\warning It is not safe to remove a timer multiple times."]
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool;
}
#[doc = "  \\brief Information the version of SDL in use."]
#[doc = ""]
#[doc = "  Represents the library's version as three levels: major revision"]
#[doc = "  (increments with massive changes, additions, and enhancements),"]
#[doc = "  minor revision (increments with backwards-compatible changes to the"]
#[doc = "  major revision), and patchlevel (increments with fixes to the minor"]
#[doc = "  revision)."]
#[doc = ""]
#[doc = "  \\sa SDL_VERSION"]
#[doc = "  \\sa SDL_GetVersion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_version {
    #[doc = "< major version"]
    pub major: Uint8,
    #[doc = "< minor version"]
    pub minor: Uint8,
    #[doc = "< update version"]
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    assert_eq!(
        ::std::mem::size_of::<SDL_version>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_version))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_version>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_version>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_version>())).patch as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Get the version of SDL that is linked against your program."]
    #[doc = ""]
    #[doc = "  If you are linking to SDL dynamically, then it is possible that the"]
    #[doc = "  current version will be different than the version you compiled against."]
    #[doc = "  This function returns the current version, while SDL_VERSION() is a"]
    #[doc = "  macro that tells you what version you compiled with."]
    #[doc = ""]
    #[doc = "  \\code"]
    #[doc = "  SDL_version compiled;"]
    #[doc = "  SDL_version linked;"]
    #[doc = ""]
    #[doc = "  SDL_VERSION(&compiled);"]
    #[doc = "  SDL_GetVersion(&linked);"]
    #[doc = "  printf(\"We compiled against SDL version %d.%d.%d ...\\n\","]
    #[doc = "         compiled.major, compiled.minor, compiled.patch);"]
    #[doc = "  printf(\"But we linked against SDL version %d.%d.%d.\\n\","]
    #[doc = "         linked.major, linked.minor, linked.patch);"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = "  This function may be called safely at any time, even before SDL_Init()."]
    #[doc = ""]
    #[doc = "  \\sa SDL_VERSION"]
    pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
    #[doc = "  \\brief Get the code revision of SDL that is linked against your program."]
    #[doc = ""]
    #[doc = "  Returns an arbitrary string (a hash value) uniquely identifying the"]
    #[doc = "  exact revision of the SDL library in use, and is only useful in comparing"]
    #[doc = "  against other revisions. It is NOT an incrementing number."]
    pub fn SDL_GetRevision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the revision number of SDL that is linked against your program."]
    #[doc = ""]
    #[doc = "  Returns a number uniquely identifying the exact revision of the SDL"]
    #[doc = "  library in use. It is an incrementing number based on commits to"]
    #[doc = "  hg.libsdl.org."]
    pub fn SDL_GetRevisionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This function initializes  the subsystems specified by \\c flags"]
    pub fn SDL_Init(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This function initializes specific SDL subsystems"]
    #[doc = ""]
    #[doc = "  Subsystem initialization is ref-counted, you must call"]
    #[doc = "  SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly"]
    #[doc = "  shutdown a subsystem manually (or call SDL_Quit() to force shutdown)."]
    #[doc = "  If a subsystem is already loaded then this call will"]
    #[doc = "  increase the ref-count and return."]
    pub fn SDL_InitSubSystem(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  This function cleans up specific SDL subsystems"]
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    #[doc = "  This function returns a mask of the specified subsystems which have"]
    #[doc = "  previously been initialized."]
    #[doc = ""]
    #[doc = "  If \\c flags is 0, it returns a mask of all initialized subsystems."]
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    #[doc = "  This function cleans up all initialized subsystems. You should"]
    #[doc = "  call it upon all exit conditions."]
    pub fn SDL_Quit();
}
pub type ImGuiCol = ::std::os::raw::c_int;
pub type ImGuiCond = ::std::os::raw::c_int;
pub type ImGuiDataType = ::std::os::raw::c_int;
pub type ImGuiDir = ::std::os::raw::c_int;
pub type ImGuiKey = ::std::os::raw::c_int;
pub type ImGuiNavInput = ::std::os::raw::c_int;
pub type ImGuiMouseButton = ::std::os::raw::c_int;
pub type ImGuiMouseCursor = ::std::os::raw::c_int;
pub type ImGuiStyleVar = ::std::os::raw::c_int;
pub type ImDrawCornerFlags = ::std::os::raw::c_int;
pub type ImDrawListFlags = ::std::os::raw::c_int;
pub type ImFontAtlasFlags = ::std::os::raw::c_int;
pub type ImGuiBackendFlags = ::std::os::raw::c_int;
pub type ImGuiColorEditFlags = ::std::os::raw::c_int;
pub type ImGuiConfigFlags = ::std::os::raw::c_int;
pub type ImGuiComboFlags = ::std::os::raw::c_int;
pub type ImGuiDragDropFlags = ::std::os::raw::c_int;
pub type ImGuiFocusedFlags = ::std::os::raw::c_int;
pub type ImGuiHoveredFlags = ::std::os::raw::c_int;
pub type ImGuiInputTextFlags = ::std::os::raw::c_int;
pub type ImGuiKeyModFlags = ::std::os::raw::c_int;
pub type ImGuiSelectableFlags = ::std::os::raw::c_int;
pub type ImGuiTabBarFlags = ::std::os::raw::c_int;
pub type ImGuiTabItemFlags = ::std::os::raw::c_int;
pub type ImGuiTreeNodeFlags = ::std::os::raw::c_int;
pub type ImGuiWindowFlags = ::std::os::raw::c_int;
pub type ImTextureID = *mut ::std::os::raw::c_void;
pub type ImGuiID = ::std::os::raw::c_uint;
pub type ImGuiInputTextCallback = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ImGuiInputTextCallbackData) -> ::std::os::raw::c_int,
>;
pub type ImGuiSizeCallback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ImGuiSizeCallbackData)>;
pub type ImWchar16 = ::std::os::raw::c_ushort;
pub type ImWchar32 = ::std::os::raw::c_uint;
pub type ImWchar = ImWchar16;
pub type ImS8 = ::std::os::raw::c_schar;
pub type ImU8 = ::std::os::raw::c_uchar;
pub type ImS16 = ::std::os::raw::c_short;
pub type ImU16 = ::std::os::raw::c_ushort;
pub type ImS32 = ::std::os::raw::c_int;
pub type ImU32 = ::std::os::raw::c_uint;
pub type ImS64 = i64;
pub type ImU64 = u64;
pub type ImDrawCallback = ::std::option::Option<
    unsafe extern "C" fn(parent_list: *const ImDrawList, cmd: *const ImDrawCmd),
>;
pub type ImDrawIdx = ::std::os::raw::c_ushort;
pub type ImGuiLayoutType = ::std::os::raw::c_int;
pub type ImGuiButtonFlags = ::std::os::raw::c_int;
pub type ImGuiColumnsFlags = ::std::os::raw::c_int;
pub type ImGuiDragFlags = ::std::os::raw::c_int;
pub type ImGuiItemFlags = ::std::os::raw::c_int;
pub type ImGuiItemStatusFlags = ::std::os::raw::c_int;
pub type ImGuiNavHighlightFlags = ::std::os::raw::c_int;
pub type ImGuiNavDirSourceFlags = ::std::os::raw::c_int;
pub type ImGuiNavMoveFlags = ::std::os::raw::c_int;
pub type ImGuiNextItemDataFlags = ::std::os::raw::c_int;
pub type ImGuiNextWindowDataFlags = ::std::os::raw::c_int;
pub type ImGuiSeparatorFlags = ::std::os::raw::c_int;
pub type ImGuiSliderFlags = ::std::os::raw::c_int;
pub type ImGuiTextFlags = ::std::os::raw::c_int;
pub type ImGuiTooltipFlags = ::std::os::raw::c_int;
extern "C" {
    pub static mut GImGui: *mut ImGuiContext;
}
pub type ImFileHandle = *mut FILE;
pub type ImPoolIdx = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ImVector() {
    assert_eq!(
        ::std::mem::size_of::<ImVector>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_float {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut f32,
}
#[test]
fn bindgen_test_layout_ImVector_float() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_float>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_float))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_float>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_float))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_float>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_float),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_float>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_float),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_float>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_float),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImWchar {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImWchar,
}
#[test]
fn bindgen_test_layout_ImVector_ImWchar() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImWchar>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImWchar))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImWchar>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImWchar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImWchar>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImWchar),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImWchar>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImWchar),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImWchar>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImWchar),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImDrawVert {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawVert,
}
#[test]
fn bindgen_test_layout_ImVector_ImDrawVert() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImDrawVert>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImDrawVert))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImDrawVert>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImDrawVert))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawVert>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawVert),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawVert>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawVert),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawVert>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawVert),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiSettingsHandler {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiSettingsHandler,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiSettingsHandler() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiSettingsHandler>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiSettingsHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiSettingsHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiSettingsHandler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiSettingsHandler>())).Size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiSettingsHandler),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiSettingsHandler>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiSettingsHandler),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiSettingsHandler>())).Data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiSettingsHandler),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImVec4 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImVec4,
}
#[test]
fn bindgen_test_layout_ImVector_ImVec4() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImVec4>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImVec4))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImVec4>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImVec4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImVec4>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImVec4),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImVec4>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImVec4),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImVec4>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImVec4),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiGroupData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiGroupData,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiGroupData() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiGroupData>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiGroupData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiGroupData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiGroupData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiGroupData>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiGroupData),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiGroupData>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiGroupData),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiGroupData>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiGroupData),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiID {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiID,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiID() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiID>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiID))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiID>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiID>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiID),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiID>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiID),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiID>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiID),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiWindowPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImGuiWindow,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiWindowPtr() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiWindowPtr>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiWindowPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiWindowPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiWindowPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiWindowPtr>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiWindowPtr),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiWindowPtr>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiWindowPtr),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiWindowPtr>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiWindowPtr),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiColumnData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiColumnData,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiColumnData() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiColumnData>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiColumnData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiColumnData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiColumnData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColumnData>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColumnData),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiColumnData>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColumnData),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColumnData>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColumnData),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiColumns {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiColumns,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiColumns() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiColumns>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiColumns))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiColumns>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiColumns))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColumns>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColumns),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColumns>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColumns),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColumns>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColumns),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImVec2 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImVec2,
}
#[test]
fn bindgen_test_layout_ImVector_ImVec2() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImVec2>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImVec2))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImVec2>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImVec2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImVec2>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImVec2),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImVec2>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImVec2),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImVec2>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImVec2),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImFontGlyph {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontGlyph,
}
#[test]
fn bindgen_test_layout_ImVector_ImFontGlyph() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImFontGlyph>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImFontGlyph))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImFontGlyph>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImFontGlyph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontGlyph>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontGlyph),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontGlyph>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontGlyph),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontGlyph>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontGlyph),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiTextRange {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTextRange,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiTextRange() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiTextRange>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiTextRange))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiTextRange>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiTextRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTextRange>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTextRange),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiTextRange>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTextRange),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTextRange>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTextRange),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiStoragePair {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiStoragePair,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiStoragePair() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiStoragePair>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiStoragePair))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiStoragePair>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiStoragePair))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiStoragePair>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiStoragePair),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiStoragePair>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiStoragePair),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiStoragePair>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiStoragePair),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiStyleMod {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiStyleMod,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiStyleMod() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiStyleMod>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiStyleMod))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiStyleMod>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiStyleMod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiStyleMod>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiStyleMod),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiStyleMod>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiStyleMod),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiStyleMod>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiStyleMod),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImDrawChannel {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawChannel,
}
#[test]
fn bindgen_test_layout_ImVector_ImDrawChannel() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImDrawChannel>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImDrawChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImDrawChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImDrawChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawChannel>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawChannel),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawChannel>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawChannel),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawChannel>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawChannel),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImDrawListPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImDrawList,
}
#[test]
fn bindgen_test_layout_ImVector_ImDrawListPtr() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImDrawListPtr>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImDrawListPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImDrawListPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImDrawListPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawListPtr>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawListPtr),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawListPtr>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawListPtr),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawListPtr>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawListPtr),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImU32 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImU32,
}
#[test]
fn bindgen_test_layout_ImVector_ImU32() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImU32>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImU32))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImU32>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImU32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImU32>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImU32),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImU32>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImU32),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImU32>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImU32),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiItemFlags {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiItemFlags,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiItemFlags() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiItemFlags>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiItemFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiItemFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiItemFlags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiItemFlags>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiItemFlags),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiItemFlags>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiItemFlags),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiItemFlags>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiItemFlags),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImFontAtlasCustomRect {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontAtlasCustomRect,
}
#[test]
fn bindgen_test_layout_ImVector_ImFontAtlasCustomRect() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImFontAtlasCustomRect>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImFontAtlasCustomRect))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImFontAtlasCustomRect>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImFontAtlasCustomRect))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImFontAtlasCustomRect>())).Size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontAtlasCustomRect),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImFontAtlasCustomRect>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontAtlasCustomRect),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImFontAtlasCustomRect>())).Data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontAtlasCustomRect),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiTabItem {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTabItem,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiTabItem() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiTabItem>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiTabItem))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiTabItem>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiTabItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTabItem>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTabItem),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTabItem>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTabItem),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTabItem>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTabItem),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiShrinkWidthItem {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiShrinkWidthItem,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiShrinkWidthItem() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiShrinkWidthItem>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiShrinkWidthItem))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiShrinkWidthItem>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiShrinkWidthItem))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiShrinkWidthItem>())).Size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiShrinkWidthItem),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiShrinkWidthItem>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiShrinkWidthItem),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiShrinkWidthItem>())).Data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiShrinkWidthItem),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_unsigned_char {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ImVector_unsigned_char() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_unsigned_char>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_unsigned_char))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_unsigned_char>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_unsigned_char))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_unsigned_char>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_unsigned_char),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_unsigned_char>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_unsigned_char),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_unsigned_char>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_unsigned_char),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImTextureID {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImTextureID,
}
#[test]
fn bindgen_test_layout_ImVector_ImTextureID() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImTextureID>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImTextureID))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImTextureID>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImTextureID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImTextureID>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImTextureID),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImTextureID>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImTextureID),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImTextureID>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImTextureID),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImFontPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImFont,
}
#[test]
fn bindgen_test_layout_ImVector_ImFontPtr() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImFontPtr>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImFontPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImFontPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImFontPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontPtr>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontPtr),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontPtr>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontPtr),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontPtr>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontPtr),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImFontConfig {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontConfig,
}
#[test]
fn bindgen_test_layout_ImVector_ImFontConfig() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImFontConfig>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImFontConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImFontConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImFontConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontConfig>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontConfig),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontConfig>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontConfig),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImFontConfig>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImFontConfig),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiColorMod {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiColorMod,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiColorMod() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiColorMod>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiColorMod))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiColorMod>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiColorMod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColorMod>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColorMod),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColorMod>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColorMod),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiColorMod>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiColorMod),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImDrawCmd {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawCmd,
}
#[test]
fn bindgen_test_layout_ImVector_ImDrawCmd() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImDrawCmd>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImDrawCmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImDrawCmd>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImDrawCmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawCmd>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawCmd),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawCmd>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawCmd),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawCmd>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawCmd),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiPtrOrIndex {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiPtrOrIndex,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiPtrOrIndex() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiPtrOrIndex>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiPtrOrIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiPtrOrIndex>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiPtrOrIndex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiPtrOrIndex>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiPtrOrIndex),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiPtrOrIndex>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiPtrOrIndex),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiPtrOrIndex>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiPtrOrIndex),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiPopupData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiPopupData,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiPopupData() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiPopupData>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiPopupData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiPopupData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiPopupData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiPopupData>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiPopupData),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiPopupData>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiPopupData),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiPopupData>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiPopupData),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImDrawIdx {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawIdx,
}
#[test]
fn bindgen_test_layout_ImVector_ImDrawIdx() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImDrawIdx>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImDrawIdx))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImDrawIdx>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImDrawIdx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawIdx>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawIdx),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawIdx>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawIdx),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImDrawIdx>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImDrawIdx),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_char {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ImVector_char() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_char>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_char))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_char>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_char))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_char>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_char),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_char>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_char),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_char>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_char),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiWindowSettings {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiWindowSettings,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiWindowSettings() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiWindowSettings>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiWindowSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiWindowSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiWindowSettings))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiWindowSettings>())).Size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiWindowSettings),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiWindowSettings>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiWindowSettings),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImVector_ImGuiWindowSettings>())).Data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiWindowSettings),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImChunkStream_ImGuiWindowSettings {
    pub Buf: ImVector_ImGuiWindowSettings,
}
#[test]
fn bindgen_test_layout_ImChunkStream_ImGuiWindowSettings() {
    assert_eq!(
        ::std::mem::size_of::<ImChunkStream_ImGuiWindowSettings>(),
        16usize,
        concat!("Size of: ", stringify!(ImChunkStream_ImGuiWindowSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<ImChunkStream_ImGuiWindowSettings>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ImChunkStream_ImGuiWindowSettings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImChunkStream_ImGuiWindowSettings>())).Buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImChunkStream_ImGuiWindowSettings),
            "::",
            stringify!(Buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StbUndoRecord {
    pub where_: ::std::os::raw::c_int,
    pub insert_length: ::std::os::raw::c_int,
    pub delete_length: ::std::os::raw::c_int,
    pub char_storage: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StbUndoRecord() {
    assert_eq!(
        ::std::mem::size_of::<StbUndoRecord>(),
        16usize,
        concat!("Size of: ", stringify!(StbUndoRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<StbUndoRecord>(),
        4usize,
        concat!("Alignment of ", stringify!(StbUndoRecord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoRecord>())).where_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoRecord),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoRecord>())).insert_length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoRecord),
            "::",
            stringify!(insert_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoRecord>())).delete_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoRecord),
            "::",
            stringify!(delete_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoRecord>())).char_storage as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoRecord),
            "::",
            stringify!(char_storage)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StbUndoState {
    pub undo_rec: [StbUndoRecord; 99usize],
    pub undo_char: [ImWchar; 999usize],
    pub undo_point: ::std::os::raw::c_short,
    pub redo_point: ::std::os::raw::c_short,
    pub undo_char_point: ::std::os::raw::c_int,
    pub redo_char_point: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StbUndoState() {
    assert_eq!(
        ::std::mem::size_of::<StbUndoState>(),
        3596usize,
        concat!("Size of: ", stringify!(StbUndoState))
    );
    assert_eq!(
        ::std::mem::align_of::<StbUndoState>(),
        4usize,
        concat!("Alignment of ", stringify!(StbUndoState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoState>())).undo_rec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoState),
            "::",
            stringify!(undo_rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoState>())).undo_char as *const _ as usize },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoState),
            "::",
            stringify!(undo_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoState>())).undo_point as *const _ as usize },
        3582usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoState),
            "::",
            stringify!(undo_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoState>())).redo_point as *const _ as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoState),
            "::",
            stringify!(redo_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoState>())).undo_char_point as *const _ as usize },
        3588usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoState),
            "::",
            stringify!(undo_char_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbUndoState>())).redo_char_point as *const _ as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(StbUndoState),
            "::",
            stringify!(redo_char_point)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STB_TexteditState {
    pub cursor: ::std::os::raw::c_int,
    pub select_start: ::std::os::raw::c_int,
    pub select_end: ::std::os::raw::c_int,
    pub insert_mode: ::std::os::raw::c_uchar,
    pub cursor_at_end_of_line: ::std::os::raw::c_uchar,
    pub initialized: ::std::os::raw::c_uchar,
    pub has_preferred_x: ::std::os::raw::c_uchar,
    pub single_line: ::std::os::raw::c_uchar,
    pub padding1: ::std::os::raw::c_uchar,
    pub padding2: ::std::os::raw::c_uchar,
    pub padding3: ::std::os::raw::c_uchar,
    pub preferred_x: f32,
    pub undostate: StbUndoState,
}
#[test]
fn bindgen_test_layout_STB_TexteditState() {
    assert_eq!(
        ::std::mem::size_of::<STB_TexteditState>(),
        3620usize,
        concat!("Size of: ", stringify!(STB_TexteditState))
    );
    assert_eq!(
        ::std::mem::align_of::<STB_TexteditState>(),
        4usize,
        concat!("Alignment of ", stringify!(STB_TexteditState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).cursor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).select_start as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(select_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).select_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(select_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).insert_mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(insert_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STB_TexteditState>())).cursor_at_end_of_line as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(cursor_at_end_of_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).initialized as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STB_TexteditState>())).has_preferred_x as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(has_preferred_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).single_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(single_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).padding1 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).padding2 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).padding3 as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).preferred_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(preferred_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STB_TexteditState>())).undostate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(STB_TexteditState),
            "::",
            stringify!(undostate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StbTexteditRow {
    pub x0: f32,
    pub x1: f32,
    pub baseline_y_delta: f32,
    pub ymin: f32,
    pub ymax: f32,
    pub num_chars: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StbTexteditRow() {
    assert_eq!(
        ::std::mem::size_of::<StbTexteditRow>(),
        24usize,
        concat!("Size of: ", stringify!(StbTexteditRow))
    );
    assert_eq!(
        ::std::mem::align_of::<StbTexteditRow>(),
        4usize,
        concat!("Alignment of ", stringify!(StbTexteditRow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbTexteditRow>())).x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StbTexteditRow),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbTexteditRow>())).x1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StbTexteditRow),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbTexteditRow>())).baseline_y_delta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StbTexteditRow),
            "::",
            stringify!(baseline_y_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbTexteditRow>())).ymin as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(StbTexteditRow),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbTexteditRow>())).ymax as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StbTexteditRow),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StbTexteditRow>())).num_chars as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(StbTexteditRow),
            "::",
            stringify!(num_chars)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVec2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_ImVec2() {
    assert_eq!(
        ::std::mem::size_of::<ImVec2>(),
        8usize,
        concat!("Size of: ", stringify!(ImVec2))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVec2>(),
        4usize,
        concat!("Alignment of ", stringify!(ImVec2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ImVec2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ImVec2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ImVec4() {
    assert_eq!(
        ::std::mem::size_of::<ImVec4>(),
        16usize,
        concat!("Size of: ", stringify!(ImVec4))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVec4>(),
        4usize,
        concat!("Alignment of ", stringify!(ImVec4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ImVec4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ImVec4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ImVec4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(ImVec4), "::", stringify!(w))
    );
}
pub const ImGuiWindowFlags__ImGuiWindowFlags_None: ImGuiWindowFlags_ = 0;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoTitleBar: ImGuiWindowFlags_ = 1;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoResize: ImGuiWindowFlags_ = 2;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoMove: ImGuiWindowFlags_ = 4;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoScrollbar: ImGuiWindowFlags_ = 8;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoScrollWithMouse: ImGuiWindowFlags_ = 16;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoCollapse: ImGuiWindowFlags_ = 32;
pub const ImGuiWindowFlags__ImGuiWindowFlags_AlwaysAutoResize: ImGuiWindowFlags_ = 64;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoBackground: ImGuiWindowFlags_ = 128;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoSavedSettings: ImGuiWindowFlags_ = 256;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoMouseInputs: ImGuiWindowFlags_ = 512;
pub const ImGuiWindowFlags__ImGuiWindowFlags_MenuBar: ImGuiWindowFlags_ = 1024;
pub const ImGuiWindowFlags__ImGuiWindowFlags_HorizontalScrollbar: ImGuiWindowFlags_ = 2048;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoFocusOnAppearing: ImGuiWindowFlags_ = 4096;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoBringToFrontOnFocus: ImGuiWindowFlags_ = 8192;
pub const ImGuiWindowFlags__ImGuiWindowFlags_AlwaysVerticalScrollbar: ImGuiWindowFlags_ = 16384;
pub const ImGuiWindowFlags__ImGuiWindowFlags_AlwaysHorizontalScrollbar: ImGuiWindowFlags_ = 32768;
pub const ImGuiWindowFlags__ImGuiWindowFlags_AlwaysUseWindowPadding: ImGuiWindowFlags_ = 65536;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoNavInputs: ImGuiWindowFlags_ = 262144;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoNavFocus: ImGuiWindowFlags_ = 524288;
pub const ImGuiWindowFlags__ImGuiWindowFlags_UnsavedDocument: ImGuiWindowFlags_ = 1048576;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoNav: ImGuiWindowFlags_ = 786432;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoDecoration: ImGuiWindowFlags_ = 43;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NoInputs: ImGuiWindowFlags_ = 786944;
pub const ImGuiWindowFlags__ImGuiWindowFlags_NavFlattened: ImGuiWindowFlags_ = 8388608;
pub const ImGuiWindowFlags__ImGuiWindowFlags_ChildWindow: ImGuiWindowFlags_ = 16777216;
pub const ImGuiWindowFlags__ImGuiWindowFlags_Tooltip: ImGuiWindowFlags_ = 33554432;
pub const ImGuiWindowFlags__ImGuiWindowFlags_Popup: ImGuiWindowFlags_ = 67108864;
pub const ImGuiWindowFlags__ImGuiWindowFlags_Modal: ImGuiWindowFlags_ = 134217728;
pub const ImGuiWindowFlags__ImGuiWindowFlags_ChildMenu: ImGuiWindowFlags_ = 268435456;
pub type ImGuiWindowFlags_ = u32;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_None: ImGuiInputTextFlags_ = 0;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CharsDecimal: ImGuiInputTextFlags_ = 1;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CharsHexadecimal: ImGuiInputTextFlags_ = 2;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CharsUppercase: ImGuiInputTextFlags_ = 4;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CharsNoBlank: ImGuiInputTextFlags_ = 8;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_AutoSelectAll: ImGuiInputTextFlags_ = 16;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_EnterReturnsTrue: ImGuiInputTextFlags_ = 32;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CallbackCompletion: ImGuiInputTextFlags_ = 64;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CallbackHistory: ImGuiInputTextFlags_ = 128;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CallbackAlways: ImGuiInputTextFlags_ = 256;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CallbackCharFilter: ImGuiInputTextFlags_ = 512;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_AllowTabInput: ImGuiInputTextFlags_ = 1024;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CtrlEnterForNewLine: ImGuiInputTextFlags_ = 2048;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_NoHorizontalScroll: ImGuiInputTextFlags_ = 4096;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_AlwaysInsertMode: ImGuiInputTextFlags_ = 8192;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_ReadOnly: ImGuiInputTextFlags_ = 16384;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_Password: ImGuiInputTextFlags_ = 32768;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_NoUndoRedo: ImGuiInputTextFlags_ = 65536;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CharsScientific: ImGuiInputTextFlags_ = 131072;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_CallbackResize: ImGuiInputTextFlags_ = 262144;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_Multiline: ImGuiInputTextFlags_ = 1048576;
pub const ImGuiInputTextFlags__ImGuiInputTextFlags_NoMarkEdited: ImGuiInputTextFlags_ = 2097152;
pub type ImGuiInputTextFlags_ = u32;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_None: ImGuiTreeNodeFlags_ = 0;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_Selected: ImGuiTreeNodeFlags_ = 1;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_Framed: ImGuiTreeNodeFlags_ = 2;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_AllowItemOverlap: ImGuiTreeNodeFlags_ = 4;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_NoTreePushOnOpen: ImGuiTreeNodeFlags_ = 8;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_NoAutoOpenOnLog: ImGuiTreeNodeFlags_ = 16;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_DefaultOpen: ImGuiTreeNodeFlags_ = 32;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_OpenOnDoubleClick: ImGuiTreeNodeFlags_ = 64;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_OpenOnArrow: ImGuiTreeNodeFlags_ = 128;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_Leaf: ImGuiTreeNodeFlags_ = 256;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_Bullet: ImGuiTreeNodeFlags_ = 512;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_FramePadding: ImGuiTreeNodeFlags_ = 1024;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_SpanAvailWidth: ImGuiTreeNodeFlags_ = 2048;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_SpanFullWidth: ImGuiTreeNodeFlags_ = 4096;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_NavLeftJumpsBackHere: ImGuiTreeNodeFlags_ = 8192;
pub const ImGuiTreeNodeFlags__ImGuiTreeNodeFlags_CollapsingHeader: ImGuiTreeNodeFlags_ = 26;
pub type ImGuiTreeNodeFlags_ = u32;
pub const ImGuiSelectableFlags__ImGuiSelectableFlags_None: ImGuiSelectableFlags_ = 0;
pub const ImGuiSelectableFlags__ImGuiSelectableFlags_DontClosePopups: ImGuiSelectableFlags_ = 1;
pub const ImGuiSelectableFlags__ImGuiSelectableFlags_SpanAllColumns: ImGuiSelectableFlags_ = 2;
pub const ImGuiSelectableFlags__ImGuiSelectableFlags_AllowDoubleClick: ImGuiSelectableFlags_ = 4;
pub const ImGuiSelectableFlags__ImGuiSelectableFlags_Disabled: ImGuiSelectableFlags_ = 8;
pub const ImGuiSelectableFlags__ImGuiSelectableFlags_AllowItemOverlap: ImGuiSelectableFlags_ = 16;
pub type ImGuiSelectableFlags_ = u32;
pub const ImGuiComboFlags__ImGuiComboFlags_None: ImGuiComboFlags_ = 0;
pub const ImGuiComboFlags__ImGuiComboFlags_PopupAlignLeft: ImGuiComboFlags_ = 1;
pub const ImGuiComboFlags__ImGuiComboFlags_HeightSmall: ImGuiComboFlags_ = 2;
pub const ImGuiComboFlags__ImGuiComboFlags_HeightRegular: ImGuiComboFlags_ = 4;
pub const ImGuiComboFlags__ImGuiComboFlags_HeightLarge: ImGuiComboFlags_ = 8;
pub const ImGuiComboFlags__ImGuiComboFlags_HeightLargest: ImGuiComboFlags_ = 16;
pub const ImGuiComboFlags__ImGuiComboFlags_NoArrowButton: ImGuiComboFlags_ = 32;
pub const ImGuiComboFlags__ImGuiComboFlags_NoPreview: ImGuiComboFlags_ = 64;
pub const ImGuiComboFlags__ImGuiComboFlags_HeightMask_: ImGuiComboFlags_ = 30;
pub type ImGuiComboFlags_ = u32;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_None: ImGuiTabBarFlags_ = 0;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_Reorderable: ImGuiTabBarFlags_ = 1;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_AutoSelectNewTabs: ImGuiTabBarFlags_ = 2;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_TabListPopupButton: ImGuiTabBarFlags_ = 4;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_NoCloseWithMiddleMouseButton: ImGuiTabBarFlags_ = 8;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_NoTabListScrollingButtons: ImGuiTabBarFlags_ = 16;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_NoTooltip: ImGuiTabBarFlags_ = 32;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_FittingPolicyResizeDown: ImGuiTabBarFlags_ = 64;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_FittingPolicyScroll: ImGuiTabBarFlags_ = 128;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_FittingPolicyMask_: ImGuiTabBarFlags_ = 192;
pub const ImGuiTabBarFlags__ImGuiTabBarFlags_FittingPolicyDefault_: ImGuiTabBarFlags_ = 64;
pub type ImGuiTabBarFlags_ = u32;
pub const ImGuiTabItemFlags__ImGuiTabItemFlags_None: ImGuiTabItemFlags_ = 0;
pub const ImGuiTabItemFlags__ImGuiTabItemFlags_UnsavedDocument: ImGuiTabItemFlags_ = 1;
pub const ImGuiTabItemFlags__ImGuiTabItemFlags_SetSelected: ImGuiTabItemFlags_ = 2;
pub const ImGuiTabItemFlags__ImGuiTabItemFlags_NoCloseWithMiddleMouseButton: ImGuiTabItemFlags_ = 4;
pub const ImGuiTabItemFlags__ImGuiTabItemFlags_NoPushId: ImGuiTabItemFlags_ = 8;
pub type ImGuiTabItemFlags_ = u32;
pub const ImGuiFocusedFlags__ImGuiFocusedFlags_None: ImGuiFocusedFlags_ = 0;
pub const ImGuiFocusedFlags__ImGuiFocusedFlags_ChildWindows: ImGuiFocusedFlags_ = 1;
pub const ImGuiFocusedFlags__ImGuiFocusedFlags_RootWindow: ImGuiFocusedFlags_ = 2;
pub const ImGuiFocusedFlags__ImGuiFocusedFlags_AnyWindow: ImGuiFocusedFlags_ = 4;
pub const ImGuiFocusedFlags__ImGuiFocusedFlags_RootAndChildWindows: ImGuiFocusedFlags_ = 3;
pub type ImGuiFocusedFlags_ = u32;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_None: ImGuiHoveredFlags_ = 0;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_ChildWindows: ImGuiHoveredFlags_ = 1;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_RootWindow: ImGuiHoveredFlags_ = 2;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_AnyWindow: ImGuiHoveredFlags_ = 4;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_AllowWhenBlockedByPopup: ImGuiHoveredFlags_ = 8;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_AllowWhenBlockedByActiveItem: ImGuiHoveredFlags_ =
    32;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_AllowWhenOverlapped: ImGuiHoveredFlags_ = 64;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_AllowWhenDisabled: ImGuiHoveredFlags_ = 128;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_RectOnly: ImGuiHoveredFlags_ = 104;
pub const ImGuiHoveredFlags__ImGuiHoveredFlags_RootAndChildWindows: ImGuiHoveredFlags_ = 3;
pub type ImGuiHoveredFlags_ = u32;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_None: ImGuiDragDropFlags_ = 0;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_SourceNoPreviewTooltip: ImGuiDragDropFlags_ = 1;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_SourceNoDisableHover: ImGuiDragDropFlags_ = 2;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_SourceNoHoldToOpenOthers: ImGuiDragDropFlags_ = 4;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_SourceAllowNullID: ImGuiDragDropFlags_ = 8;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_SourceExtern: ImGuiDragDropFlags_ = 16;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_SourceAutoExpirePayload: ImGuiDragDropFlags_ = 32;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_AcceptBeforeDelivery: ImGuiDragDropFlags_ = 1024;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_AcceptNoDrawDefaultRect: ImGuiDragDropFlags_ =
    2048;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_AcceptNoPreviewTooltip: ImGuiDragDropFlags_ = 4096;
pub const ImGuiDragDropFlags__ImGuiDragDropFlags_AcceptPeekOnly: ImGuiDragDropFlags_ = 3072;
pub type ImGuiDragDropFlags_ = u32;
pub const ImGuiDataType__ImGuiDataType_S8: ImGuiDataType_ = 0;
pub const ImGuiDataType__ImGuiDataType_U8: ImGuiDataType_ = 1;
pub const ImGuiDataType__ImGuiDataType_S16: ImGuiDataType_ = 2;
pub const ImGuiDataType__ImGuiDataType_U16: ImGuiDataType_ = 3;
pub const ImGuiDataType__ImGuiDataType_S32: ImGuiDataType_ = 4;
pub const ImGuiDataType__ImGuiDataType_U32: ImGuiDataType_ = 5;
pub const ImGuiDataType__ImGuiDataType_S64: ImGuiDataType_ = 6;
pub const ImGuiDataType__ImGuiDataType_U64: ImGuiDataType_ = 7;
pub const ImGuiDataType__ImGuiDataType_Float: ImGuiDataType_ = 8;
pub const ImGuiDataType__ImGuiDataType_Double: ImGuiDataType_ = 9;
pub const ImGuiDataType__ImGuiDataType_COUNT: ImGuiDataType_ = 10;
pub type ImGuiDataType_ = u32;
pub const ImGuiDir__ImGuiDir_None: ImGuiDir_ = -1;
pub const ImGuiDir__ImGuiDir_Left: ImGuiDir_ = 0;
pub const ImGuiDir__ImGuiDir_Right: ImGuiDir_ = 1;
pub const ImGuiDir__ImGuiDir_Up: ImGuiDir_ = 2;
pub const ImGuiDir__ImGuiDir_Down: ImGuiDir_ = 3;
pub const ImGuiDir__ImGuiDir_COUNT: ImGuiDir_ = 4;
pub type ImGuiDir_ = i32;
pub const ImGuiKey__ImGuiKey_Tab: ImGuiKey_ = 0;
pub const ImGuiKey__ImGuiKey_LeftArrow: ImGuiKey_ = 1;
pub const ImGuiKey__ImGuiKey_RightArrow: ImGuiKey_ = 2;
pub const ImGuiKey__ImGuiKey_UpArrow: ImGuiKey_ = 3;
pub const ImGuiKey__ImGuiKey_DownArrow: ImGuiKey_ = 4;
pub const ImGuiKey__ImGuiKey_PageUp: ImGuiKey_ = 5;
pub const ImGuiKey__ImGuiKey_PageDown: ImGuiKey_ = 6;
pub const ImGuiKey__ImGuiKey_Home: ImGuiKey_ = 7;
pub const ImGuiKey__ImGuiKey_End: ImGuiKey_ = 8;
pub const ImGuiKey__ImGuiKey_Insert: ImGuiKey_ = 9;
pub const ImGuiKey__ImGuiKey_Delete: ImGuiKey_ = 10;
pub const ImGuiKey__ImGuiKey_Backspace: ImGuiKey_ = 11;
pub const ImGuiKey__ImGuiKey_Space: ImGuiKey_ = 12;
pub const ImGuiKey__ImGuiKey_Enter: ImGuiKey_ = 13;
pub const ImGuiKey__ImGuiKey_Escape: ImGuiKey_ = 14;
pub const ImGuiKey__ImGuiKey_KeyPadEnter: ImGuiKey_ = 15;
pub const ImGuiKey__ImGuiKey_A: ImGuiKey_ = 16;
pub const ImGuiKey__ImGuiKey_C: ImGuiKey_ = 17;
pub const ImGuiKey__ImGuiKey_V: ImGuiKey_ = 18;
pub const ImGuiKey__ImGuiKey_X: ImGuiKey_ = 19;
pub const ImGuiKey__ImGuiKey_Y: ImGuiKey_ = 20;
pub const ImGuiKey__ImGuiKey_Z: ImGuiKey_ = 21;
pub const ImGuiKey__ImGuiKey_COUNT: ImGuiKey_ = 22;
pub type ImGuiKey_ = u32;
pub const ImGuiKeyModFlags__ImGuiKeyModFlags_None: ImGuiKeyModFlags_ = 0;
pub const ImGuiKeyModFlags__ImGuiKeyModFlags_Ctrl: ImGuiKeyModFlags_ = 1;
pub const ImGuiKeyModFlags__ImGuiKeyModFlags_Shift: ImGuiKeyModFlags_ = 2;
pub const ImGuiKeyModFlags__ImGuiKeyModFlags_Alt: ImGuiKeyModFlags_ = 4;
pub const ImGuiKeyModFlags__ImGuiKeyModFlags_Super: ImGuiKeyModFlags_ = 8;
pub type ImGuiKeyModFlags_ = u32;
pub const ImGuiNavInput__ImGuiNavInput_Activate: ImGuiNavInput_ = 0;
pub const ImGuiNavInput__ImGuiNavInput_Cancel: ImGuiNavInput_ = 1;
pub const ImGuiNavInput__ImGuiNavInput_Input: ImGuiNavInput_ = 2;
pub const ImGuiNavInput__ImGuiNavInput_Menu: ImGuiNavInput_ = 3;
pub const ImGuiNavInput__ImGuiNavInput_DpadLeft: ImGuiNavInput_ = 4;
pub const ImGuiNavInput__ImGuiNavInput_DpadRight: ImGuiNavInput_ = 5;
pub const ImGuiNavInput__ImGuiNavInput_DpadUp: ImGuiNavInput_ = 6;
pub const ImGuiNavInput__ImGuiNavInput_DpadDown: ImGuiNavInput_ = 7;
pub const ImGuiNavInput__ImGuiNavInput_LStickLeft: ImGuiNavInput_ = 8;
pub const ImGuiNavInput__ImGuiNavInput_LStickRight: ImGuiNavInput_ = 9;
pub const ImGuiNavInput__ImGuiNavInput_LStickUp: ImGuiNavInput_ = 10;
pub const ImGuiNavInput__ImGuiNavInput_LStickDown: ImGuiNavInput_ = 11;
pub const ImGuiNavInput__ImGuiNavInput_FocusPrev: ImGuiNavInput_ = 12;
pub const ImGuiNavInput__ImGuiNavInput_FocusNext: ImGuiNavInput_ = 13;
pub const ImGuiNavInput__ImGuiNavInput_TweakSlow: ImGuiNavInput_ = 14;
pub const ImGuiNavInput__ImGuiNavInput_TweakFast: ImGuiNavInput_ = 15;
pub const ImGuiNavInput__ImGuiNavInput_KeyMenu_: ImGuiNavInput_ = 16;
pub const ImGuiNavInput__ImGuiNavInput_KeyLeft_: ImGuiNavInput_ = 17;
pub const ImGuiNavInput__ImGuiNavInput_KeyRight_: ImGuiNavInput_ = 18;
pub const ImGuiNavInput__ImGuiNavInput_KeyUp_: ImGuiNavInput_ = 19;
pub const ImGuiNavInput__ImGuiNavInput_KeyDown_: ImGuiNavInput_ = 20;
pub const ImGuiNavInput__ImGuiNavInput_COUNT: ImGuiNavInput_ = 21;
pub const ImGuiNavInput__ImGuiNavInput_InternalStart_: ImGuiNavInput_ = 16;
pub type ImGuiNavInput_ = u32;
pub const ImGuiConfigFlags__ImGuiConfigFlags_None: ImGuiConfigFlags_ = 0;
pub const ImGuiConfigFlags__ImGuiConfigFlags_NavEnableKeyboard: ImGuiConfigFlags_ = 1;
pub const ImGuiConfigFlags__ImGuiConfigFlags_NavEnableGamepad: ImGuiConfigFlags_ = 2;
pub const ImGuiConfigFlags__ImGuiConfigFlags_NavEnableSetMousePos: ImGuiConfigFlags_ = 4;
pub const ImGuiConfigFlags__ImGuiConfigFlags_NavNoCaptureKeyboard: ImGuiConfigFlags_ = 8;
pub const ImGuiConfigFlags__ImGuiConfigFlags_NoMouse: ImGuiConfigFlags_ = 16;
pub const ImGuiConfigFlags__ImGuiConfigFlags_NoMouseCursorChange: ImGuiConfigFlags_ = 32;
pub const ImGuiConfigFlags__ImGuiConfigFlags_IsSRGB: ImGuiConfigFlags_ = 1048576;
pub const ImGuiConfigFlags__ImGuiConfigFlags_IsTouchScreen: ImGuiConfigFlags_ = 2097152;
pub type ImGuiConfigFlags_ = u32;
pub const ImGuiBackendFlags__ImGuiBackendFlags_None: ImGuiBackendFlags_ = 0;
pub const ImGuiBackendFlags__ImGuiBackendFlags_HasGamepad: ImGuiBackendFlags_ = 1;
pub const ImGuiBackendFlags__ImGuiBackendFlags_HasMouseCursors: ImGuiBackendFlags_ = 2;
pub const ImGuiBackendFlags__ImGuiBackendFlags_HasSetMousePos: ImGuiBackendFlags_ = 4;
pub const ImGuiBackendFlags__ImGuiBackendFlags_RendererHasVtxOffset: ImGuiBackendFlags_ = 8;
pub type ImGuiBackendFlags_ = u32;
pub const ImGuiCol__ImGuiCol_Text: ImGuiCol_ = 0;
pub const ImGuiCol__ImGuiCol_TextDisabled: ImGuiCol_ = 1;
pub const ImGuiCol__ImGuiCol_WindowBg: ImGuiCol_ = 2;
pub const ImGuiCol__ImGuiCol_ChildBg: ImGuiCol_ = 3;
pub const ImGuiCol__ImGuiCol_PopupBg: ImGuiCol_ = 4;
pub const ImGuiCol__ImGuiCol_Border: ImGuiCol_ = 5;
pub const ImGuiCol__ImGuiCol_BorderShadow: ImGuiCol_ = 6;
pub const ImGuiCol__ImGuiCol_FrameBg: ImGuiCol_ = 7;
pub const ImGuiCol__ImGuiCol_FrameBgHovered: ImGuiCol_ = 8;
pub const ImGuiCol__ImGuiCol_FrameBgActive: ImGuiCol_ = 9;
pub const ImGuiCol__ImGuiCol_TitleBg: ImGuiCol_ = 10;
pub const ImGuiCol__ImGuiCol_TitleBgActive: ImGuiCol_ = 11;
pub const ImGuiCol__ImGuiCol_TitleBgCollapsed: ImGuiCol_ = 12;
pub const ImGuiCol__ImGuiCol_MenuBarBg: ImGuiCol_ = 13;
pub const ImGuiCol__ImGuiCol_ScrollbarBg: ImGuiCol_ = 14;
pub const ImGuiCol__ImGuiCol_ScrollbarGrab: ImGuiCol_ = 15;
pub const ImGuiCol__ImGuiCol_ScrollbarGrabHovered: ImGuiCol_ = 16;
pub const ImGuiCol__ImGuiCol_ScrollbarGrabActive: ImGuiCol_ = 17;
pub const ImGuiCol__ImGuiCol_CheckMark: ImGuiCol_ = 18;
pub const ImGuiCol__ImGuiCol_SliderGrab: ImGuiCol_ = 19;
pub const ImGuiCol__ImGuiCol_SliderGrabActive: ImGuiCol_ = 20;
pub const ImGuiCol__ImGuiCol_Button: ImGuiCol_ = 21;
pub const ImGuiCol__ImGuiCol_ButtonHovered: ImGuiCol_ = 22;
pub const ImGuiCol__ImGuiCol_ButtonActive: ImGuiCol_ = 23;
pub const ImGuiCol__ImGuiCol_Header: ImGuiCol_ = 24;
pub const ImGuiCol__ImGuiCol_HeaderHovered: ImGuiCol_ = 25;
pub const ImGuiCol__ImGuiCol_HeaderActive: ImGuiCol_ = 26;
pub const ImGuiCol__ImGuiCol_Separator: ImGuiCol_ = 27;
pub const ImGuiCol__ImGuiCol_SeparatorHovered: ImGuiCol_ = 28;
pub const ImGuiCol__ImGuiCol_SeparatorActive: ImGuiCol_ = 29;
pub const ImGuiCol__ImGuiCol_ResizeGrip: ImGuiCol_ = 30;
pub const ImGuiCol__ImGuiCol_ResizeGripHovered: ImGuiCol_ = 31;
pub const ImGuiCol__ImGuiCol_ResizeGripActive: ImGuiCol_ = 32;
pub const ImGuiCol__ImGuiCol_Tab: ImGuiCol_ = 33;
pub const ImGuiCol__ImGuiCol_TabHovered: ImGuiCol_ = 34;
pub const ImGuiCol__ImGuiCol_TabActive: ImGuiCol_ = 35;
pub const ImGuiCol__ImGuiCol_TabUnfocused: ImGuiCol_ = 36;
pub const ImGuiCol__ImGuiCol_TabUnfocusedActive: ImGuiCol_ = 37;
pub const ImGuiCol__ImGuiCol_PlotLines: ImGuiCol_ = 38;
pub const ImGuiCol__ImGuiCol_PlotLinesHovered: ImGuiCol_ = 39;
pub const ImGuiCol__ImGuiCol_PlotHistogram: ImGuiCol_ = 40;
pub const ImGuiCol__ImGuiCol_PlotHistogramHovered: ImGuiCol_ = 41;
pub const ImGuiCol__ImGuiCol_TextSelectedBg: ImGuiCol_ = 42;
pub const ImGuiCol__ImGuiCol_DragDropTarget: ImGuiCol_ = 43;
pub const ImGuiCol__ImGuiCol_NavHighlight: ImGuiCol_ = 44;
pub const ImGuiCol__ImGuiCol_NavWindowingHighlight: ImGuiCol_ = 45;
pub const ImGuiCol__ImGuiCol_NavWindowingDimBg: ImGuiCol_ = 46;
pub const ImGuiCol__ImGuiCol_ModalWindowDimBg: ImGuiCol_ = 47;
pub const ImGuiCol__ImGuiCol_COUNT: ImGuiCol_ = 48;
pub type ImGuiCol_ = u32;
pub const ImGuiStyleVar__ImGuiStyleVar_Alpha: ImGuiStyleVar_ = 0;
pub const ImGuiStyleVar__ImGuiStyleVar_WindowPadding: ImGuiStyleVar_ = 1;
pub const ImGuiStyleVar__ImGuiStyleVar_WindowRounding: ImGuiStyleVar_ = 2;
pub const ImGuiStyleVar__ImGuiStyleVar_WindowBorderSize: ImGuiStyleVar_ = 3;
pub const ImGuiStyleVar__ImGuiStyleVar_WindowMinSize: ImGuiStyleVar_ = 4;
pub const ImGuiStyleVar__ImGuiStyleVar_WindowTitleAlign: ImGuiStyleVar_ = 5;
pub const ImGuiStyleVar__ImGuiStyleVar_ChildRounding: ImGuiStyleVar_ = 6;
pub const ImGuiStyleVar__ImGuiStyleVar_ChildBorderSize: ImGuiStyleVar_ = 7;
pub const ImGuiStyleVar__ImGuiStyleVar_PopupRounding: ImGuiStyleVar_ = 8;
pub const ImGuiStyleVar__ImGuiStyleVar_PopupBorderSize: ImGuiStyleVar_ = 9;
pub const ImGuiStyleVar__ImGuiStyleVar_FramePadding: ImGuiStyleVar_ = 10;
pub const ImGuiStyleVar__ImGuiStyleVar_FrameRounding: ImGuiStyleVar_ = 11;
pub const ImGuiStyleVar__ImGuiStyleVar_FrameBorderSize: ImGuiStyleVar_ = 12;
pub const ImGuiStyleVar__ImGuiStyleVar_ItemSpacing: ImGuiStyleVar_ = 13;
pub const ImGuiStyleVar__ImGuiStyleVar_ItemInnerSpacing: ImGuiStyleVar_ = 14;
pub const ImGuiStyleVar__ImGuiStyleVar_IndentSpacing: ImGuiStyleVar_ = 15;
pub const ImGuiStyleVar__ImGuiStyleVar_ScrollbarSize: ImGuiStyleVar_ = 16;
pub const ImGuiStyleVar__ImGuiStyleVar_ScrollbarRounding: ImGuiStyleVar_ = 17;
pub const ImGuiStyleVar__ImGuiStyleVar_GrabMinSize: ImGuiStyleVar_ = 18;
pub const ImGuiStyleVar__ImGuiStyleVar_GrabRounding: ImGuiStyleVar_ = 19;
pub const ImGuiStyleVar__ImGuiStyleVar_TabRounding: ImGuiStyleVar_ = 20;
pub const ImGuiStyleVar__ImGuiStyleVar_ButtonTextAlign: ImGuiStyleVar_ = 21;
pub const ImGuiStyleVar__ImGuiStyleVar_SelectableTextAlign: ImGuiStyleVar_ = 22;
pub const ImGuiStyleVar__ImGuiStyleVar_COUNT: ImGuiStyleVar_ = 23;
pub type ImGuiStyleVar_ = u32;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_None: ImGuiColorEditFlags_ = 0;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoAlpha: ImGuiColorEditFlags_ = 2;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoPicker: ImGuiColorEditFlags_ = 4;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoOptions: ImGuiColorEditFlags_ = 8;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoSmallPreview: ImGuiColorEditFlags_ = 16;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoInputs: ImGuiColorEditFlags_ = 32;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoTooltip: ImGuiColorEditFlags_ = 64;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoLabel: ImGuiColorEditFlags_ = 128;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoSidePreview: ImGuiColorEditFlags_ = 256;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoDragDrop: ImGuiColorEditFlags_ = 512;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_NoBorder: ImGuiColorEditFlags_ = 1024;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_AlphaBar: ImGuiColorEditFlags_ = 65536;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_AlphaPreview: ImGuiColorEditFlags_ = 131072;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_AlphaPreviewHalf: ImGuiColorEditFlags_ = 262144;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_HDR: ImGuiColorEditFlags_ = 524288;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_DisplayRGB: ImGuiColorEditFlags_ = 1048576;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_DisplayHSV: ImGuiColorEditFlags_ = 2097152;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_DisplayHex: ImGuiColorEditFlags_ = 4194304;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_Uint8: ImGuiColorEditFlags_ = 8388608;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_Float: ImGuiColorEditFlags_ = 16777216;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_PickerHueBar: ImGuiColorEditFlags_ = 33554432;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_PickerHueWheel: ImGuiColorEditFlags_ = 67108864;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_InputRGB: ImGuiColorEditFlags_ = 134217728;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags_InputHSV: ImGuiColorEditFlags_ = 268435456;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags__OptionsDefault: ImGuiColorEditFlags_ =
    177209344;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags__DisplayMask: ImGuiColorEditFlags_ = 7340032;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags__DataTypeMask: ImGuiColorEditFlags_ = 25165824;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags__PickerMask: ImGuiColorEditFlags_ = 100663296;
pub const ImGuiColorEditFlags__ImGuiColorEditFlags__InputMask: ImGuiColorEditFlags_ = 402653184;
pub type ImGuiColorEditFlags_ = u32;
pub const ImGuiMouseButton__ImGuiMouseButton_Left: ImGuiMouseButton_ = 0;
pub const ImGuiMouseButton__ImGuiMouseButton_Right: ImGuiMouseButton_ = 1;
pub const ImGuiMouseButton__ImGuiMouseButton_Middle: ImGuiMouseButton_ = 2;
pub const ImGuiMouseButton__ImGuiMouseButton_COUNT: ImGuiMouseButton_ = 5;
pub type ImGuiMouseButton_ = u32;
pub const ImGuiMouseCursor__ImGuiMouseCursor_None: ImGuiMouseCursor_ = -1;
pub const ImGuiMouseCursor__ImGuiMouseCursor_Arrow: ImGuiMouseCursor_ = 0;
pub const ImGuiMouseCursor__ImGuiMouseCursor_TextInput: ImGuiMouseCursor_ = 1;
pub const ImGuiMouseCursor__ImGuiMouseCursor_ResizeAll: ImGuiMouseCursor_ = 2;
pub const ImGuiMouseCursor__ImGuiMouseCursor_ResizeNS: ImGuiMouseCursor_ = 3;
pub const ImGuiMouseCursor__ImGuiMouseCursor_ResizeEW: ImGuiMouseCursor_ = 4;
pub const ImGuiMouseCursor__ImGuiMouseCursor_ResizeNESW: ImGuiMouseCursor_ = 5;
pub const ImGuiMouseCursor__ImGuiMouseCursor_ResizeNWSE: ImGuiMouseCursor_ = 6;
pub const ImGuiMouseCursor__ImGuiMouseCursor_Hand: ImGuiMouseCursor_ = 7;
pub const ImGuiMouseCursor__ImGuiMouseCursor_NotAllowed: ImGuiMouseCursor_ = 8;
pub const ImGuiMouseCursor__ImGuiMouseCursor_COUNT: ImGuiMouseCursor_ = 9;
pub type ImGuiMouseCursor_ = i32;
pub const ImGuiCond__ImGuiCond_Always: ImGuiCond_ = 1;
pub const ImGuiCond__ImGuiCond_Once: ImGuiCond_ = 2;
pub const ImGuiCond__ImGuiCond_FirstUseEver: ImGuiCond_ = 4;
pub const ImGuiCond__ImGuiCond_Appearing: ImGuiCond_ = 8;
pub type ImGuiCond_ = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiStyle {
    pub Alpha: f32,
    pub WindowPadding: ImVec2,
    pub WindowRounding: f32,
    pub WindowBorderSize: f32,
    pub WindowMinSize: ImVec2,
    pub WindowTitleAlign: ImVec2,
    pub WindowMenuButtonPosition: ImGuiDir,
    pub ChildRounding: f32,
    pub ChildBorderSize: f32,
    pub PopupRounding: f32,
    pub PopupBorderSize: f32,
    pub FramePadding: ImVec2,
    pub FrameRounding: f32,
    pub FrameBorderSize: f32,
    pub ItemSpacing: ImVec2,
    pub ItemInnerSpacing: ImVec2,
    pub TouchExtraPadding: ImVec2,
    pub IndentSpacing: f32,
    pub ColumnsMinSpacing: f32,
    pub ScrollbarSize: f32,
    pub ScrollbarRounding: f32,
    pub GrabMinSize: f32,
    pub GrabRounding: f32,
    pub TabRounding: f32,
    pub TabBorderSize: f32,
    pub ColorButtonPosition: ImGuiDir,
    pub ButtonTextAlign: ImVec2,
    pub SelectableTextAlign: ImVec2,
    pub DisplayWindowPadding: ImVec2,
    pub DisplaySafeAreaPadding: ImVec2,
    pub MouseCursorScale: f32,
    pub AntiAliasedLines: bool,
    pub AntiAliasedFill: bool,
    pub CurveTessellationTol: f32,
    pub CircleSegmentMaxError: f32,
    pub Colors: [ImVec4; 48usize],
}
#[test]
fn bindgen_test_layout_ImGuiStyle() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiStyle>(),
        948usize,
        concat!("Size of: ", stringify!(ImGuiStyle))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiStyle>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiStyle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).Alpha as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(Alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).WindowPadding as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(WindowPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).WindowRounding as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(WindowRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).WindowBorderSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(WindowBorderSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).WindowMinSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(WindowMinSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).WindowTitleAlign as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(WindowTitleAlign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStyle>())).WindowMenuButtonPosition as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(WindowMenuButtonPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ChildRounding as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ChildRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ChildBorderSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ChildBorderSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).PopupRounding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(PopupRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).PopupBorderSize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(PopupBorderSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).FramePadding as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(FramePadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).FrameRounding as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(FrameRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).FrameBorderSize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(FrameBorderSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ItemSpacing as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ItemSpacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ItemInnerSpacing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ItemInnerSpacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).TouchExtraPadding as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(TouchExtraPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).IndentSpacing as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(IndentSpacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ColumnsMinSpacing as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ColumnsMinSpacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ScrollbarSize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ScrollbarSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ScrollbarRounding as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ScrollbarRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).GrabMinSize as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(GrabMinSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).GrabRounding as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(GrabRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).TabRounding as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(TabRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).TabBorderSize as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(TabBorderSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ColorButtonPosition as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ColorButtonPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).ButtonTextAlign as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(ButtonTextAlign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).SelectableTextAlign as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(SelectableTextAlign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).DisplayWindowPadding as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(DisplayWindowPadding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStyle>())).DisplaySafeAreaPadding as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(DisplaySafeAreaPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).MouseCursorScale as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(MouseCursorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).AntiAliasedLines as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(AntiAliasedLines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).AntiAliasedFill as *const _ as usize },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(AntiAliasedFill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).CurveTessellationTol as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(CurveTessellationTol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStyle>())).CircleSegmentMaxError as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(CircleSegmentMaxError)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyle>())).Colors as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyle),
            "::",
            stringify!(Colors)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiIO {
    pub ConfigFlags: ImGuiConfigFlags,
    pub BackendFlags: ImGuiBackendFlags,
    pub DisplaySize: ImVec2,
    pub DeltaTime: f32,
    pub IniSavingRate: f32,
    pub IniFilename: *const ::std::os::raw::c_char,
    pub LogFilename: *const ::std::os::raw::c_char,
    pub MouseDoubleClickTime: f32,
    pub MouseDoubleClickMaxDist: f32,
    pub MouseDragThreshold: f32,
    pub KeyMap: [::std::os::raw::c_int; 22usize],
    pub KeyRepeatDelay: f32,
    pub KeyRepeatRate: f32,
    pub UserData: *mut ::std::os::raw::c_void,
    pub Fonts: *mut ImFontAtlas,
    pub FontGlobalScale: f32,
    pub FontAllowUserScaling: bool,
    pub FontDefault: *mut ImFont,
    pub DisplayFramebufferScale: ImVec2,
    pub MouseDrawCursor: bool,
    pub ConfigMacOSXBehaviors: bool,
    pub ConfigInputTextCursorBlink: bool,
    pub ConfigWindowsResizeFromEdges: bool,
    pub ConfigWindowsMoveFromTitleBarOnly: bool,
    pub ConfigWindowsMemoryCompactTimer: f32,
    pub BackendPlatformName: *const ::std::os::raw::c_char,
    pub BackendRendererName: *const ::std::os::raw::c_char,
    pub BackendPlatformUserData: *mut ::std::os::raw::c_void,
    pub BackendRendererUserData: *mut ::std::os::raw::c_void,
    pub BackendLanguageUserData: *mut ::std::os::raw::c_void,
    pub GetClipboardTextFn: ::std::option::Option<
        unsafe extern "C" fn(
            user_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub SetClipboardTextFn: ::std::option::Option<
        unsafe extern "C" fn(
            user_data: *mut ::std::os::raw::c_void,
            text: *const ::std::os::raw::c_char,
        ),
    >,
    pub ClipboardUserData: *mut ::std::os::raw::c_void,
    pub ImeSetInputScreenPosFn: ::std::option::Option<
        unsafe extern "C" fn(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int),
    >,
    pub ImeWindowHandle: *mut ::std::os::raw::c_void,
    pub RenderDrawListsFnUnused: *mut ::std::os::raw::c_void,
    pub MousePos: ImVec2,
    pub MouseDown: [bool; 5usize],
    pub MouseWheel: f32,
    pub MouseWheelH: f32,
    pub KeyCtrl: bool,
    pub KeyShift: bool,
    pub KeyAlt: bool,
    pub KeySuper: bool,
    pub KeysDown: [bool; 512usize],
    pub NavInputs: [f32; 21usize],
    pub WantCaptureMouse: bool,
    pub WantCaptureKeyboard: bool,
    pub WantTextInput: bool,
    pub WantSetMousePos: bool,
    pub WantSaveIniSettings: bool,
    pub NavActive: bool,
    pub NavVisible: bool,
    pub Framerate: f32,
    pub MetricsRenderVertices: ::std::os::raw::c_int,
    pub MetricsRenderIndices: ::std::os::raw::c_int,
    pub MetricsRenderWindows: ::std::os::raw::c_int,
    pub MetricsActiveWindows: ::std::os::raw::c_int,
    pub MetricsActiveAllocations: ::std::os::raw::c_int,
    pub MouseDelta: ImVec2,
    pub KeyMods: ImGuiKeyModFlags,
    pub MousePosPrev: ImVec2,
    pub MouseClickedPos: [ImVec2; 5usize],
    pub MouseClickedTime: [f64; 5usize],
    pub MouseClicked: [bool; 5usize],
    pub MouseDoubleClicked: [bool; 5usize],
    pub MouseReleased: [bool; 5usize],
    pub MouseDownOwned: [bool; 5usize],
    pub MouseDownWasDoubleClick: [bool; 5usize],
    pub MouseDownDuration: [f32; 5usize],
    pub MouseDownDurationPrev: [f32; 5usize],
    pub MouseDragMaxDistanceAbs: [ImVec2; 5usize],
    pub MouseDragMaxDistanceSqr: [f32; 5usize],
    pub KeysDownDuration: [f32; 512usize],
    pub KeysDownDurationPrev: [f32; 512usize],
    pub NavInputsDownDuration: [f32; 21usize],
    pub NavInputsDownDurationPrev: [f32; 21usize],
    pub InputQueueSurrogate: ImWchar16,
    pub InputQueueCharacters: ImVector_ImWchar,
}
#[test]
fn bindgen_test_layout_ImGuiIO() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiIO>(),
        5472usize,
        concat!("Size of: ", stringify!(ImGuiIO))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiIO>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiIO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).ConfigFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ConfigFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).BackendFlags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(BackendFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).DisplaySize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(DisplaySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).DeltaTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(DeltaTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).IniSavingRate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(IniSavingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).IniFilename as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(IniFilename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).LogFilename as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(LogFilename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDoubleClickTime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDoubleClickTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDoubleClickMaxDist as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDoubleClickMaxDist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDragThreshold as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDragThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyMap as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyRepeatDelay as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyRepeatDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyRepeatRate as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyRepeatRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).UserData as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(UserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).Fonts as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(Fonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).FontGlobalScale as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(FontGlobalScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).FontAllowUserScaling as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(FontAllowUserScaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).FontDefault as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(FontDefault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).DisplayFramebufferScale as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(DisplayFramebufferScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDrawCursor as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDrawCursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).ConfigMacOSXBehaviors as *const _ as usize },
        193usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ConfigMacOSXBehaviors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiIO>())).ConfigInputTextCursorBlink as *const _ as usize
        },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ConfigInputTextCursorBlink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiIO>())).ConfigWindowsResizeFromEdges as *const _ as usize
        },
        195usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ConfigWindowsResizeFromEdges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiIO>())).ConfigWindowsMoveFromTitleBarOnly as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ConfigWindowsMoveFromTitleBarOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiIO>())).ConfigWindowsMemoryCompactTimer as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ConfigWindowsMemoryCompactTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).BackendPlatformName as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(BackendPlatformName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).BackendRendererName as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(BackendRendererName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).BackendPlatformUserData as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(BackendPlatformUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).BackendRendererUserData as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(BackendRendererUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).BackendLanguageUserData as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(BackendLanguageUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).GetClipboardTextFn as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(GetClipboardTextFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).SetClipboardTextFn as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(SetClipboardTextFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).ClipboardUserData as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ClipboardUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).ImeSetInputScreenPosFn as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ImeSetInputScreenPosFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).ImeWindowHandle as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(ImeWindowHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).RenderDrawListsFnUnused as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(RenderDrawListsFnUnused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MousePos as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MousePos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDown as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseWheel as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseWheel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseWheelH as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseWheelH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyCtrl as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyCtrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyShift as *const _ as usize },
        321usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyShift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyAlt as *const _ as usize },
        322usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyAlt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeySuper as *const _ as usize },
        323usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeySuper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeysDown as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeysDown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).NavInputs as *const _ as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(NavInputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).WantCaptureMouse as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(WantCaptureMouse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).WantCaptureKeyboard as *const _ as usize },
        921usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(WantCaptureKeyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).WantTextInput as *const _ as usize },
        922usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(WantTextInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).WantSetMousePos as *const _ as usize },
        923usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(WantSetMousePos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).WantSaveIniSettings as *const _ as usize },
        924usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(WantSaveIniSettings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).NavActive as *const _ as usize },
        925usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(NavActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).NavVisible as *const _ as usize },
        926usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(NavVisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).Framerate as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(Framerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MetricsRenderVertices as *const _ as usize },
        932usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MetricsRenderVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MetricsRenderIndices as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MetricsRenderIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MetricsRenderWindows as *const _ as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MetricsRenderWindows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MetricsActiveWindows as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MetricsActiveWindows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiIO>())).MetricsActiveAllocations as *const _ as usize
        },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MetricsActiveAllocations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDelta as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDelta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeyMods as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeyMods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MousePosPrev as *const _ as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MousePosPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseClickedPos as *const _ as usize },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseClickedPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseClickedTime as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseClickedTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseClicked as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseClicked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDoubleClicked as *const _ as usize },
        1061usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDoubleClicked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseReleased as *const _ as usize },
        1066usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseReleased)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDownOwned as *const _ as usize },
        1071usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDownOwned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDownWasDoubleClick as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDownWasDoubleClick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDownDuration as *const _ as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDownDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDownDurationPrev as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDownDurationPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDragMaxDistanceAbs as *const _ as usize },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDragMaxDistanceAbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).MouseDragMaxDistanceSqr as *const _ as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(MouseDragMaxDistanceSqr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeysDownDuration as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeysDownDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).KeysDownDurationPrev as *const _ as usize },
        3232usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(KeysDownDurationPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).NavInputsDownDuration as *const _ as usize },
        5280usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(NavInputsDownDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiIO>())).NavInputsDownDurationPrev as *const _ as usize
        },
        5364usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(NavInputsDownDurationPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).InputQueueSurrogate as *const _ as usize },
        5448usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(InputQueueSurrogate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiIO>())).InputQueueCharacters as *const _ as usize },
        5456usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiIO),
            "::",
            stringify!(InputQueueCharacters)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiInputTextCallbackData {
    pub EventFlag: ImGuiInputTextFlags,
    pub Flags: ImGuiInputTextFlags,
    pub UserData: *mut ::std::os::raw::c_void,
    pub EventChar: ImWchar,
    pub EventKey: ImGuiKey,
    pub Buf: *mut ::std::os::raw::c_char,
    pub BufTextLen: ::std::os::raw::c_int,
    pub BufSize: ::std::os::raw::c_int,
    pub BufDirty: bool,
    pub CursorPos: ::std::os::raw::c_int,
    pub SelectionStart: ::std::os::raw::c_int,
    pub SelectionEnd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ImGuiInputTextCallbackData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiInputTextCallbackData>(),
        56usize,
        concat!("Size of: ", stringify!(ImGuiInputTextCallbackData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiInputTextCallbackData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiInputTextCallbackData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).EventFlag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(EventFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).Flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).UserData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(UserData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).EventChar as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(EventChar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).EventKey as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(EventKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).Buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(Buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).BufTextLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(BufTextLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).BufSize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(BufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).BufDirty as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(BufDirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).CursorPos as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(CursorPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).SelectionStart as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(SelectionStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextCallbackData>())).SelectionEnd as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextCallbackData),
            "::",
            stringify!(SelectionEnd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiSizeCallbackData {
    pub UserData: *mut ::std::os::raw::c_void,
    pub Pos: ImVec2,
    pub CurrentSize: ImVec2,
    pub DesiredSize: ImVec2,
}
#[test]
fn bindgen_test_layout_ImGuiSizeCallbackData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiSizeCallbackData>(),
        32usize,
        concat!("Size of: ", stringify!(ImGuiSizeCallbackData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiSizeCallbackData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiSizeCallbackData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSizeCallbackData>())).UserData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSizeCallbackData),
            "::",
            stringify!(UserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSizeCallbackData>())).Pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSizeCallbackData),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiSizeCallbackData>())).CurrentSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSizeCallbackData),
            "::",
            stringify!(CurrentSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiSizeCallbackData>())).DesiredSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSizeCallbackData),
            "::",
            stringify!(DesiredSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiPayload {
    pub Data: *mut ::std::os::raw::c_void,
    pub DataSize: ::std::os::raw::c_int,
    pub SourceId: ImGuiID,
    pub SourceParentId: ImGuiID,
    pub DataFrameCount: ::std::os::raw::c_int,
    pub DataType: [::std::os::raw::c_char; 33usize],
    pub Preview: bool,
    pub Delivery: bool,
}
#[test]
fn bindgen_test_layout_ImGuiPayload() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiPayload>(),
        64usize,
        concat!("Size of: ", stringify!(ImGuiPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiPayload))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).Data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).DataSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).SourceId as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(SourceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).SourceParentId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(SourceParentId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).DataFrameCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(DataFrameCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).DataType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(DataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).Preview as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(Preview)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPayload>())).Delivery as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPayload),
            "::",
            stringify!(Delivery)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiOnceUponAFrame {
    pub RefFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ImGuiOnceUponAFrame() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiOnceUponAFrame>(),
        4usize,
        concat!("Size of: ", stringify!(ImGuiOnceUponAFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiOnceUponAFrame>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiOnceUponAFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiOnceUponAFrame>())).RefFrame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiOnceUponAFrame),
            "::",
            stringify!(RefFrame)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiTextFilter {
    pub InputBuf: [::std::os::raw::c_char; 256usize],
    pub Filters: ImVector_ImGuiTextRange,
    pub CountGrep: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ImGuiTextFilter() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiTextFilter>(),
        280usize,
        concat!("Size of: ", stringify!(ImGuiTextFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiTextFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiTextFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTextFilter>())).InputBuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTextFilter),
            "::",
            stringify!(InputBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTextFilter>())).Filters as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTextFilter),
            "::",
            stringify!(Filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTextFilter>())).CountGrep as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTextFilter),
            "::",
            stringify!(CountGrep)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiTextBuffer {
    pub Buf: ImVector_char,
}
#[test]
fn bindgen_test_layout_ImGuiTextBuffer() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiTextBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(ImGuiTextBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiTextBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiTextBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTextBuffer>())).Buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTextBuffer),
            "::",
            stringify!(Buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiStorage {
    pub Data: ImVector_ImGuiStoragePair,
}
#[test]
fn bindgen_test_layout_ImGuiStorage() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiStorage>(),
        16usize,
        concat!("Size of: ", stringify!(ImGuiStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiStorage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStorage>())).Data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStorage),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVector_ImGuiTabBar {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTabBar,
}
#[test]
fn bindgen_test_layout_ImVector_ImGuiTabBar() {
    assert_eq!(
        ::std::mem::size_of::<ImVector_ImGuiTabBar>(),
        16usize,
        concat!("Size of: ", stringify!(ImVector_ImGuiTabBar))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVector_ImGuiTabBar>(),
        8usize,
        concat!("Alignment of ", stringify!(ImVector_ImGuiTabBar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTabBar>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTabBar),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTabBar>())).Capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTabBar),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVector_ImGuiTabBar>())).Data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVector_ImGuiTabBar),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImPool_ImGuiTabBar {
    pub Buf: ImVector_ImGuiTabBar,
    pub Map: ImGuiStorage,
    pub FreeIdx: ImPoolIdx,
}
#[test]
fn bindgen_test_layout_ImPool_ImGuiTabBar() {
    assert_eq!(
        ::std::mem::size_of::<ImPool_ImGuiTabBar>(),
        40usize,
        concat!("Size of: ", stringify!(ImPool_ImGuiTabBar))
    );
    assert_eq!(
        ::std::mem::align_of::<ImPool_ImGuiTabBar>(),
        8usize,
        concat!("Alignment of ", stringify!(ImPool_ImGuiTabBar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImPool_ImGuiTabBar>())).Buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImPool_ImGuiTabBar),
            "::",
            stringify!(Buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImPool_ImGuiTabBar>())).Map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImPool_ImGuiTabBar),
            "::",
            stringify!(Map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImPool_ImGuiTabBar>())).FreeIdx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImPool_ImGuiTabBar),
            "::",
            stringify!(FreeIdx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiListClipper {
    pub DisplayStart: ::std::os::raw::c_int,
    pub DisplayEnd: ::std::os::raw::c_int,
    pub ItemsCount: ::std::os::raw::c_int,
    pub StepNo: ::std::os::raw::c_int,
    pub ItemsHeight: f32,
    pub StartPosY: f32,
}
#[test]
fn bindgen_test_layout_ImGuiListClipper() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiListClipper>(),
        24usize,
        concat!("Size of: ", stringify!(ImGuiListClipper))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiListClipper>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiListClipper))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiListClipper>())).DisplayStart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiListClipper),
            "::",
            stringify!(DisplayStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiListClipper>())).DisplayEnd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiListClipper),
            "::",
            stringify!(DisplayEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiListClipper>())).ItemsCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiListClipper),
            "::",
            stringify!(ItemsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiListClipper>())).StepNo as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiListClipper),
            "::",
            stringify!(StepNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiListClipper>())).ItemsHeight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiListClipper),
            "::",
            stringify!(ItemsHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiListClipper>())).StartPosY as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiListClipper),
            "::",
            stringify!(StartPosY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImColor {
    pub Value: ImVec4,
}
#[test]
fn bindgen_test_layout_ImColor() {
    assert_eq!(
        ::std::mem::size_of::<ImColor>(),
        16usize,
        concat!("Size of: ", stringify!(ImColor))
    );
    assert_eq!(
        ::std::mem::align_of::<ImColor>(),
        4usize,
        concat!("Alignment of ", stringify!(ImColor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImColor>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImColor),
            "::",
            stringify!(Value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawCmd {
    pub ElemCount: ::std::os::raw::c_uint,
    pub ClipRect: ImVec4,
    pub TextureId: ImTextureID,
    pub VtxOffset: ::std::os::raw::c_uint,
    pub IdxOffset: ::std::os::raw::c_uint,
    pub UserCallback: ImDrawCallback,
    pub UserCallbackData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ImDrawCmd() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawCmd>(),
        56usize,
        concat!("Size of: ", stringify!(ImDrawCmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawCmd>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawCmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).ElemCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(ElemCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).ClipRect as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(ClipRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).TextureId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(TextureId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).VtxOffset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(VtxOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).IdxOffset as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(IdxOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).UserCallback as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(UserCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawCmd>())).UserCallbackData as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawCmd),
            "::",
            stringify!(UserCallbackData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawVert {
    pub pos: ImVec2,
    pub uv: ImVec2,
    pub col: ImU32,
}
#[test]
fn bindgen_test_layout_ImDrawVert() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawVert>(),
        20usize,
        concat!("Size of: ", stringify!(ImDrawVert))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawVert>(),
        4usize,
        concat!("Alignment of ", stringify!(ImDrawVert))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawVert>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawVert),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawVert>())).uv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawVert),
            "::",
            stringify!(uv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawVert>())).col as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawVert),
            "::",
            stringify!(col)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawChannel {
    pub _CmdBuffer: ImVector_ImDrawCmd,
    pub _IdxBuffer: ImVector_ImDrawIdx,
}
#[test]
fn bindgen_test_layout_ImDrawChannel() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawChannel>(),
        32usize,
        concat!("Size of: ", stringify!(ImDrawChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawChannel>()))._CmdBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawChannel),
            "::",
            stringify!(_CmdBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawChannel>()))._IdxBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawChannel),
            "::",
            stringify!(_IdxBuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawListSplitter {
    pub _Current: ::std::os::raw::c_int,
    pub _Count: ::std::os::raw::c_int,
    pub _Channels: ImVector_ImDrawChannel,
}
#[test]
fn bindgen_test_layout_ImDrawListSplitter() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawListSplitter>(),
        24usize,
        concat!("Size of: ", stringify!(ImDrawListSplitter))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawListSplitter>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawListSplitter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawListSplitter>()))._Current as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSplitter),
            "::",
            stringify!(_Current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawListSplitter>()))._Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSplitter),
            "::",
            stringify!(_Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawListSplitter>()))._Channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSplitter),
            "::",
            stringify!(_Channels)
        )
    );
}
pub const ImDrawCornerFlags__ImDrawCornerFlags_None: ImDrawCornerFlags_ = 0;
pub const ImDrawCornerFlags__ImDrawCornerFlags_TopLeft: ImDrawCornerFlags_ = 1;
pub const ImDrawCornerFlags__ImDrawCornerFlags_TopRight: ImDrawCornerFlags_ = 2;
pub const ImDrawCornerFlags__ImDrawCornerFlags_BotLeft: ImDrawCornerFlags_ = 4;
pub const ImDrawCornerFlags__ImDrawCornerFlags_BotRight: ImDrawCornerFlags_ = 8;
pub const ImDrawCornerFlags__ImDrawCornerFlags_Top: ImDrawCornerFlags_ = 3;
pub const ImDrawCornerFlags__ImDrawCornerFlags_Bot: ImDrawCornerFlags_ = 12;
pub const ImDrawCornerFlags__ImDrawCornerFlags_Left: ImDrawCornerFlags_ = 5;
pub const ImDrawCornerFlags__ImDrawCornerFlags_Right: ImDrawCornerFlags_ = 10;
pub const ImDrawCornerFlags__ImDrawCornerFlags_All: ImDrawCornerFlags_ = 15;
pub type ImDrawCornerFlags_ = u32;
pub const ImDrawListFlags__ImDrawListFlags_None: ImDrawListFlags_ = 0;
pub const ImDrawListFlags__ImDrawListFlags_AntiAliasedLines: ImDrawListFlags_ = 1;
pub const ImDrawListFlags__ImDrawListFlags_AntiAliasedFill: ImDrawListFlags_ = 2;
pub const ImDrawListFlags__ImDrawListFlags_AllowVtxOffset: ImDrawListFlags_ = 4;
pub type ImDrawListFlags_ = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawList {
    pub CmdBuffer: ImVector_ImDrawCmd,
    pub IdxBuffer: ImVector_ImDrawIdx,
    pub VtxBuffer: ImVector_ImDrawVert,
    pub Flags: ImDrawListFlags,
    pub _Data: *const ImDrawListSharedData,
    pub _OwnerName: *const ::std::os::raw::c_char,
    pub _VtxCurrentOffset: ::std::os::raw::c_uint,
    pub _VtxCurrentIdx: ::std::os::raw::c_uint,
    pub _VtxWritePtr: *mut ImDrawVert,
    pub _IdxWritePtr: *mut ImDrawIdx,
    pub _ClipRectStack: ImVector_ImVec4,
    pub _TextureIdStack: ImVector_ImTextureID,
    pub _Path: ImVector_ImVec2,
    pub _Splitter: ImDrawListSplitter,
}
#[test]
fn bindgen_test_layout_ImDrawList() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawList>(),
        168usize,
        concat!("Size of: ", stringify!(ImDrawList))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawList>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>())).CmdBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(CmdBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>())).IdxBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(IdxBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>())).VtxBuffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(VtxBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>())).Flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._Data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_Data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._OwnerName as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_OwnerName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._VtxCurrentOffset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_VtxCurrentOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._VtxCurrentIdx as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_VtxCurrentIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._VtxWritePtr as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_VtxWritePtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._IdxWritePtr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_IdxWritePtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._ClipRectStack as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_ClipRectStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._TextureIdStack as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_TextureIdStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._Path as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_Path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawList>()))._Splitter as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawList),
            "::",
            stringify!(_Splitter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawData {
    pub Valid: bool,
    pub CmdLists: *mut *mut ImDrawList,
    pub CmdListsCount: ::std::os::raw::c_int,
    pub TotalIdxCount: ::std::os::raw::c_int,
    pub TotalVtxCount: ::std::os::raw::c_int,
    pub DisplayPos: ImVec2,
    pub DisplaySize: ImVec2,
    pub FramebufferScale: ImVec2,
}
#[test]
fn bindgen_test_layout_ImDrawData() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawData>(),
        56usize,
        concat!("Size of: ", stringify!(ImDrawData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).Valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(Valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).CmdLists as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(CmdLists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).CmdListsCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(CmdListsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).TotalIdxCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(TotalIdxCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).TotalVtxCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(TotalVtxCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).DisplayPos as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(DisplayPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).DisplaySize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(DisplaySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawData>())).FramebufferScale as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawData),
            "::",
            stringify!(FramebufferScale)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImFontConfig {
    pub FontData: *mut ::std::os::raw::c_void,
    pub FontDataSize: ::std::os::raw::c_int,
    pub FontDataOwnedByAtlas: bool,
    pub FontNo: ::std::os::raw::c_int,
    pub SizePixels: f32,
    pub OversampleH: ::std::os::raw::c_int,
    pub OversampleV: ::std::os::raw::c_int,
    pub PixelSnapH: bool,
    pub GlyphExtraSpacing: ImVec2,
    pub GlyphOffset: ImVec2,
    pub GlyphRanges: *const ImWchar,
    pub GlyphMinAdvanceX: f32,
    pub GlyphMaxAdvanceX: f32,
    pub MergeMode: bool,
    pub RasterizerFlags: ::std::os::raw::c_uint,
    pub RasterizerMultiply: f32,
    pub EllipsisChar: ImWchar,
    pub Name: [::std::os::raw::c_char; 40usize],
    pub DstFont: *mut ImFont,
}
#[test]
fn bindgen_test_layout_ImFontConfig() {
    assert_eq!(
        ::std::mem::size_of::<ImFontConfig>(),
        136usize,
        concat!("Size of: ", stringify!(ImFontConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<ImFontConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(ImFontConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).FontData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(FontData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).FontDataSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(FontDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImFontConfig>())).FontDataOwnedByAtlas as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(FontDataOwnedByAtlas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).FontNo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(FontNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).SizePixels as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(SizePixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).OversampleH as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(OversampleH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).OversampleV as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(OversampleV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).PixelSnapH as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(PixelSnapH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).GlyphExtraSpacing as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(GlyphExtraSpacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).GlyphOffset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(GlyphOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).GlyphRanges as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(GlyphRanges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).GlyphMinAdvanceX as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(GlyphMinAdvanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).GlyphMaxAdvanceX as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(GlyphMaxAdvanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).MergeMode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(MergeMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).RasterizerFlags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(RasterizerFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).RasterizerMultiply as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(RasterizerMultiply)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).EllipsisChar as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(EllipsisChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).Name as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontConfig>())).DstFont as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontConfig),
            "::",
            stringify!(DstFont)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImFontGlyph {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub AdvanceX: f32,
    pub X0: f32,
    pub Y0: f32,
    pub X1: f32,
    pub Y1: f32,
    pub U0: f32,
    pub V0: f32,
    pub U1: f32,
    pub V1: f32,
}
#[test]
fn bindgen_test_layout_ImFontGlyph() {
    assert_eq!(
        ::std::mem::size_of::<ImFontGlyph>(),
        40usize,
        concat!("Size of: ", stringify!(ImFontGlyph))
    );
    assert_eq!(
        ::std::mem::align_of::<ImFontGlyph>(),
        4usize,
        concat!("Alignment of ", stringify!(ImFontGlyph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).AdvanceX as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(AdvanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).X0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(X0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).Y0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(Y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).X1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(X1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).Y1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(Y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).U0 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(U0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).V0 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(V0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).U1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(U1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontGlyph>())).V1 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyph),
            "::",
            stringify!(V1)
        )
    );
}
impl ImFontGlyph {
    #[inline]
    pub fn Codepoint(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Codepoint(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn Visible(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Visible(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Codepoint: ::std::os::raw::c_uint,
        Visible: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let Codepoint: u32 = unsafe { ::std::mem::transmute(Codepoint) };
            Codepoint as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let Visible: u32 = unsafe { ::std::mem::transmute(Visible) };
            Visible as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImFontGlyphRangesBuilder {
    pub UsedChars: ImVector_ImU32,
}
#[test]
fn bindgen_test_layout_ImFontGlyphRangesBuilder() {
    assert_eq!(
        ::std::mem::size_of::<ImFontGlyphRangesBuilder>(),
        16usize,
        concat!("Size of: ", stringify!(ImFontGlyphRangesBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<ImFontGlyphRangesBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(ImFontGlyphRangesBuilder))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImFontGlyphRangesBuilder>())).UsedChars as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontGlyphRangesBuilder),
            "::",
            stringify!(UsedChars)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImFontAtlasCustomRect {
    pub ID: ::std::os::raw::c_uint,
    pub Width: ::std::os::raw::c_ushort,
    pub Height: ::std::os::raw::c_ushort,
    pub X: ::std::os::raw::c_ushort,
    pub Y: ::std::os::raw::c_ushort,
    pub GlyphAdvanceX: f32,
    pub GlyphOffset: ImVec2,
    pub Font: *mut ImFont,
}
#[test]
fn bindgen_test_layout_ImFontAtlasCustomRect() {
    assert_eq!(
        ::std::mem::size_of::<ImFontAtlasCustomRect>(),
        32usize,
        concat!("Size of: ", stringify!(ImFontAtlasCustomRect))
    );
    assert_eq!(
        ::std::mem::align_of::<ImFontAtlasCustomRect>(),
        8usize,
        concat!("Alignment of ", stringify!(ImFontAtlasCustomRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).Width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).Height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).X as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).Y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).GlyphAdvanceX as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(GlyphAdvanceX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).GlyphOffset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(GlyphOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlasCustomRect>())).Font as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlasCustomRect),
            "::",
            stringify!(Font)
        )
    );
}
pub const ImFontAtlasFlags__ImFontAtlasFlags_None: ImFontAtlasFlags_ = 0;
pub const ImFontAtlasFlags__ImFontAtlasFlags_NoPowerOfTwoHeight: ImFontAtlasFlags_ = 1;
pub const ImFontAtlasFlags__ImFontAtlasFlags_NoMouseCursors: ImFontAtlasFlags_ = 2;
pub type ImFontAtlasFlags_ = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImFontAtlas {
    pub Locked: bool,
    pub Flags: ImFontAtlasFlags,
    pub TexID: ImTextureID,
    pub TexDesiredWidth: ::std::os::raw::c_int,
    pub TexGlyphPadding: ::std::os::raw::c_int,
    pub TexPixelsAlpha8: *mut ::std::os::raw::c_uchar,
    pub TexPixelsRGBA32: *mut ::std::os::raw::c_uint,
    pub TexWidth: ::std::os::raw::c_int,
    pub TexHeight: ::std::os::raw::c_int,
    pub TexUvScale: ImVec2,
    pub TexUvWhitePixel: ImVec2,
    pub Fonts: ImVector_ImFontPtr,
    pub CustomRects: ImVector_ImFontAtlasCustomRect,
    pub ConfigData: ImVector_ImFontConfig,
    pub CustomRectIds: [::std::os::raw::c_int; 1usize],
}
#[test]
fn bindgen_test_layout_ImFontAtlas() {
    assert_eq!(
        ::std::mem::size_of::<ImFontAtlas>(),
        120usize,
        concat!("Size of: ", stringify!(ImFontAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<ImFontAtlas>(),
        8usize,
        concat!("Alignment of ", stringify!(ImFontAtlas))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).Locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(Locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexDesiredWidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexDesiredWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexGlyphPadding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexGlyphPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexPixelsAlpha8 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexPixelsAlpha8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexPixelsRGBA32 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexPixelsRGBA32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexWidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexHeight as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexUvScale as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexUvScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).TexUvWhitePixel as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(TexUvWhitePixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).Fonts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(Fonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).CustomRects as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(CustomRects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).ConfigData as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(ConfigData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFontAtlas>())).CustomRectIds as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFontAtlas),
            "::",
            stringify!(CustomRectIds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImFont {
    pub IndexAdvanceX: ImVector_float,
    pub FallbackAdvanceX: f32,
    pub FontSize: f32,
    pub IndexLookup: ImVector_ImWchar,
    pub Glyphs: ImVector_ImFontGlyph,
    pub FallbackGlyph: *const ImFontGlyph,
    pub DisplayOffset: ImVec2,
    pub ContainerAtlas: *mut ImFontAtlas,
    pub ConfigData: *const ImFontConfig,
    pub ConfigDataCount: ::std::os::raw::c_short,
    pub FallbackChar: ImWchar,
    pub EllipsisChar: ImWchar,
    pub DirtyLookupTables: bool,
    pub Scale: f32,
    pub Ascent: f32,
    pub Descent: f32,
    pub MetricsTotalSurface: ::std::os::raw::c_int,
    pub Used4kPagesMap: [ImU8; 2usize],
}
#[test]
fn bindgen_test_layout_ImFont() {
    assert_eq!(
        ::std::mem::size_of::<ImFont>(),
        120usize,
        concat!("Size of: ", stringify!(ImFont))
    );
    assert_eq!(
        ::std::mem::align_of::<ImFont>(),
        8usize,
        concat!("Alignment of ", stringify!(ImFont))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).IndexAdvanceX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(IndexAdvanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).FallbackAdvanceX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(FallbackAdvanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).FontSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(FontSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).IndexLookup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(IndexLookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).Glyphs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(Glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).FallbackGlyph as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(FallbackGlyph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).DisplayOffset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(DisplayOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).ContainerAtlas as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(ContainerAtlas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).ConfigData as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(ConfigData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).ConfigDataCount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(ConfigDataCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).FallbackChar as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(FallbackChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).EllipsisChar as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(EllipsisChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).DirtyLookupTables as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(DirtyLookupTables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).Scale as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(Scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).Ascent as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(Ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).Descent as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(Descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).MetricsTotalSurface as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(MetricsTotalSurface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImFont>())).Used4kPagesMap as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImFont),
            "::",
            stringify!(Used4kPagesMap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImBitVector {
    pub Storage: ImVector_ImU32,
}
#[test]
fn bindgen_test_layout_ImBitVector() {
    assert_eq!(
        ::std::mem::size_of::<ImBitVector>(),
        16usize,
        concat!("Size of: ", stringify!(ImBitVector))
    );
    assert_eq!(
        ::std::mem::align_of::<ImBitVector>(),
        8usize,
        concat!("Alignment of ", stringify!(ImBitVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImBitVector>())).Storage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImBitVector),
            "::",
            stringify!(Storage)
        )
    );
}
pub const ImGuiButtonFlags__ImGuiButtonFlags_None: ImGuiButtonFlags_ = 0;
pub const ImGuiButtonFlags__ImGuiButtonFlags_Repeat: ImGuiButtonFlags_ = 1;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnClick: ImGuiButtonFlags_ = 2;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnClickRelease: ImGuiButtonFlags_ = 4;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnClickReleaseAnywhere: ImGuiButtonFlags_ = 8;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnRelease: ImGuiButtonFlags_ = 16;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnDoubleClick: ImGuiButtonFlags_ = 32;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnDragDropHold: ImGuiButtonFlags_ = 64;
pub const ImGuiButtonFlags__ImGuiButtonFlags_FlattenChildren: ImGuiButtonFlags_ = 128;
pub const ImGuiButtonFlags__ImGuiButtonFlags_AllowItemOverlap: ImGuiButtonFlags_ = 256;
pub const ImGuiButtonFlags__ImGuiButtonFlags_DontClosePopups: ImGuiButtonFlags_ = 512;
pub const ImGuiButtonFlags__ImGuiButtonFlags_Disabled: ImGuiButtonFlags_ = 1024;
pub const ImGuiButtonFlags__ImGuiButtonFlags_AlignTextBaseLine: ImGuiButtonFlags_ = 2048;
pub const ImGuiButtonFlags__ImGuiButtonFlags_NoKeyModifiers: ImGuiButtonFlags_ = 4096;
pub const ImGuiButtonFlags__ImGuiButtonFlags_NoHoldingActiveId: ImGuiButtonFlags_ = 8192;
pub const ImGuiButtonFlags__ImGuiButtonFlags_NoNavFocus: ImGuiButtonFlags_ = 16384;
pub const ImGuiButtonFlags__ImGuiButtonFlags_NoHoveredOnFocus: ImGuiButtonFlags_ = 32768;
pub const ImGuiButtonFlags__ImGuiButtonFlags_MouseButtonLeft: ImGuiButtonFlags_ = 65536;
pub const ImGuiButtonFlags__ImGuiButtonFlags_MouseButtonRight: ImGuiButtonFlags_ = 131072;
pub const ImGuiButtonFlags__ImGuiButtonFlags_MouseButtonMiddle: ImGuiButtonFlags_ = 262144;
pub const ImGuiButtonFlags__ImGuiButtonFlags_MouseButtonMask_: ImGuiButtonFlags_ = 458752;
pub const ImGuiButtonFlags__ImGuiButtonFlags_MouseButtonShift_: ImGuiButtonFlags_ = 16;
pub const ImGuiButtonFlags__ImGuiButtonFlags_MouseButtonDefault_: ImGuiButtonFlags_ = 65536;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnMask_: ImGuiButtonFlags_ = 126;
pub const ImGuiButtonFlags__ImGuiButtonFlags_PressedOnDefault_: ImGuiButtonFlags_ = 4;
pub type ImGuiButtonFlags_ = u32;
pub const ImGuiSliderFlags__ImGuiSliderFlags_None: ImGuiSliderFlags_ = 0;
pub const ImGuiSliderFlags__ImGuiSliderFlags_Vertical: ImGuiSliderFlags_ = 1;
pub type ImGuiSliderFlags_ = u32;
pub const ImGuiDragFlags__ImGuiDragFlags_None: ImGuiDragFlags_ = 0;
pub const ImGuiDragFlags__ImGuiDragFlags_Vertical: ImGuiDragFlags_ = 1;
pub type ImGuiDragFlags_ = u32;
pub const ImGuiColumnsFlags__ImGuiColumnsFlags_None: ImGuiColumnsFlags_ = 0;
pub const ImGuiColumnsFlags__ImGuiColumnsFlags_NoBorder: ImGuiColumnsFlags_ = 1;
pub const ImGuiColumnsFlags__ImGuiColumnsFlags_NoResize: ImGuiColumnsFlags_ = 2;
pub const ImGuiColumnsFlags__ImGuiColumnsFlags_NoPreserveWidths: ImGuiColumnsFlags_ = 4;
pub const ImGuiColumnsFlags__ImGuiColumnsFlags_NoForceWithinWindow: ImGuiColumnsFlags_ = 8;
pub const ImGuiColumnsFlags__ImGuiColumnsFlags_GrowParentContentsSize: ImGuiColumnsFlags_ = 16;
pub type ImGuiColumnsFlags_ = u32;
pub const ImGuiSelectableFlagsPrivate__ImGuiSelectableFlags_NoHoldingActiveID:
    ImGuiSelectableFlagsPrivate_ = 1048576;
pub const ImGuiSelectableFlagsPrivate__ImGuiSelectableFlags_SelectOnClick:
    ImGuiSelectableFlagsPrivate_ = 2097152;
pub const ImGuiSelectableFlagsPrivate__ImGuiSelectableFlags_SelectOnRelease:
    ImGuiSelectableFlagsPrivate_ = 4194304;
pub const ImGuiSelectableFlagsPrivate__ImGuiSelectableFlags_SpanAvailWidth:
    ImGuiSelectableFlagsPrivate_ = 8388608;
pub const ImGuiSelectableFlagsPrivate__ImGuiSelectableFlags_DrawHoveredWhenHeld:
    ImGuiSelectableFlagsPrivate_ = 16777216;
pub const ImGuiSelectableFlagsPrivate__ImGuiSelectableFlags_SetNavIdOnHover:
    ImGuiSelectableFlagsPrivate_ = 33554432;
pub type ImGuiSelectableFlagsPrivate_ = u32;
pub const ImGuiTreeNodeFlagsPrivate__ImGuiTreeNodeFlags_ClipLabelForTrailingButton:
    ImGuiTreeNodeFlagsPrivate_ = 1048576;
pub type ImGuiTreeNodeFlagsPrivate_ = u32;
pub const ImGuiSeparatorFlags__ImGuiSeparatorFlags_None: ImGuiSeparatorFlags_ = 0;
pub const ImGuiSeparatorFlags__ImGuiSeparatorFlags_Horizontal: ImGuiSeparatorFlags_ = 1;
pub const ImGuiSeparatorFlags__ImGuiSeparatorFlags_Vertical: ImGuiSeparatorFlags_ = 2;
pub const ImGuiSeparatorFlags__ImGuiSeparatorFlags_SpanAllColumns: ImGuiSeparatorFlags_ = 4;
pub type ImGuiSeparatorFlags_ = u32;
pub const ImGuiItemFlags__ImGuiItemFlags_None: ImGuiItemFlags_ = 0;
pub const ImGuiItemFlags__ImGuiItemFlags_NoTabStop: ImGuiItemFlags_ = 1;
pub const ImGuiItemFlags__ImGuiItemFlags_ButtonRepeat: ImGuiItemFlags_ = 2;
pub const ImGuiItemFlags__ImGuiItemFlags_Disabled: ImGuiItemFlags_ = 4;
pub const ImGuiItemFlags__ImGuiItemFlags_NoNav: ImGuiItemFlags_ = 8;
pub const ImGuiItemFlags__ImGuiItemFlags_NoNavDefaultFocus: ImGuiItemFlags_ = 16;
pub const ImGuiItemFlags__ImGuiItemFlags_SelectableDontClosePopup: ImGuiItemFlags_ = 32;
pub const ImGuiItemFlags__ImGuiItemFlags_MixedValue: ImGuiItemFlags_ = 64;
pub const ImGuiItemFlags__ImGuiItemFlags_Default_: ImGuiItemFlags_ = 0;
pub type ImGuiItemFlags_ = u32;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_None: ImGuiItemStatusFlags_ = 0;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_HoveredRect: ImGuiItemStatusFlags_ = 1;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_HasDisplayRect: ImGuiItemStatusFlags_ = 2;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_Edited: ImGuiItemStatusFlags_ = 4;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_ToggledSelection: ImGuiItemStatusFlags_ = 8;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_ToggledOpen: ImGuiItemStatusFlags_ = 16;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_HasDeactivated: ImGuiItemStatusFlags_ = 32;
pub const ImGuiItemStatusFlags__ImGuiItemStatusFlags_Deactivated: ImGuiItemStatusFlags_ = 64;
pub type ImGuiItemStatusFlags_ = u32;
pub const ImGuiTextFlags__ImGuiTextFlags_None: ImGuiTextFlags_ = 0;
pub const ImGuiTextFlags__ImGuiTextFlags_NoWidthForLargeClippedText: ImGuiTextFlags_ = 1;
pub type ImGuiTextFlags_ = u32;
pub const ImGuiTooltipFlags__ImGuiTooltipFlags_None: ImGuiTooltipFlags_ = 0;
pub const ImGuiTooltipFlags__ImGuiTooltipFlags_OverridePreviousTooltip: ImGuiTooltipFlags_ = 1;
pub type ImGuiTooltipFlags_ = u32;
pub const ImGuiLayoutType__ImGuiLayoutType_Horizontal: ImGuiLayoutType_ = 0;
pub const ImGuiLayoutType__ImGuiLayoutType_Vertical: ImGuiLayoutType_ = 1;
pub type ImGuiLayoutType_ = u32;
pub const ImGuiLogType_ImGuiLogType_None: ImGuiLogType = 0;
pub const ImGuiLogType_ImGuiLogType_TTY: ImGuiLogType = 1;
pub const ImGuiLogType_ImGuiLogType_File: ImGuiLogType = 2;
pub const ImGuiLogType_ImGuiLogType_Buffer: ImGuiLogType = 3;
pub const ImGuiLogType_ImGuiLogType_Clipboard: ImGuiLogType = 4;
pub type ImGuiLogType = u32;
pub const ImGuiAxis_ImGuiAxis_None: ImGuiAxis = -1;
pub const ImGuiAxis_ImGuiAxis_X: ImGuiAxis = 0;
pub const ImGuiAxis_ImGuiAxis_Y: ImGuiAxis = 1;
pub type ImGuiAxis = i32;
pub const ImGuiPlotType_ImGuiPlotType_Lines: ImGuiPlotType = 0;
pub const ImGuiPlotType_ImGuiPlotType_Histogram: ImGuiPlotType = 1;
pub type ImGuiPlotType = u32;
pub const ImGuiInputSource_ImGuiInputSource_None: ImGuiInputSource = 0;
pub const ImGuiInputSource_ImGuiInputSource_Mouse: ImGuiInputSource = 1;
pub const ImGuiInputSource_ImGuiInputSource_Nav: ImGuiInputSource = 2;
pub const ImGuiInputSource_ImGuiInputSource_NavKeyboard: ImGuiInputSource = 3;
pub const ImGuiInputSource_ImGuiInputSource_NavGamepad: ImGuiInputSource = 4;
pub const ImGuiInputSource_ImGuiInputSource_COUNT: ImGuiInputSource = 5;
pub type ImGuiInputSource = u32;
pub const ImGuiInputReadMode_ImGuiInputReadMode_Down: ImGuiInputReadMode = 0;
pub const ImGuiInputReadMode_ImGuiInputReadMode_Pressed: ImGuiInputReadMode = 1;
pub const ImGuiInputReadMode_ImGuiInputReadMode_Released: ImGuiInputReadMode = 2;
pub const ImGuiInputReadMode_ImGuiInputReadMode_Repeat: ImGuiInputReadMode = 3;
pub const ImGuiInputReadMode_ImGuiInputReadMode_RepeatSlow: ImGuiInputReadMode = 4;
pub const ImGuiInputReadMode_ImGuiInputReadMode_RepeatFast: ImGuiInputReadMode = 5;
pub type ImGuiInputReadMode = u32;
pub const ImGuiNavHighlightFlags__ImGuiNavHighlightFlags_None: ImGuiNavHighlightFlags_ = 0;
pub const ImGuiNavHighlightFlags__ImGuiNavHighlightFlags_TypeDefault: ImGuiNavHighlightFlags_ = 1;
pub const ImGuiNavHighlightFlags__ImGuiNavHighlightFlags_TypeThin: ImGuiNavHighlightFlags_ = 2;
pub const ImGuiNavHighlightFlags__ImGuiNavHighlightFlags_AlwaysDraw: ImGuiNavHighlightFlags_ = 4;
pub const ImGuiNavHighlightFlags__ImGuiNavHighlightFlags_NoRounding: ImGuiNavHighlightFlags_ = 8;
pub type ImGuiNavHighlightFlags_ = u32;
pub const ImGuiNavDirSourceFlags__ImGuiNavDirSourceFlags_None: ImGuiNavDirSourceFlags_ = 0;
pub const ImGuiNavDirSourceFlags__ImGuiNavDirSourceFlags_Keyboard: ImGuiNavDirSourceFlags_ = 1;
pub const ImGuiNavDirSourceFlags__ImGuiNavDirSourceFlags_PadDPad: ImGuiNavDirSourceFlags_ = 2;
pub const ImGuiNavDirSourceFlags__ImGuiNavDirSourceFlags_PadLStick: ImGuiNavDirSourceFlags_ = 4;
pub type ImGuiNavDirSourceFlags_ = u32;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_None: ImGuiNavMoveFlags_ = 0;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_LoopX: ImGuiNavMoveFlags_ = 1;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_LoopY: ImGuiNavMoveFlags_ = 2;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_WrapX: ImGuiNavMoveFlags_ = 4;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_WrapY: ImGuiNavMoveFlags_ = 8;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_AllowCurrentNavId: ImGuiNavMoveFlags_ = 16;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_AlsoScoreVisibleSet: ImGuiNavMoveFlags_ = 32;
pub const ImGuiNavMoveFlags__ImGuiNavMoveFlags_ScrollToEdge: ImGuiNavMoveFlags_ = 64;
pub type ImGuiNavMoveFlags_ = u32;
pub const ImGuiNavForward_ImGuiNavForward_None: ImGuiNavForward = 0;
pub const ImGuiNavForward_ImGuiNavForward_ForwardQueued: ImGuiNavForward = 1;
pub const ImGuiNavForward_ImGuiNavForward_ForwardActive: ImGuiNavForward = 2;
pub type ImGuiNavForward = u32;
pub const ImGuiNavLayer_ImGuiNavLayer_Main: ImGuiNavLayer = 0;
pub const ImGuiNavLayer_ImGuiNavLayer_Menu: ImGuiNavLayer = 1;
pub const ImGuiNavLayer_ImGuiNavLayer_COUNT: ImGuiNavLayer = 2;
pub type ImGuiNavLayer = u32;
pub const ImGuiPopupPositionPolicy_ImGuiPopupPositionPolicy_Default: ImGuiPopupPositionPolicy = 0;
pub const ImGuiPopupPositionPolicy_ImGuiPopupPositionPolicy_ComboBox: ImGuiPopupPositionPolicy = 1;
pub type ImGuiPopupPositionPolicy = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVec1 {
    pub x: f32,
}
#[test]
fn bindgen_test_layout_ImVec1() {
    assert_eq!(
        ::std::mem::size_of::<ImVec1>(),
        4usize,
        concat!("Size of: ", stringify!(ImVec1))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVec1>(),
        4usize,
        concat!("Alignment of ", stringify!(ImVec1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ImVec1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImVec2ih {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_ImVec2ih() {
    assert_eq!(
        ::std::mem::size_of::<ImVec2ih>(),
        4usize,
        concat!("Size of: ", stringify!(ImVec2ih))
    );
    assert_eq!(
        ::std::mem::align_of::<ImVec2ih>(),
        2usize,
        concat!("Alignment of ", stringify!(ImVec2ih))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec2ih>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVec2ih),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImVec2ih>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ImVec2ih),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImRect {
    pub Min: ImVec2,
    pub Max: ImVec2,
}
#[test]
fn bindgen_test_layout_ImRect() {
    assert_eq!(
        ::std::mem::size_of::<ImRect>(),
        16usize,
        concat!("Size of: ", stringify!(ImRect))
    );
    assert_eq!(
        ::std::mem::align_of::<ImRect>(),
        4usize,
        concat!("Alignment of ", stringify!(ImRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImRect>())).Min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImRect),
            "::",
            stringify!(Min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImRect>())).Max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImRect),
            "::",
            stringify!(Max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiDataTypeInfo {
    pub Size: size_t,
    pub PrintFmt: *const ::std::os::raw::c_char,
    pub ScanFmt: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ImGuiDataTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiDataTypeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(ImGuiDataTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiDataTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiDataTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiDataTypeInfo>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiDataTypeInfo),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiDataTypeInfo>())).PrintFmt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiDataTypeInfo),
            "::",
            stringify!(PrintFmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiDataTypeInfo>())).ScanFmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiDataTypeInfo),
            "::",
            stringify!(ScanFmt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiColorMod {
    pub Col: ImGuiCol,
    pub BackupValue: ImVec4,
}
#[test]
fn bindgen_test_layout_ImGuiColorMod() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiColorMod>(),
        20usize,
        concat!("Size of: ", stringify!(ImGuiColorMod))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiColorMod>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiColorMod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColorMod>())).Col as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColorMod),
            "::",
            stringify!(Col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColorMod>())).BackupValue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColorMod),
            "::",
            stringify!(BackupValue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiStyleMod {
    pub VarIdx: ImGuiStyleVar,
    pub __bindgen_anon_1: ImGuiStyleMod__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiStyleMod__bindgen_ty_1 {
    pub BackupInt: [::std::os::raw::c_int; 2usize],
    pub BackupFloat: [f32; 2usize],
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_ImGuiStyleMod__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiStyleMod__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ImGuiStyleMod__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiStyleMod__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiStyleMod__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStyleMod__bindgen_ty_1>())).BackupInt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyleMod__bindgen_ty_1),
            "::",
            stringify!(BackupInt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStyleMod__bindgen_ty_1>())).BackupFloat as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyleMod__bindgen_ty_1),
            "::",
            stringify!(BackupFloat)
        )
    );
}
#[test]
fn bindgen_test_layout_ImGuiStyleMod() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiStyleMod>(),
        12usize,
        concat!("Size of: ", stringify!(ImGuiStyleMod))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiStyleMod>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiStyleMod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStyleMod>())).VarIdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStyleMod),
            "::",
            stringify!(VarIdx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiGroupData {
    pub BackupCursorPos: ImVec2,
    pub BackupCursorMaxPos: ImVec2,
    pub BackupIndent: ImVec1,
    pub BackupGroupOffset: ImVec1,
    pub BackupCurrLineSize: ImVec2,
    pub BackupCurrLineTextBaseOffset: f32,
    pub BackupActiveIdIsAlive: ImGuiID,
    pub BackupActiveIdPreviousFrameIsAlive: bool,
    pub EmitItem: bool,
}
#[test]
fn bindgen_test_layout_ImGuiGroupData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiGroupData>(),
        44usize,
        concat!("Size of: ", stringify!(ImGuiGroupData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiGroupData>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiGroupData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiGroupData>())).BackupCursorPos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupCursorPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiGroupData>())).BackupCursorMaxPos as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupCursorMaxPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiGroupData>())).BackupIndent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupIndent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiGroupData>())).BackupGroupOffset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupGroupOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiGroupData>())).BackupCurrLineSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupCurrLineSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiGroupData>())).BackupCurrLineTextBaseOffset as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupCurrLineTextBaseOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiGroupData>())).BackupActiveIdIsAlive as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupActiveIdIsAlive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiGroupData>())).BackupActiveIdPreviousFrameIsAlive
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(BackupActiveIdPreviousFrameIsAlive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiGroupData>())).EmitItem as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiGroupData),
            "::",
            stringify!(EmitItem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiMenuColumns {
    pub Spacing: f32,
    pub Width: f32,
    pub NextWidth: f32,
    pub Pos: [f32; 3usize],
    pub NextWidths: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_ImGuiMenuColumns() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiMenuColumns>(),
        36usize,
        concat!("Size of: ", stringify!(ImGuiMenuColumns))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiMenuColumns>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiMenuColumns))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiMenuColumns>())).Spacing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiMenuColumns),
            "::",
            stringify!(Spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiMenuColumns>())).Width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiMenuColumns),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiMenuColumns>())).NextWidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiMenuColumns),
            "::",
            stringify!(NextWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiMenuColumns>())).Pos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiMenuColumns),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiMenuColumns>())).NextWidths as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiMenuColumns),
            "::",
            stringify!(NextWidths)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiInputTextState {
    pub ID: ImGuiID,
    pub CurLenW: ::std::os::raw::c_int,
    pub CurLenA: ::std::os::raw::c_int,
    pub TextW: ImVector_ImWchar,
    pub TextA: ImVector_char,
    pub InitialTextA: ImVector_char,
    pub TextAIsValid: bool,
    pub BufCapacityA: ::std::os::raw::c_int,
    pub ScrollX: f32,
    pub Stb: STB_TexteditState,
    pub CursorAnim: f32,
    pub CursorFollow: bool,
    pub SelectedAllMouseLock: bool,
    pub UserFlags: ImGuiInputTextFlags,
    pub UserCallback: ImGuiInputTextCallback,
    pub UserCallbackData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ImGuiInputTextState() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiInputTextState>(),
        3728usize,
        concat!("Size of: ", stringify!(ImGuiInputTextState))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiInputTextState>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiInputTextState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).CurLenW as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(CurLenW)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).CurLenA as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(CurLenA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).TextW as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(TextW)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).TextA as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(TextA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).InitialTextA as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(InitialTextA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).TextAIsValid as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(TextAIsValid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).BufCapacityA as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(BufCapacityA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).ScrollX as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(ScrollX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).Stb as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(Stb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).CursorAnim as *const _ as usize },
        3696usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(CursorAnim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).CursorFollow as *const _ as usize
        },
        3700usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(CursorFollow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).SelectedAllMouseLock as *const _
                as usize
        },
        3701usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(SelectedAllMouseLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiInputTextState>())).UserFlags as *const _ as usize },
        3704usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(UserFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).UserCallback as *const _ as usize
        },
        3712usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(UserCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiInputTextState>())).UserCallbackData as *const _ as usize
        },
        3720usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiInputTextState),
            "::",
            stringify!(UserCallbackData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiWindowSettings {
    pub ID: ImGuiID,
    pub Pos: ImVec2ih,
    pub Size: ImVec2ih,
    pub Collapsed: bool,
}
#[test]
fn bindgen_test_layout_ImGuiWindowSettings() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiWindowSettings>(),
        16usize,
        concat!("Size of: ", stringify!(ImGuiWindowSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiWindowSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiWindowSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowSettings>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowSettings),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowSettings>())).Pos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowSettings),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowSettings>())).Size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowSettings),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowSettings>())).Collapsed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowSettings),
            "::",
            stringify!(Collapsed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiSettingsHandler {
    pub TypeName: *const ::std::os::raw::c_char,
    pub TypeHash: ImGuiID,
    pub ReadOpenFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            name: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub ReadLineFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            entry: *mut ::std::os::raw::c_void,
            line: *const ::std::os::raw::c_char,
        ),
    >,
    pub WriteAllFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            out_buf: *mut ImGuiTextBuffer,
        ),
    >,
    pub UserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ImGuiSettingsHandler() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiSettingsHandler>(),
        48usize,
        concat!("Size of: ", stringify!(ImGuiSettingsHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiSettingsHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiSettingsHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSettingsHandler>())).TypeName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSettingsHandler),
            "::",
            stringify!(TypeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSettingsHandler>())).TypeHash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSettingsHandler),
            "::",
            stringify!(TypeHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSettingsHandler>())).ReadOpenFn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSettingsHandler),
            "::",
            stringify!(ReadOpenFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSettingsHandler>())).ReadLineFn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSettingsHandler),
            "::",
            stringify!(ReadLineFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSettingsHandler>())).WriteAllFn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSettingsHandler),
            "::",
            stringify!(WriteAllFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiSettingsHandler>())).UserData as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiSettingsHandler),
            "::",
            stringify!(UserData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiPopupData {
    pub PopupId: ImGuiID,
    pub Window: *mut ImGuiWindow,
    pub SourceWindow: *mut ImGuiWindow,
    pub OpenFrameCount: ::std::os::raw::c_int,
    pub OpenParentId: ImGuiID,
    pub OpenPopupPos: ImVec2,
    pub OpenMousePos: ImVec2,
}
#[test]
fn bindgen_test_layout_ImGuiPopupData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiPopupData>(),
        48usize,
        concat!("Size of: ", stringify!(ImGuiPopupData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiPopupData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiPopupData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).PopupId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(PopupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).Window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(Window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).SourceWindow as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(SourceWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).OpenFrameCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(OpenFrameCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).OpenParentId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(OpenParentId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).OpenPopupPos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(OpenPopupPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPopupData>())).OpenMousePos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPopupData),
            "::",
            stringify!(OpenMousePos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiColumnData {
    pub OffsetNorm: f32,
    pub OffsetNormBeforeResize: f32,
    pub Flags: ImGuiColumnsFlags,
    pub ClipRect: ImRect,
}
#[test]
fn bindgen_test_layout_ImGuiColumnData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiColumnData>(),
        28usize,
        concat!("Size of: ", stringify!(ImGuiColumnData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiColumnData>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiColumnData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumnData>())).OffsetNorm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumnData),
            "::",
            stringify!(OffsetNorm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiColumnData>())).OffsetNormBeforeResize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumnData),
            "::",
            stringify!(OffsetNormBeforeResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumnData>())).Flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumnData),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumnData>())).ClipRect as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumnData),
            "::",
            stringify!(ClipRect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiColumns {
    pub ID: ImGuiID,
    pub Flags: ImGuiColumnsFlags,
    pub IsFirstFrame: bool,
    pub IsBeingResized: bool,
    pub Current: ::std::os::raw::c_int,
    pub Count: ::std::os::raw::c_int,
    pub OffMinX: f32,
    pub OffMaxX: f32,
    pub LineMinY: f32,
    pub LineMaxY: f32,
    pub HostCursorPosY: f32,
    pub HostCursorMaxPosX: f32,
    pub HostClipRect: ImRect,
    pub HostWorkRect: ImRect,
    pub Columns: ImVector_ImGuiColumnData,
    pub Splitter: ImDrawListSplitter,
}
#[test]
fn bindgen_test_layout_ImGuiColumns() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiColumns>(),
        120usize,
        concat!("Size of: ", stringify!(ImGuiColumns))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiColumns>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiColumns))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).IsFirstFrame as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(IsFirstFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).IsBeingResized as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(IsBeingResized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).Current as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(Current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).Count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).OffMinX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(OffMinX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).OffMaxX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(OffMaxX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).LineMinY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(LineMinY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).LineMaxY as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(LineMaxY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).HostCursorPosY as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(HostCursorPosY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).HostCursorMaxPosX as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(HostCursorMaxPosX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).HostClipRect as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(HostClipRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).HostWorkRect as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(HostWorkRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).Columns as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(Columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiColumns>())).Splitter as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiColumns),
            "::",
            stringify!(Splitter)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImDrawListSharedData {
    pub TexUvWhitePixel: ImVec2,
    pub Font: *mut ImFont,
    pub FontSize: f32,
    pub CurveTessellationTol: f32,
    pub CircleSegmentMaxError: f32,
    pub ClipRectFullscreen: ImVec4,
    pub InitialFlags: ImDrawListFlags,
    pub ArcFastVtx: [ImVec2; 12usize],
    pub CircleSegmentCounts: [ImU8; 64usize],
}
#[test]
fn bindgen_test_layout_ImDrawListSharedData() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawListSharedData>(),
        208usize,
        concat!("Size of: ", stringify!(ImDrawListSharedData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawListSharedData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawListSharedData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImDrawListSharedData>())).TexUvWhitePixel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(TexUvWhitePixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawListSharedData>())).Font as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(Font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawListSharedData>())).FontSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(FontSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImDrawListSharedData>())).CurveTessellationTol as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(CurveTessellationTol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImDrawListSharedData>())).CircleSegmentMaxError as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(CircleSegmentMaxError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImDrawListSharedData>())).ClipRectFullscreen as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(ClipRectFullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImDrawListSharedData>())).InitialFlags as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(InitialFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawListSharedData>())).ArcFastVtx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(ArcFastVtx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImDrawListSharedData>())).CircleSegmentCounts as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawListSharedData),
            "::",
            stringify!(CircleSegmentCounts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImDrawDataBuilder {
    pub Layers: [ImVector_ImDrawListPtr; 2usize],
}
#[test]
fn bindgen_test_layout_ImDrawDataBuilder() {
    assert_eq!(
        ::std::mem::size_of::<ImDrawDataBuilder>(),
        32usize,
        concat!("Size of: ", stringify!(ImDrawDataBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<ImDrawDataBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(ImDrawDataBuilder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImDrawDataBuilder>())).Layers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImDrawDataBuilder),
            "::",
            stringify!(Layers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiNavMoveResult {
    pub Window: *mut ImGuiWindow,
    pub ID: ImGuiID,
    pub FocusScopeId: ImGuiID,
    pub DistBox: f32,
    pub DistCenter: f32,
    pub DistAxial: f32,
    pub RectRel: ImRect,
}
#[test]
fn bindgen_test_layout_ImGuiNavMoveResult() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiNavMoveResult>(),
        48usize,
        concat!("Size of: ", stringify!(ImGuiNavMoveResult))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiNavMoveResult>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiNavMoveResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).Window as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(Window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).ID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).FocusScopeId as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(FocusScopeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).DistBox as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(DistBox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).DistCenter as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(DistCenter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).DistAxial as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(DistAxial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNavMoveResult>())).RectRel as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNavMoveResult),
            "::",
            stringify!(RectRel)
        )
    );
}
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_None: ImGuiNextWindowDataFlags_ = 0;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasPos: ImGuiNextWindowDataFlags_ = 1;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasSize: ImGuiNextWindowDataFlags_ = 2;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasContentSize:
    ImGuiNextWindowDataFlags_ = 4;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasCollapsed:
    ImGuiNextWindowDataFlags_ = 8;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasSizeConstraint:
    ImGuiNextWindowDataFlags_ = 16;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasFocus: ImGuiNextWindowDataFlags_ =
    32;
pub const ImGuiNextWindowDataFlags__ImGuiNextWindowDataFlags_HasBgAlpha: ImGuiNextWindowDataFlags_ =
    64;
pub type ImGuiNextWindowDataFlags_ = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiNextWindowData {
    pub Flags: ImGuiNextWindowDataFlags,
    pub PosCond: ImGuiCond,
    pub SizeCond: ImGuiCond,
    pub CollapsedCond: ImGuiCond,
    pub PosVal: ImVec2,
    pub PosPivotVal: ImVec2,
    pub SizeVal: ImVec2,
    pub ContentSizeVal: ImVec2,
    pub CollapsedVal: bool,
    pub SizeConstraintRect: ImRect,
    pub SizeCallback: ImGuiSizeCallback,
    pub SizeCallbackUserData: *mut ::std::os::raw::c_void,
    pub BgAlphaVal: f32,
    pub MenuBarOffsetMinVal: ImVec2,
}
#[test]
fn bindgen_test_layout_ImGuiNextWindowData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiNextWindowData>(),
        104usize,
        concat!("Size of: ", stringify!(ImGuiNextWindowData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiNextWindowData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiNextWindowData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).PosCond as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(PosCond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).SizeCond as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(SizeCond)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).CollapsedCond as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(CollapsedCond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).PosVal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(PosVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).PosPivotVal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(PosPivotVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).SizeVal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(SizeVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).ContentSizeVal as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(ContentSizeVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).CollapsedVal as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(CollapsedVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).SizeConstraintRect as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(SizeConstraintRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).SizeCallback as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(SizeCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).SizeCallbackUserData as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(SizeCallbackUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextWindowData>())).BgAlphaVal as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(BgAlphaVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiNextWindowData>())).MenuBarOffsetMinVal as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextWindowData),
            "::",
            stringify!(MenuBarOffsetMinVal)
        )
    );
}
pub const ImGuiNextItemDataFlags__ImGuiNextItemDataFlags_None: ImGuiNextItemDataFlags_ = 0;
pub const ImGuiNextItemDataFlags__ImGuiNextItemDataFlags_HasWidth: ImGuiNextItemDataFlags_ = 1;
pub const ImGuiNextItemDataFlags__ImGuiNextItemDataFlags_HasOpen: ImGuiNextItemDataFlags_ = 2;
pub type ImGuiNextItemDataFlags_ = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiNextItemData {
    pub Flags: ImGuiNextItemDataFlags,
    pub Width: f32,
    pub FocusScopeId: ImGuiID,
    pub OpenCond: ImGuiCond,
    pub OpenVal: bool,
}
#[test]
fn bindgen_test_layout_ImGuiNextItemData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiNextItemData>(),
        20usize,
        concat!("Size of: ", stringify!(ImGuiNextItemData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiNextItemData>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiNextItemData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextItemData>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextItemData),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextItemData>())).Width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextItemData),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextItemData>())).FocusScopeId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextItemData),
            "::",
            stringify!(FocusScopeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextItemData>())).OpenCond as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextItemData),
            "::",
            stringify!(OpenCond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiNextItemData>())).OpenVal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiNextItemData),
            "::",
            stringify!(OpenVal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiShrinkWidthItem {
    pub Index: ::std::os::raw::c_int,
    pub Width: f32,
}
#[test]
fn bindgen_test_layout_ImGuiShrinkWidthItem() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiShrinkWidthItem>(),
        8usize,
        concat!("Size of: ", stringify!(ImGuiShrinkWidthItem))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiShrinkWidthItem>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiShrinkWidthItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiShrinkWidthItem>())).Index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiShrinkWidthItem),
            "::",
            stringify!(Index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiShrinkWidthItem>())).Width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiShrinkWidthItem),
            "::",
            stringify!(Width)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiPtrOrIndex {
    pub Ptr: *mut ::std::os::raw::c_void,
    pub Index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ImGuiPtrOrIndex() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiPtrOrIndex>(),
        16usize,
        concat!("Size of: ", stringify!(ImGuiPtrOrIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiPtrOrIndex>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiPtrOrIndex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPtrOrIndex>())).Ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPtrOrIndex),
            "::",
            stringify!(Ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiPtrOrIndex>())).Index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiPtrOrIndex),
            "::",
            stringify!(Index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiContext {
    pub Initialized: bool,
    pub FontAtlasOwnedByContext: bool,
    pub IO: ImGuiIO,
    pub Style: ImGuiStyle,
    pub Font: *mut ImFont,
    pub FontSize: f32,
    pub FontBaseSize: f32,
    pub DrawListSharedData: ImDrawListSharedData,
    pub Time: f64,
    pub FrameCount: ::std::os::raw::c_int,
    pub FrameCountEnded: ::std::os::raw::c_int,
    pub FrameCountRendered: ::std::os::raw::c_int,
    pub WithinFrameScope: bool,
    pub WithinFrameScopeWithImplicitWindow: bool,
    pub WithinEndChild: bool,
    pub Windows: ImVector_ImGuiWindowPtr,
    pub WindowsFocusOrder: ImVector_ImGuiWindowPtr,
    pub WindowsTempSortBuffer: ImVector_ImGuiWindowPtr,
    pub CurrentWindowStack: ImVector_ImGuiWindowPtr,
    pub WindowsById: ImGuiStorage,
    pub WindowsActiveCount: ::std::os::raw::c_int,
    pub CurrentWindow: *mut ImGuiWindow,
    pub HoveredWindow: *mut ImGuiWindow,
    pub HoveredRootWindow: *mut ImGuiWindow,
    pub MovingWindow: *mut ImGuiWindow,
    pub WheelingWindow: *mut ImGuiWindow,
    pub WheelingWindowRefMousePos: ImVec2,
    pub WheelingWindowTimer: f32,
    pub HoveredId: ImGuiID,
    pub HoveredIdAllowOverlap: bool,
    pub HoveredIdPreviousFrame: ImGuiID,
    pub HoveredIdTimer: f32,
    pub HoveredIdNotActiveTimer: f32,
    pub ActiveId: ImGuiID,
    pub ActiveIdIsAlive: ImGuiID,
    pub ActiveIdTimer: f32,
    pub ActiveIdIsJustActivated: bool,
    pub ActiveIdAllowOverlap: bool,
    pub ActiveIdHasBeenPressedBefore: bool,
    pub ActiveIdHasBeenEditedBefore: bool,
    pub ActiveIdHasBeenEditedThisFrame: bool,
    pub ActiveIdUsingNavDirMask: ImU32,
    pub ActiveIdUsingNavInputMask: ImU32,
    pub ActiveIdUsingKeyInputMask: ImU64,
    pub ActiveIdClickOffset: ImVec2,
    pub ActiveIdWindow: *mut ImGuiWindow,
    pub ActiveIdSource: ImGuiInputSource,
    pub ActiveIdMouseButton: ::std::os::raw::c_int,
    pub ActiveIdPreviousFrame: ImGuiID,
    pub ActiveIdPreviousFrameIsAlive: bool,
    pub ActiveIdPreviousFrameHasBeenEditedBefore: bool,
    pub ActiveIdPreviousFrameWindow: *mut ImGuiWindow,
    pub LastActiveId: ImGuiID,
    pub LastActiveIdTimer: f32,
    pub NextWindowData: ImGuiNextWindowData,
    pub NextItemData: ImGuiNextItemData,
    pub ColorModifiers: ImVector_ImGuiColorMod,
    pub StyleModifiers: ImVector_ImGuiStyleMod,
    pub FontStack: ImVector_ImFontPtr,
    pub OpenPopupStack: ImVector_ImGuiPopupData,
    pub BeginPopupStack: ImVector_ImGuiPopupData,
    pub NavWindow: *mut ImGuiWindow,
    pub NavId: ImGuiID,
    pub NavFocusScopeId: ImGuiID,
    pub NavActivateId: ImGuiID,
    pub NavActivateDownId: ImGuiID,
    pub NavActivatePressedId: ImGuiID,
    pub NavInputId: ImGuiID,
    pub NavJustTabbedId: ImGuiID,
    pub NavJustMovedToId: ImGuiID,
    pub NavJustMovedToFocusScopeId: ImGuiID,
    pub NavJustMovedToKeyMods: ImGuiKeyModFlags,
    pub NavNextActivateId: ImGuiID,
    pub NavInputSource: ImGuiInputSource,
    pub NavScoringRect: ImRect,
    pub NavScoringCount: ::std::os::raw::c_int,
    pub NavLayer: ImGuiNavLayer,
    pub NavIdTabCounter: ::std::os::raw::c_int,
    pub NavIdIsAlive: bool,
    pub NavMousePosDirty: bool,
    pub NavDisableHighlight: bool,
    pub NavDisableMouseHover: bool,
    pub NavAnyRequest: bool,
    pub NavInitRequest: bool,
    pub NavInitRequestFromMove: bool,
    pub NavInitResultId: ImGuiID,
    pub NavInitResultRectRel: ImRect,
    pub NavMoveFromClampedRefRect: bool,
    pub NavMoveRequest: bool,
    pub NavMoveRequestFlags: ImGuiNavMoveFlags,
    pub NavMoveRequestForward: ImGuiNavForward,
    pub NavMoveRequestKeyMods: ImGuiKeyModFlags,
    pub NavMoveDir: ImGuiDir,
    pub NavMoveDirLast: ImGuiDir,
    pub NavMoveClipDir: ImGuiDir,
    pub NavMoveResultLocal: ImGuiNavMoveResult,
    pub NavMoveResultLocalVisibleSet: ImGuiNavMoveResult,
    pub NavMoveResultOther: ImGuiNavMoveResult,
    pub NavWindowingTarget: *mut ImGuiWindow,
    pub NavWindowingTargetAnim: *mut ImGuiWindow,
    pub NavWindowingList: *mut ImGuiWindow,
    pub NavWindowingTimer: f32,
    pub NavWindowingHighlightAlpha: f32,
    pub NavWindowingToggleLayer: bool,
    pub FocusRequestCurrWindow: *mut ImGuiWindow,
    pub FocusRequestNextWindow: *mut ImGuiWindow,
    pub FocusRequestCurrCounterRegular: ::std::os::raw::c_int,
    pub FocusRequestCurrCounterTabStop: ::std::os::raw::c_int,
    pub FocusRequestNextCounterRegular: ::std::os::raw::c_int,
    pub FocusRequestNextCounterTabStop: ::std::os::raw::c_int,
    pub FocusTabPressed: bool,
    pub DrawData: ImDrawData,
    pub DrawDataBuilder: ImDrawDataBuilder,
    pub DimBgRatio: f32,
    pub BackgroundDrawList: ImDrawList,
    pub ForegroundDrawList: ImDrawList,
    pub MouseCursor: ImGuiMouseCursor,
    pub DragDropActive: bool,
    pub DragDropWithinSource: bool,
    pub DragDropWithinTarget: bool,
    pub DragDropSourceFlags: ImGuiDragDropFlags,
    pub DragDropSourceFrameCount: ::std::os::raw::c_int,
    pub DragDropMouseButton: ::std::os::raw::c_int,
    pub DragDropPayload: ImGuiPayload,
    pub DragDropTargetRect: ImRect,
    pub DragDropTargetId: ImGuiID,
    pub DragDropAcceptFlags: ImGuiDragDropFlags,
    pub DragDropAcceptIdCurrRectSurface: f32,
    pub DragDropAcceptIdCurr: ImGuiID,
    pub DragDropAcceptIdPrev: ImGuiID,
    pub DragDropAcceptFrameCount: ::std::os::raw::c_int,
    pub DragDropPayloadBufHeap: ImVector_unsigned_char,
    pub DragDropPayloadBufLocal: [::std::os::raw::c_uchar; 16usize],
    pub CurrentTabBar: *mut ImGuiTabBar,
    pub TabBars: ImPool_ImGuiTabBar,
    pub CurrentTabBarStack: ImVector_ImGuiPtrOrIndex,
    pub ShrinkWidthBuffer: ImVector_ImGuiShrinkWidthItem,
    pub LastValidMousePos: ImVec2,
    pub InputTextState: ImGuiInputTextState,
    pub InputTextPasswordFont: ImFont,
    pub TempInputId: ImGuiID,
    pub ColorEditOptions: ImGuiColorEditFlags,
    pub ColorEditLastHue: f32,
    pub ColorEditLastSat: f32,
    pub ColorEditLastColor: [f32; 3usize],
    pub ColorPickerRef: ImVec4,
    pub DragCurrentAccumDirty: bool,
    pub DragCurrentAccum: f32,
    pub DragSpeedDefaultRatio: f32,
    pub ScrollbarClickDeltaToGrabCenter: f32,
    pub TooltipOverrideCount: ::std::os::raw::c_int,
    pub ClipboardHandlerData: ImVector_char,
    pub MenusIdSubmittedThisFrame: ImVector_ImGuiID,
    pub PlatformImePos: ImVec2,
    pub PlatformImeLastPos: ImVec2,
    pub SettingsLoaded: bool,
    pub SettingsDirtyTimer: f32,
    pub SettingsIniData: ImGuiTextBuffer,
    pub SettingsHandlers: ImVector_ImGuiSettingsHandler,
    pub SettingsWindows: ImChunkStream_ImGuiWindowSettings,
    pub LogEnabled: bool,
    pub LogType: ImGuiLogType,
    pub LogFile: ImFileHandle,
    pub LogBuffer: ImGuiTextBuffer,
    pub LogLinePosY: f32,
    pub LogLineFirstItem: bool,
    pub LogDepthRef: ::std::os::raw::c_int,
    pub LogDepthToExpand: ::std::os::raw::c_int,
    pub LogDepthToExpandDefault: ::std::os::raw::c_int,
    pub DebugItemPickerActive: bool,
    pub DebugItemPickerBreakId: ImGuiID,
    pub FramerateSecPerFrame: [f32; 120usize],
    pub FramerateSecPerFrameIdx: ::std::os::raw::c_int,
    pub FramerateSecPerFrameAccum: f32,
    pub WantCaptureMouseNextFrame: ::std::os::raw::c_int,
    pub WantCaptureKeyboardNextFrame: ::std::os::raw::c_int,
    pub WantTextInputNextFrame: ::std::os::raw::c_int,
    pub TempBuffer: [::std::os::raw::c_char; 3073usize],
}
#[test]
fn bindgen_test_layout_ImGuiContext() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiContext>(),
        15840usize,
        concat!("Size of: ", stringify!(ImGuiContext))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiContext>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).Initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(Initialized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FontAtlasOwnedByContext as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FontAtlasOwnedByContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).IO as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(IO)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).Style as *const _ as usize },
        5480usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(Style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).Font as *const _ as usize },
        6432usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(Font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FontSize as *const _ as usize },
        6440usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FontSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FontBaseSize as *const _ as usize },
        6444usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FontBaseSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DrawListSharedData as *const _ as usize },
        6448usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DrawListSharedData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).Time as *const _ as usize },
        6656usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(Time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FrameCount as *const _ as usize },
        6664usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FrameCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FrameCountEnded as *const _ as usize },
        6668usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FrameCountEnded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FrameCountRendered as *const _ as usize },
        6672usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FrameCountRendered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).WithinFrameScope as *const _ as usize },
        6676usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WithinFrameScope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WithinFrameScopeWithImplicitWindow as *const _
                as usize
        },
        6677usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WithinFrameScopeWithImplicitWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).WithinEndChild as *const _ as usize },
        6678usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WithinEndChild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).Windows as *const _ as usize },
        6680usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(Windows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).WindowsFocusOrder as *const _ as usize },
        6696usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WindowsFocusOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WindowsTempSortBuffer as *const _ as usize
        },
        6712usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WindowsTempSortBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).CurrentWindowStack as *const _ as usize },
        6728usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(CurrentWindowStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).WindowsById as *const _ as usize },
        6744usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WindowsById)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).WindowsActiveCount as *const _ as usize },
        6760usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WindowsActiveCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).CurrentWindow as *const _ as usize },
        6768usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(CurrentWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).HoveredWindow as *const _ as usize },
        6776usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).HoveredRootWindow as *const _ as usize },
        6784usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredRootWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).MovingWindow as *const _ as usize },
        6792usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(MovingWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).WheelingWindow as *const _ as usize },
        6800usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WheelingWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WheelingWindowRefMousePos as *const _ as usize
        },
        6808usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WheelingWindowRefMousePos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WheelingWindowTimer as *const _ as usize
        },
        6816usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WheelingWindowTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).HoveredId as *const _ as usize },
        6820usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).HoveredIdAllowOverlap as *const _ as usize
        },
        6824usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredIdAllowOverlap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).HoveredIdPreviousFrame as *const _ as usize
        },
        6828usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredIdPreviousFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).HoveredIdTimer as *const _ as usize },
        6832usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredIdTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).HoveredIdNotActiveTimer as *const _ as usize
        },
        6836usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(HoveredIdNotActiveTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ActiveId as *const _ as usize },
        6840usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdIsAlive as *const _ as usize },
        6844usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdIsAlive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdTimer as *const _ as usize },
        6848usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdIsJustActivated as *const _ as usize
        },
        6852usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdIsJustActivated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdAllowOverlap as *const _ as usize
        },
        6853usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdAllowOverlap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdHasBeenPressedBefore as *const _
                as usize
        },
        6854usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdHasBeenPressedBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdHasBeenEditedBefore as *const _
                as usize
        },
        6855usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdHasBeenEditedBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdHasBeenEditedThisFrame as *const _
                as usize
        },
        6856usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdHasBeenEditedThisFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdUsingNavDirMask as *const _ as usize
        },
        6860usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdUsingNavDirMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdUsingNavInputMask as *const _ as usize
        },
        6864usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdUsingNavInputMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdUsingKeyInputMask as *const _ as usize
        },
        6872usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdUsingKeyInputMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdClickOffset as *const _ as usize
        },
        6880usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdClickOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdWindow as *const _ as usize },
        6888usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdSource as *const _ as usize },
        6896usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdMouseButton as *const _ as usize
        },
        6900usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdMouseButton)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdPreviousFrame as *const _ as usize
        },
        6904usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdPreviousFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdPreviousFrameIsAlive as *const _
                as usize
        },
        6908usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdPreviousFrameIsAlive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdPreviousFrameHasBeenEditedBefore
                as *const _ as usize
        },
        6909usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdPreviousFrameHasBeenEditedBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ActiveIdPreviousFrameWindow as *const _
                as usize
        },
        6912usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ActiveIdPreviousFrameWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LastActiveId as *const _ as usize },
        6920usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LastActiveId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LastActiveIdTimer as *const _ as usize },
        6924usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LastActiveIdTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NextWindowData as *const _ as usize },
        6928usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NextWindowData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NextItemData as *const _ as usize },
        7032usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NextItemData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ColorModifiers as *const _ as usize },
        7056usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ColorModifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).StyleModifiers as *const _ as usize },
        7072usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(StyleModifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FontStack as *const _ as usize },
        7088usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FontStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).OpenPopupStack as *const _ as usize },
        7104usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(OpenPopupStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).BeginPopupStack as *const _ as usize },
        7120usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(BeginPopupStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavWindow as *const _ as usize },
        7136usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavId as *const _ as usize },
        7144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavFocusScopeId as *const _ as usize },
        7148usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavFocusScopeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavActivateId as *const _ as usize },
        7152usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavActivateId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavActivateDownId as *const _ as usize },
        7156usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavActivateDownId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavActivatePressedId as *const _ as usize
        },
        7160usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavActivatePressedId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavInputId as *const _ as usize },
        7164usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavInputId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavJustTabbedId as *const _ as usize },
        7168usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavJustTabbedId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavJustMovedToId as *const _ as usize },
        7172usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavJustMovedToId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavJustMovedToFocusScopeId as *const _ as usize
        },
        7176usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavJustMovedToFocusScopeId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavJustMovedToKeyMods as *const _ as usize
        },
        7180usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavJustMovedToKeyMods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavNextActivateId as *const _ as usize },
        7184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavNextActivateId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavInputSource as *const _ as usize },
        7188usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavInputSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavScoringRect as *const _ as usize },
        7192usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavScoringRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavScoringCount as *const _ as usize },
        7208usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavScoringCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavLayer as *const _ as usize },
        7212usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavIdTabCounter as *const _ as usize },
        7216usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavIdTabCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavIdIsAlive as *const _ as usize },
        7220usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavIdIsAlive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMousePosDirty as *const _ as usize },
        7221usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMousePosDirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavDisableHighlight as *const _ as usize
        },
        7222usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavDisableHighlight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavDisableMouseHover as *const _ as usize
        },
        7223usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavDisableMouseHover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavAnyRequest as *const _ as usize },
        7224usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavAnyRequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavInitRequest as *const _ as usize },
        7225usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavInitRequest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavInitRequestFromMove as *const _ as usize
        },
        7226usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavInitRequestFromMove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavInitResultId as *const _ as usize },
        7228usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavInitResultId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavInitResultRectRel as *const _ as usize
        },
        7232usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavInitResultRectRel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavMoveFromClampedRefRect as *const _ as usize
        },
        7248usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveFromClampedRefRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMoveRequest as *const _ as usize },
        7249usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveRequest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavMoveRequestFlags as *const _ as usize
        },
        7252usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveRequestFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavMoveRequestForward as *const _ as usize
        },
        7256usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveRequestForward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavMoveRequestKeyMods as *const _ as usize
        },
        7260usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveRequestKeyMods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMoveDir as *const _ as usize },
        7264usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveDir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMoveDirLast as *const _ as usize },
        7268usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveDirLast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMoveClipDir as *const _ as usize },
        7272usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveClipDir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMoveResultLocal as *const _ as usize },
        7280usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveResultLocal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavMoveResultLocalVisibleSet as *const _
                as usize
        },
        7328usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveResultLocalVisibleSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavMoveResultOther as *const _ as usize },
        7376usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavMoveResultOther)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavWindowingTarget as *const _ as usize },
        7424usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindowingTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavWindowingTargetAnim as *const _ as usize
        },
        7432usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindowingTargetAnim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavWindowingList as *const _ as usize },
        7440usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindowingList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).NavWindowingTimer as *const _ as usize },
        7448usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindowingTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavWindowingHighlightAlpha as *const _ as usize
        },
        7452usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindowingHighlightAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).NavWindowingToggleLayer as *const _ as usize
        },
        7456usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(NavWindowingToggleLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FocusRequestCurrWindow as *const _ as usize
        },
        7464usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusRequestCurrWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FocusRequestNextWindow as *const _ as usize
        },
        7472usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusRequestNextWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FocusRequestCurrCounterRegular as *const _
                as usize
        },
        7480usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusRequestCurrCounterRegular)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FocusRequestCurrCounterTabStop as *const _
                as usize
        },
        7484usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusRequestCurrCounterTabStop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FocusRequestNextCounterRegular as *const _
                as usize
        },
        7488usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusRequestNextCounterRegular)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FocusRequestNextCounterTabStop as *const _
                as usize
        },
        7492usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusRequestNextCounterTabStop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).FocusTabPressed as *const _ as usize },
        7496usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FocusTabPressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DrawData as *const _ as usize },
        7504usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DrawData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DrawDataBuilder as *const _ as usize },
        7560usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DrawDataBuilder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DimBgRatio as *const _ as usize },
        7592usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DimBgRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).BackgroundDrawList as *const _ as usize },
        7600usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(BackgroundDrawList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ForegroundDrawList as *const _ as usize },
        7768usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ForegroundDrawList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).MouseCursor as *const _ as usize },
        7936usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(MouseCursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DragDropActive as *const _ as usize },
        7940usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropActive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropWithinSource as *const _ as usize
        },
        7941usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropWithinSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropWithinTarget as *const _ as usize
        },
        7942usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropWithinTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropSourceFlags as *const _ as usize
        },
        7944usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropSourceFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropSourceFrameCount as *const _ as usize
        },
        7948usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropSourceFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropMouseButton as *const _ as usize
        },
        7952usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropMouseButton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DragDropPayload as *const _ as usize },
        7960usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropPayload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DragDropTargetRect as *const _ as usize },
        8024usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropTargetRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DragDropTargetId as *const _ as usize },
        8040usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropTargetId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropAcceptFlags as *const _ as usize
        },
        8044usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropAcceptFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropAcceptIdCurrRectSurface as *const _
                as usize
        },
        8048usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropAcceptIdCurrRectSurface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropAcceptIdCurr as *const _ as usize
        },
        8052usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropAcceptIdCurr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropAcceptIdPrev as *const _ as usize
        },
        8056usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropAcceptIdPrev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropAcceptFrameCount as *const _ as usize
        },
        8060usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropAcceptFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropPayloadBufHeap as *const _ as usize
        },
        8064usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropPayloadBufHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragDropPayloadBufLocal as *const _ as usize
        },
        8080usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragDropPayloadBufLocal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).CurrentTabBar as *const _ as usize },
        8096usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(CurrentTabBar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).TabBars as *const _ as usize },
        8104usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(TabBars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).CurrentTabBarStack as *const _ as usize },
        8144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(CurrentTabBarStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ShrinkWidthBuffer as *const _ as usize },
        8160usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ShrinkWidthBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LastValidMousePos as *const _ as usize },
        8176usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LastValidMousePos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).InputTextState as *const _ as usize },
        8184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(InputTextState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).InputTextPasswordFont as *const _ as usize
        },
        11912usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(InputTextPasswordFont)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).TempInputId as *const _ as usize },
        12032usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(TempInputId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ColorEditOptions as *const _ as usize },
        12036usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ColorEditOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ColorEditLastHue as *const _ as usize },
        12040usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ColorEditLastHue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ColorEditLastSat as *const _ as usize },
        12044usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ColorEditLastSat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ColorEditLastColor as *const _ as usize },
        12048usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ColorEditLastColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).ColorPickerRef as *const _ as usize },
        12060usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ColorPickerRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragCurrentAccumDirty as *const _ as usize
        },
        12076usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragCurrentAccumDirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).DragCurrentAccum as *const _ as usize },
        12080usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragCurrentAccum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DragSpeedDefaultRatio as *const _ as usize
        },
        12084usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DragSpeedDefaultRatio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ScrollbarClickDeltaToGrabCenter as *const _
                as usize
        },
        12088usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ScrollbarClickDeltaToGrabCenter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).TooltipOverrideCount as *const _ as usize
        },
        12092usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(TooltipOverrideCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).ClipboardHandlerData as *const _ as usize
        },
        12096usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(ClipboardHandlerData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).MenusIdSubmittedThisFrame as *const _ as usize
        },
        12112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(MenusIdSubmittedThisFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).PlatformImePos as *const _ as usize },
        12128usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(PlatformImePos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).PlatformImeLastPos as *const _ as usize },
        12136usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(PlatformImeLastPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).SettingsLoaded as *const _ as usize },
        12144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(SettingsLoaded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).SettingsDirtyTimer as *const _ as usize },
        12148usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(SettingsDirtyTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).SettingsIniData as *const _ as usize },
        12152usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(SettingsIniData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).SettingsHandlers as *const _ as usize },
        12168usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(SettingsHandlers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).SettingsWindows as *const _ as usize },
        12184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(SettingsWindows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogEnabled as *const _ as usize },
        12200usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogType as *const _ as usize },
        12204usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogFile as *const _ as usize },
        12208usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogBuffer as *const _ as usize },
        12216usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogLinePosY as *const _ as usize },
        12232usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogLinePosY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogLineFirstItem as *const _ as usize },
        12236usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogLineFirstItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogDepthRef as *const _ as usize },
        12240usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogDepthRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).LogDepthToExpand as *const _ as usize },
        12244usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogDepthToExpand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).LogDepthToExpandDefault as *const _ as usize
        },
        12248usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(LogDepthToExpandDefault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DebugItemPickerActive as *const _ as usize
        },
        12252usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DebugItemPickerActive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).DebugItemPickerBreakId as *const _ as usize
        },
        12256usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(DebugItemPickerBreakId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FramerateSecPerFrame as *const _ as usize
        },
        12260usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FramerateSecPerFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FramerateSecPerFrameIdx as *const _ as usize
        },
        12740usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FramerateSecPerFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).FramerateSecPerFrameAccum as *const _ as usize
        },
        12744usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(FramerateSecPerFrameAccum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WantCaptureMouseNextFrame as *const _ as usize
        },
        12748usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WantCaptureMouseNextFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WantCaptureKeyboardNextFrame as *const _
                as usize
        },
        12752usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WantCaptureKeyboardNextFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiContext>())).WantTextInputNextFrame as *const _ as usize
        },
        12756usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(WantTextInputNextFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiContext>())).TempBuffer as *const _ as usize },
        12760usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiContext),
            "::",
            stringify!(TempBuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiWindowTempData {
    pub CursorPos: ImVec2,
    pub CursorPosPrevLine: ImVec2,
    pub CursorStartPos: ImVec2,
    pub CursorMaxPos: ImVec2,
    pub CurrLineSize: ImVec2,
    pub PrevLineSize: ImVec2,
    pub CurrLineTextBaseOffset: f32,
    pub PrevLineTextBaseOffset: f32,
    pub Indent: ImVec1,
    pub ColumnsOffset: ImVec1,
    pub GroupOffset: ImVec1,
    pub LastItemId: ImGuiID,
    pub LastItemStatusFlags: ImGuiItemStatusFlags,
    pub LastItemRect: ImRect,
    pub LastItemDisplayRect: ImRect,
    pub NavLayerCurrent: ImGuiNavLayer,
    pub NavLayerCurrentMask: ::std::os::raw::c_int,
    pub NavLayerActiveMask: ::std::os::raw::c_int,
    pub NavLayerActiveMaskNext: ::std::os::raw::c_int,
    pub NavFocusScopeIdCurrent: ImGuiID,
    pub NavHideHighlightOneFrame: bool,
    pub NavHasScroll: bool,
    pub MenuBarAppending: bool,
    pub MenuBarOffset: ImVec2,
    pub MenuColumns: ImGuiMenuColumns,
    pub TreeDepth: ::std::os::raw::c_int,
    pub TreeJumpToParentOnPopMask: ImU32,
    pub ChildWindows: ImVector_ImGuiWindowPtr,
    pub StateStorage: *mut ImGuiStorage,
    pub CurrentColumns: *mut ImGuiColumns,
    pub LayoutType: ImGuiLayoutType,
    pub ParentLayoutType: ImGuiLayoutType,
    pub FocusCounterRegular: ::std::os::raw::c_int,
    pub FocusCounterTabStop: ::std::os::raw::c_int,
    pub ItemFlags: ImGuiItemFlags,
    pub ItemWidth: f32,
    pub TextWrapPos: f32,
    pub ItemFlagsStack: ImVector_ImGuiItemFlags,
    pub ItemWidthStack: ImVector_float,
    pub TextWrapPosStack: ImVector_float,
    pub GroupStack: ImVector_ImGuiGroupData,
    pub StackSizesBackup: [::std::os::raw::c_short; 6usize],
}
#[test]
fn bindgen_test_layout_ImGuiWindowTempData() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiWindowTempData>(),
        328usize,
        concat!("Size of: ", stringify!(ImGuiWindowTempData))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiWindowTempData>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiWindowTempData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).CursorPos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CursorPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).CursorPosPrevLine as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CursorPosPrevLine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).CursorStartPos as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CursorStartPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).CursorMaxPos as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CursorMaxPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).CurrLineSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CurrLineSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).PrevLineSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(PrevLineSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).CurrLineTextBaseOffset as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CurrLineTextBaseOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).PrevLineTextBaseOffset as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(PrevLineTextBaseOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).Indent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(Indent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).ColumnsOffset as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ColumnsOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).GroupOffset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(GroupOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).LastItemId as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(LastItemId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).LastItemStatusFlags as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(LastItemStatusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).LastItemRect as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(LastItemRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).LastItemDisplayRect as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(LastItemDisplayRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavLayerCurrent as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavLayerCurrent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavLayerCurrentMask as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavLayerCurrentMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavLayerActiveMask as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavLayerActiveMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavLayerActiveMaskNext as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavLayerActiveMaskNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavFocusScopeIdCurrent as *const _
                as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavFocusScopeIdCurrent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavHideHighlightOneFrame as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavHideHighlightOneFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).NavHasScroll as *const _ as usize
        },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(NavHasScroll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).MenuBarAppending as *const _ as usize
        },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(MenuBarAppending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).MenuBarOffset as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(MenuBarOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).MenuColumns as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(MenuColumns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).TreeDepth as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(TreeDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).TreeJumpToParentOnPopMask as *const _
                as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(TreeJumpToParentOnPopMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).ChildWindows as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ChildWindows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).StateStorage as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(StateStorage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).CurrentColumns as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(CurrentColumns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).LayoutType as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(LayoutType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).ParentLayoutType as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ParentLayoutType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).FocusCounterRegular as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(FocusCounterRegular)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).FocusCounterTabStop as *const _ as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(FocusCounterTabStop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).ItemFlags as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ItemFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).ItemWidth as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ItemWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).TextWrapPos as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(TextWrapPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).ItemFlagsStack as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ItemFlagsStack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).ItemWidthStack as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(ItemWidthStack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).TextWrapPosStack as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(TextWrapPosStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindowTempData>())).GroupStack as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(GroupStack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindowTempData>())).StackSizesBackup as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindowTempData),
            "::",
            stringify!(StackSizesBackup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiWindow {
    pub Name: *mut ::std::os::raw::c_char,
    pub ID: ImGuiID,
    pub Flags: ImGuiWindowFlags,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub SizeFull: ImVec2,
    pub ContentSize: ImVec2,
    pub ContentSizeExplicit: ImVec2,
    pub WindowPadding: ImVec2,
    pub WindowRounding: f32,
    pub WindowBorderSize: f32,
    pub NameBufLen: ::std::os::raw::c_int,
    pub MoveId: ImGuiID,
    pub ChildId: ImGuiID,
    pub Scroll: ImVec2,
    pub ScrollMax: ImVec2,
    pub ScrollTarget: ImVec2,
    pub ScrollTargetCenterRatio: ImVec2,
    pub ScrollbarSizes: ImVec2,
    pub ScrollbarX: bool,
    pub ScrollbarY: bool,
    pub Active: bool,
    pub WasActive: bool,
    pub WriteAccessed: bool,
    pub Collapsed: bool,
    pub WantCollapseToggle: bool,
    pub SkipItems: bool,
    pub Appearing: bool,
    pub Hidden: bool,
    pub IsFallbackWindow: bool,
    pub HasCloseButton: bool,
    pub ResizeBorderHeld: ::std::os::raw::c_schar,
    pub BeginCount: ::std::os::raw::c_short,
    pub BeginOrderWithinParent: ::std::os::raw::c_short,
    pub BeginOrderWithinContext: ::std::os::raw::c_short,
    pub PopupId: ImGuiID,
    pub AutoFitFramesX: ImS8,
    pub AutoFitFramesY: ImS8,
    pub AutoFitChildAxises: ImS8,
    pub AutoFitOnlyGrows: bool,
    pub AutoPosLastDirection: ImGuiDir,
    pub HiddenFramesCanSkipItems: ::std::os::raw::c_int,
    pub HiddenFramesCannotSkipItems: ::std::os::raw::c_int,
    pub SetWindowPosAllowFlags: ImGuiCond,
    pub SetWindowSizeAllowFlags: ImGuiCond,
    pub SetWindowCollapsedAllowFlags: ImGuiCond,
    pub SetWindowPosVal: ImVec2,
    pub SetWindowPosPivot: ImVec2,
    pub IDStack: ImVector_ImGuiID,
    pub DC: ImGuiWindowTempData,
    pub OuterRectClipped: ImRect,
    pub InnerRect: ImRect,
    pub InnerClipRect: ImRect,
    pub WorkRect: ImRect,
    pub ClipRect: ImRect,
    pub ContentRegionRect: ImRect,
    pub LastFrameActive: ::std::os::raw::c_int,
    pub LastTimeActive: f32,
    pub ItemWidthDefault: f32,
    pub StateStorage: ImGuiStorage,
    pub ColumnsStorage: ImVector_ImGuiColumns,
    pub FontWindowScale: f32,
    pub SettingsOffset: ::std::os::raw::c_int,
    pub DrawList: *mut ImDrawList,
    pub DrawListInst: ImDrawList,
    pub ParentWindow: *mut ImGuiWindow,
    pub RootWindow: *mut ImGuiWindow,
    pub RootWindowForTitleBarHighlight: *mut ImGuiWindow,
    pub RootWindowForNav: *mut ImGuiWindow,
    pub NavLastChildNavWindow: *mut ImGuiWindow,
    pub NavLastIds: [ImGuiID; 2usize],
    pub NavRectRel: [ImRect; 2usize],
    pub MemoryCompacted: bool,
    pub MemoryDrawListIdxCapacity: ::std::os::raw::c_int,
    pub MemoryDrawListVtxCapacity: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ImGuiWindow() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiWindow>(),
        960usize,
        concat!("Size of: ", stringify!(ImGuiWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiWindow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).SizeFull as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SizeFull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ContentSize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ContentSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ContentSizeExplicit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ContentSizeExplicit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WindowPadding as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WindowPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WindowRounding as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WindowRounding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WindowBorderSize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WindowBorderSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).NameBufLen as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(NameBufLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).MoveId as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(MoveId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ChildId as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ChildId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Scroll as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Scroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ScrollMax as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ScrollMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ScrollTarget as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ScrollTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).ScrollTargetCenterRatio as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ScrollTargetCenterRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ScrollbarSizes as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ScrollbarSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ScrollbarX as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ScrollbarX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ScrollbarY as *const _ as usize },
        125usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ScrollbarY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Active as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WasActive as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WasActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WriteAccessed as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WriteAccessed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Collapsed as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Collapsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WantCollapseToggle as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WantCollapseToggle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).SkipItems as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SkipItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Appearing as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Appearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).Hidden as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(Hidden)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).IsFallbackWindow as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(IsFallbackWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).HasCloseButton as *const _ as usize },
        135usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(HasCloseButton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ResizeBorderHeld as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ResizeBorderHeld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).BeginCount as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(BeginCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).BeginOrderWithinParent as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(BeginOrderWithinParent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).BeginOrderWithinContext as *const _ as usize
        },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(BeginOrderWithinContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).PopupId as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(PopupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).AutoFitFramesX as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(AutoFitFramesX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).AutoFitFramesY as *const _ as usize },
        149usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(AutoFitFramesY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).AutoFitChildAxises as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(AutoFitChildAxises)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).AutoFitOnlyGrows as *const _ as usize },
        151usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(AutoFitOnlyGrows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).AutoPosLastDirection as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(AutoPosLastDirection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).HiddenFramesCanSkipItems as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(HiddenFramesCanSkipItems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).HiddenFramesCannotSkipItems as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(HiddenFramesCannotSkipItems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).SetWindowPosAllowFlags as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SetWindowPosAllowFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).SetWindowSizeAllowFlags as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SetWindowSizeAllowFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).SetWindowCollapsedAllowFlags as *const _
                as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SetWindowCollapsedAllowFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).SetWindowPosVal as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SetWindowPosVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).SetWindowPosPivot as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SetWindowPosPivot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).IDStack as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(IDStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).DC as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(DC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).OuterRectClipped as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(OuterRectClipped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).InnerRect as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(InnerRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).InnerClipRect as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(InnerClipRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).WorkRect as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(WorkRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ClipRect as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ClipRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ContentRegionRect as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ContentRegionRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).LastFrameActive as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(LastFrameActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).LastTimeActive as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(LastTimeActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ItemWidthDefault as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ItemWidthDefault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).StateStorage as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(StateStorage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ColumnsStorage as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ColumnsStorage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).FontWindowScale as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(FontWindowScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).SettingsOffset as *const _ as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(SettingsOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).DrawList as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(DrawList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).DrawListInst as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(DrawListInst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).ParentWindow as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(ParentWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).RootWindow as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(RootWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).RootWindowForTitleBarHighlight as *const _
                as usize
        },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(RootWindowForTitleBarHighlight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).RootWindowForNav as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(RootWindowForNav)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).NavLastChildNavWindow as *const _ as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(NavLastChildNavWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).NavLastIds as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(NavLastIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).NavRectRel as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(NavRectRel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiWindow>())).MemoryCompacted as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(MemoryCompacted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).MemoryDrawListIdxCapacity as *const _ as usize
        },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(MemoryDrawListIdxCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiWindow>())).MemoryDrawListVtxCapacity as *const _ as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiWindow),
            "::",
            stringify!(MemoryDrawListVtxCapacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiItemHoveredDataBackup {
    pub LastItemId: ImGuiID,
    pub LastItemStatusFlags: ImGuiItemStatusFlags,
    pub LastItemRect: ImRect,
    pub LastItemDisplayRect: ImRect,
}
#[test]
fn bindgen_test_layout_ImGuiItemHoveredDataBackup() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiItemHoveredDataBackup>(),
        40usize,
        concat!("Size of: ", stringify!(ImGuiItemHoveredDataBackup))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiItemHoveredDataBackup>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiItemHoveredDataBackup))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiItemHoveredDataBackup>())).LastItemId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiItemHoveredDataBackup),
            "::",
            stringify!(LastItemId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiItemHoveredDataBackup>())).LastItemStatusFlags as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiItemHoveredDataBackup),
            "::",
            stringify!(LastItemStatusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiItemHoveredDataBackup>())).LastItemRect as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiItemHoveredDataBackup),
            "::",
            stringify!(LastItemRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiItemHoveredDataBackup>())).LastItemDisplayRect as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiItemHoveredDataBackup),
            "::",
            stringify!(LastItemDisplayRect)
        )
    );
}
pub const ImGuiTabBarFlagsPrivate__ImGuiTabBarFlags_DockNode: ImGuiTabBarFlagsPrivate_ = 1048576;
pub const ImGuiTabBarFlagsPrivate__ImGuiTabBarFlags_IsFocused: ImGuiTabBarFlagsPrivate_ = 2097152;
pub const ImGuiTabBarFlagsPrivate__ImGuiTabBarFlags_SaveSettings: ImGuiTabBarFlagsPrivate_ =
    4194304;
pub type ImGuiTabBarFlagsPrivate_ = u32;
pub const ImGuiTabItemFlagsPrivate__ImGuiTabItemFlags_NoCloseButton: ImGuiTabItemFlagsPrivate_ =
    1048576;
pub type ImGuiTabItemFlagsPrivate_ = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiTabItem {
    pub ID: ImGuiID,
    pub Flags: ImGuiTabItemFlags,
    pub LastFrameVisible: ::std::os::raw::c_int,
    pub LastFrameSelected: ::std::os::raw::c_int,
    pub NameOffset: ::std::os::raw::c_int,
    pub Offset: f32,
    pub Width: f32,
    pub ContentWidth: f32,
}
#[test]
fn bindgen_test_layout_ImGuiTabItem() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiTabItem>(),
        32usize,
        concat!("Size of: ", stringify!(ImGuiTabItem))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiTabItem>(),
        4usize,
        concat!("Alignment of ", stringify!(ImGuiTabItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).LastFrameVisible as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(LastFrameVisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).LastFrameSelected as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(LastFrameSelected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).NameOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(NameOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).Offset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).Width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabItem>())).ContentWidth as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabItem),
            "::",
            stringify!(ContentWidth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiTabBar {
    pub Tabs: ImVector_ImGuiTabItem,
    pub ID: ImGuiID,
    pub SelectedTabId: ImGuiID,
    pub NextSelectedTabId: ImGuiID,
    pub VisibleTabId: ImGuiID,
    pub CurrFrameVisible: ::std::os::raw::c_int,
    pub PrevFrameVisible: ::std::os::raw::c_int,
    pub BarRect: ImRect,
    pub LastTabContentHeight: f32,
    pub OffsetMax: f32,
    pub OffsetMaxIdeal: f32,
    pub OffsetNextTab: f32,
    pub ScrollingAnim: f32,
    pub ScrollingTarget: f32,
    pub ScrollingTargetDistToVisibility: f32,
    pub ScrollingSpeed: f32,
    pub Flags: ImGuiTabBarFlags,
    pub ReorderRequestTabId: ImGuiID,
    pub ReorderRequestDir: ImS8,
    pub WantLayout: bool,
    pub VisibleTabWasSubmitted: bool,
    pub LastTabItemIdx: ::std::os::raw::c_short,
    pub FramePadding: ImVec2,
    pub TabsNames: ImGuiTextBuffer,
}
#[test]
fn bindgen_test_layout_ImGuiTabBar() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiTabBar>(),
        128usize,
        concat!("Size of: ", stringify!(ImGuiTabBar))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiTabBar>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiTabBar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).Tabs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(Tabs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).ID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).SelectedTabId as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(SelectedTabId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).NextSelectedTabId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(NextSelectedTabId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).VisibleTabId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(VisibleTabId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).CurrFrameVisible as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(CurrFrameVisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).PrevFrameVisible as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(PrevFrameVisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).BarRect as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(BarRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiTabBar>())).LastTabContentHeight as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(LastTabContentHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).OffsetMax as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(OffsetMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).OffsetMaxIdeal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(OffsetMaxIdeal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).OffsetNextTab as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(OffsetNextTab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).ScrollingAnim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ScrollingAnim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).ScrollingTarget as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ScrollingTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiTabBar>())).ScrollingTargetDistToVisibility as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ScrollingTargetDistToVisibility)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).ScrollingSpeed as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ScrollingSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).Flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).ReorderRequestTabId as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ReorderRequestTabId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).ReorderRequestDir as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(ReorderRequestDir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).WantLayout as *const _ as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(WantLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiTabBar>())).VisibleTabWasSubmitted as *const _ as usize
        },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(VisibleTabWasSubmitted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).LastTabItemIdx as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(LastTabItemIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).FramePadding as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(FramePadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTabBar>())).TabsNames as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTabBar),
            "::",
            stringify!(TabsNames)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiTextRange {
    pub b: *const ::std::os::raw::c_char,
    pub e: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ImGuiTextRange() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiTextRange>(),
        16usize,
        concat!("Size of: ", stringify!(ImGuiTextRange))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiTextRange>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiTextRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTextRange>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTextRange),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiTextRange>())).e as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiTextRange),
            "::",
            stringify!(e)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiStoragePair {
    pub key: ImGuiID,
    pub __bindgen_anon_1: ImGuiStoragePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiStoragePair__bindgen_ty_1 {
    pub val_i: ::std::os::raw::c_int,
    pub val_f: f32,
    pub val_p: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ImGuiStoragePair__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiStoragePair__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ImGuiStoragePair__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiStoragePair__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiStoragePair__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStoragePair__bindgen_ty_1>())).val_i as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStoragePair__bindgen_ty_1),
            "::",
            stringify!(val_i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStoragePair__bindgen_ty_1>())).val_f as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStoragePair__bindgen_ty_1),
            "::",
            stringify!(val_f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImGuiStoragePair__bindgen_ty_1>())).val_p as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStoragePair__bindgen_ty_1),
            "::",
            stringify!(val_p)
        )
    );
}
#[test]
fn bindgen_test_layout_ImGuiStoragePair() {
    assert_eq!(
        ::std::mem::size_of::<ImGuiStoragePair>(),
        16usize,
        concat!("Size of: ", stringify!(ImGuiStoragePair))
    );
    assert_eq!(
        ::std::mem::align_of::<ImGuiStoragePair>(),
        8usize,
        concat!("Alignment of ", stringify!(ImGuiStoragePair))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImGuiStoragePair>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImGuiStoragePair),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    pub fn ImVec2_ImVec2Nil() -> *mut ImVec2;
}
extern "C" {
    pub fn ImVec2_destroy(self_: *mut ImVec2);
}
extern "C" {
    pub fn ImVec2_ImVec2Float(_x: f32, _y: f32) -> *mut ImVec2;
}
extern "C" {
    pub fn ImVec4_ImVec4Nil() -> *mut ImVec4;
}
extern "C" {
    pub fn ImVec4_destroy(self_: *mut ImVec4);
}
extern "C" {
    pub fn ImVec4_ImVec4Float(_x: f32, _y: f32, _z: f32, _w: f32) -> *mut ImVec4;
}
extern "C" {
    pub fn igCreateContext(shared_font_atlas: *mut ImFontAtlas) -> *mut ImGuiContext;
}
extern "C" {
    pub fn igDestroyContext(ctx: *mut ImGuiContext);
}
extern "C" {
    pub fn igGetCurrentContext() -> *mut ImGuiContext;
}
extern "C" {
    pub fn igSetCurrentContext(ctx: *mut ImGuiContext);
}
extern "C" {
    pub fn igGetIO() -> *mut ImGuiIO;
}
extern "C" {
    pub fn igGetStyle() -> *mut ImGuiStyle;
}
extern "C" {
    pub fn igNewFrame();
}
extern "C" {
    pub fn igEndFrame();
}
extern "C" {
    pub fn igRender();
}
extern "C" {
    pub fn igGetDrawData() -> *mut ImDrawData;
}
extern "C" {
    pub fn igShowDemoWindow(p_open: *mut bool);
}
extern "C" {
    pub fn igShowAboutWindow(p_open: *mut bool);
}
extern "C" {
    pub fn igShowMetricsWindow(p_open: *mut bool);
}
extern "C" {
    pub fn igShowStyleEditor(ref_: *mut ImGuiStyle);
}
extern "C" {
    pub fn igShowStyleSelector(label: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn igShowFontSelector(label: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igShowUserGuide();
}
extern "C" {
    pub fn igGetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igStyleColorsDark(dst: *mut ImGuiStyle);
}
extern "C" {
    pub fn igStyleColorsClassic(dst: *mut ImGuiStyle);
}
extern "C" {
    pub fn igStyleColorsLight(dst: *mut ImGuiStyle);
}
extern "C" {
    pub fn igBegin(
        name: *const ::std::os::raw::c_char,
        p_open: *mut bool,
        flags: ImGuiWindowFlags,
    ) -> bool;
}
extern "C" {
    pub fn igEnd();
}
extern "C" {
    pub fn igBeginChildStr(
        str_id: *const ::std::os::raw::c_char,
        size: ImVec2,
        border: bool,
        flags: ImGuiWindowFlags,
    ) -> bool;
}
extern "C" {
    pub fn igBeginChildID(id: ImGuiID, size: ImVec2, border: bool, flags: ImGuiWindowFlags)
        -> bool;
}
extern "C" {
    pub fn igEndChild();
}
extern "C" {
    pub fn igIsWindowAppearing() -> bool;
}
extern "C" {
    pub fn igIsWindowCollapsed() -> bool;
}
extern "C" {
    pub fn igIsWindowFocused(flags: ImGuiFocusedFlags) -> bool;
}
extern "C" {
    pub fn igIsWindowHovered(flags: ImGuiHoveredFlags) -> bool;
}
extern "C" {
    pub fn igGetWindowDrawList() -> *mut ImDrawList;
}
extern "C" {
    pub fn igGetWindowPos(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetWindowSize(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetWindowWidth() -> f32;
}
extern "C" {
    pub fn igGetWindowHeight() -> f32;
}
extern "C" {
    pub fn igSetNextWindowPos(pos: ImVec2, cond: ImGuiCond, pivot: ImVec2);
}
extern "C" {
    pub fn igSetNextWindowSize(size: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetNextWindowSizeConstraints(
        size_min: ImVec2,
        size_max: ImVec2,
        custom_callback: ImGuiSizeCallback,
        custom_callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn igSetNextWindowContentSize(size: ImVec2);
}
extern "C" {
    pub fn igSetNextWindowCollapsed(collapsed: bool, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetNextWindowFocus();
}
extern "C" {
    pub fn igSetNextWindowBgAlpha(alpha: f32);
}
extern "C" {
    pub fn igSetWindowPosVec2(pos: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowSizeVec2(size: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowCollapsedBool(collapsed: bool, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowFocusNil();
}
extern "C" {
    pub fn igSetWindowFontScale(scale: f32);
}
extern "C" {
    pub fn igSetWindowPosStr(name: *const ::std::os::raw::c_char, pos: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowSizeStr(name: *const ::std::os::raw::c_char, size: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowCollapsedStr(
        name: *const ::std::os::raw::c_char,
        collapsed: bool,
        cond: ImGuiCond,
    );
}
extern "C" {
    pub fn igSetWindowFocusStr(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igGetContentRegionMax(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetContentRegionAvail(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetWindowContentRegionMin(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetWindowContentRegionMax(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetWindowContentRegionWidth() -> f32;
}
extern "C" {
    pub fn igGetScrollX() -> f32;
}
extern "C" {
    pub fn igGetScrollY() -> f32;
}
extern "C" {
    pub fn igGetScrollMaxX() -> f32;
}
extern "C" {
    pub fn igGetScrollMaxY() -> f32;
}
extern "C" {
    pub fn igSetScrollXFloat(scroll_x: f32);
}
extern "C" {
    pub fn igSetScrollYFloat(scroll_y: f32);
}
extern "C" {
    pub fn igSetScrollHereX(center_x_ratio: f32);
}
extern "C" {
    pub fn igSetScrollHereY(center_y_ratio: f32);
}
extern "C" {
    pub fn igSetScrollFromPosXFloat(local_x: f32, center_x_ratio: f32);
}
extern "C" {
    pub fn igSetScrollFromPosYFloat(local_y: f32, center_y_ratio: f32);
}
extern "C" {
    pub fn igPushFont(font: *mut ImFont);
}
extern "C" {
    pub fn igPopFont();
}
extern "C" {
    pub fn igPushStyleColorU32(idx: ImGuiCol, col: ImU32);
}
extern "C" {
    pub fn igPushStyleColorVec4(idx: ImGuiCol, col: ImVec4);
}
extern "C" {
    pub fn igPopStyleColor(count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igPushStyleVarFloat(idx: ImGuiStyleVar, val: f32);
}
extern "C" {
    pub fn igPushStyleVarVec2(idx: ImGuiStyleVar, val: ImVec2);
}
extern "C" {
    pub fn igPopStyleVar(count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igGetStyleColorVec4(idx: ImGuiCol) -> *const ImVec4;
}
extern "C" {
    pub fn igGetFont() -> *mut ImFont;
}
extern "C" {
    pub fn igGetFontSize() -> f32;
}
extern "C" {
    pub fn igGetFontTexUvWhitePixel(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetColorU32Col(idx: ImGuiCol, alpha_mul: f32) -> ImU32;
}
extern "C" {
    pub fn igGetColorU32Vec4(col: ImVec4) -> ImU32;
}
extern "C" {
    pub fn igGetColorU32U32(col: ImU32) -> ImU32;
}
extern "C" {
    pub fn igPushItemWidth(item_width: f32);
}
extern "C" {
    pub fn igPopItemWidth();
}
extern "C" {
    pub fn igSetNextItemWidth(item_width: f32);
}
extern "C" {
    pub fn igCalcItemWidth() -> f32;
}
extern "C" {
    pub fn igPushTextWrapPos(wrap_local_pos_x: f32);
}
extern "C" {
    pub fn igPopTextWrapPos();
}
extern "C" {
    pub fn igPushAllowKeyboardFocus(allow_keyboard_focus: bool);
}
extern "C" {
    pub fn igPopAllowKeyboardFocus();
}
extern "C" {
    pub fn igPushButtonRepeat(repeat: bool);
}
extern "C" {
    pub fn igPopButtonRepeat();
}
extern "C" {
    pub fn igSeparator();
}
extern "C" {
    pub fn igSameLine(offset_from_start_x: f32, spacing: f32);
}
extern "C" {
    pub fn igNewLine();
}
extern "C" {
    pub fn igSpacing();
}
extern "C" {
    pub fn igDummy(size: ImVec2);
}
extern "C" {
    pub fn igIndent(indent_w: f32);
}
extern "C" {
    pub fn igUnindent(indent_w: f32);
}
extern "C" {
    pub fn igBeginGroup();
}
extern "C" {
    pub fn igEndGroup();
}
extern "C" {
    pub fn igGetCursorPos(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetCursorPosX() -> f32;
}
extern "C" {
    pub fn igGetCursorPosY() -> f32;
}
extern "C" {
    pub fn igSetCursorPos(local_pos: ImVec2);
}
extern "C" {
    pub fn igSetCursorPosX(local_x: f32);
}
extern "C" {
    pub fn igSetCursorPosY(local_y: f32);
}
extern "C" {
    pub fn igGetCursorStartPos(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetCursorScreenPos(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igSetCursorScreenPos(pos: ImVec2);
}
extern "C" {
    pub fn igAlignTextToFramePadding();
}
extern "C" {
    pub fn igGetTextLineHeight() -> f32;
}
extern "C" {
    pub fn igGetTextLineHeightWithSpacing() -> f32;
}
extern "C" {
    pub fn igGetFrameHeight() -> f32;
}
extern "C" {
    pub fn igGetFrameHeightWithSpacing() -> f32;
}
extern "C" {
    pub fn igPushIDStr(str_id: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igPushIDStrStr(
        str_id_begin: *const ::std::os::raw::c_char,
        str_id_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn igPushIDPtr(ptr_id: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn igPushIDInt(int_id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igPopID();
}
extern "C" {
    pub fn igGetIDStr(str_id: *const ::std::os::raw::c_char) -> ImGuiID;
}
extern "C" {
    pub fn igGetIDStrStr(
        str_id_begin: *const ::std::os::raw::c_char,
        str_id_end: *const ::std::os::raw::c_char,
    ) -> ImGuiID;
}
extern "C" {
    pub fn igGetIDPtr(ptr_id: *const ::std::os::raw::c_void) -> ImGuiID;
}
extern "C" {
    pub fn igTextUnformatted(
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn igText(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn igTextV(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
}
extern "C" {
    pub fn igTextColored(col: ImVec4, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn igTextColoredV(
        col: ImVec4,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn igTextDisabled(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn igTextDisabledV(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
}
extern "C" {
    pub fn igTextWrapped(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn igTextWrappedV(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
}
extern "C" {
    pub fn igLabelText(
        label: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn igLabelTextV(
        label: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn igBulletText(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn igBulletTextV(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
}
extern "C" {
    pub fn igButton(label: *const ::std::os::raw::c_char, size: ImVec2) -> bool;
}
extern "C" {
    pub fn igSmallButton(label: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn igInvisibleButton(str_id: *const ::std::os::raw::c_char, size: ImVec2) -> bool;
}
extern "C" {
    pub fn igArrowButton(str_id: *const ::std::os::raw::c_char, dir: ImGuiDir) -> bool;
}
extern "C" {
    pub fn igImage(
        user_texture_id: ImTextureID,
        size: ImVec2,
        uv0: ImVec2,
        uv1: ImVec2,
        tint_col: ImVec4,
        border_col: ImVec4,
    );
}
extern "C" {
    pub fn igImageButton(
        user_texture_id: ImTextureID,
        size: ImVec2,
        uv0: ImVec2,
        uv1: ImVec2,
        frame_padding: ::std::os::raw::c_int,
        bg_col: ImVec4,
        tint_col: ImVec4,
    ) -> bool;
}
extern "C" {
    pub fn igCheckbox(label: *const ::std::os::raw::c_char, v: *mut bool) -> bool;
}
extern "C" {
    pub fn igCheckboxFlags(
        label: *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_uint,
        flags_value: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn igRadioButtonBool(label: *const ::std::os::raw::c_char, active: bool) -> bool;
}
extern "C" {
    pub fn igRadioButtonIntPtr(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igProgressBar(fraction: f32, size_arg: ImVec2, overlay: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igBullet();
}
extern "C" {
    pub fn igBeginCombo(
        label: *const ::std::os::raw::c_char,
        preview_value: *const ::std::os::raw::c_char,
        flags: ImGuiComboFlags,
    ) -> bool;
}
extern "C" {
    pub fn igEndCombo();
}
extern "C" {
    pub fn igComboStr_arr(
        label: *const ::std::os::raw::c_char,
        current_item: *mut ::std::os::raw::c_int,
        items: *const *const ::std::os::raw::c_char,
        items_count: ::std::os::raw::c_int,
        popup_max_height_in_items: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igComboStr(
        label: *const ::std::os::raw::c_char,
        current_item: *mut ::std::os::raw::c_int,
        items_separated_by_zeros: *const ::std::os::raw::c_char,
        popup_max_height_in_items: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igComboFnPtr(
        label: *const ::std::os::raw::c_char,
        current_item: *mut ::std::os::raw::c_int,
        items_getter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                idx: ::std::os::raw::c_int,
                out_text: *mut *const ::std::os::raw::c_char,
            ) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
        items_count: ::std::os::raw::c_int,
        popup_max_height_in_items: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igDragFloat(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_speed: f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igDragFloat2(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_speed: f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igDragFloat3(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_speed: f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igDragFloat4(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_speed: f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igDragFloatRange2(
        label: *const ::std::os::raw::c_char,
        v_current_min: *mut f32,
        v_current_max: *mut f32,
        v_speed: f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        format_max: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igDragInt(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_speed: f32,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igDragInt2(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_speed: f32,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igDragInt3(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_speed: f32,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igDragInt4(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_speed: f32,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igDragIntRange2(
        label: *const ::std::os::raw::c_char,
        v_current_min: *mut ::std::os::raw::c_int,
        v_current_max: *mut ::std::os::raw::c_int,
        v_speed: f32,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        format_max: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igDragScalar(
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        v_speed: f32,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igDragScalarN(
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        components: ::std::os::raw::c_int,
        v_speed: f32,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igSliderFloat(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igSliderFloat2(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igSliderFloat3(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igSliderFloat4(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igSliderAngle(
        label: *const ::std::os::raw::c_char,
        v_rad: *mut f32,
        v_degrees_min: f32,
        v_degrees_max: f32,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igSliderInt(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igSliderInt2(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igSliderInt3(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igSliderInt4(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igSliderScalar(
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igSliderScalarN(
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        components: ::std::os::raw::c_int,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igVSliderFloat(
        label: *const ::std::os::raw::c_char,
        size: ImVec2,
        v: *mut f32,
        v_min: f32,
        v_max: f32,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igVSliderInt(
        label: *const ::std::os::raw::c_char,
        size: ImVec2,
        v: *mut ::std::os::raw::c_int,
        v_min: ::std::os::raw::c_int,
        v_max: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igVSliderScalar(
        label: *const ::std::os::raw::c_char,
        size: ImVec2,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
    ) -> bool;
}
extern "C" {
    pub fn igInputText(
        label: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        flags: ImGuiInputTextFlags,
        callback: ImGuiInputTextCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn igInputTextMultiline(
        label: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        size: ImVec2,
        flags: ImGuiInputTextFlags,
        callback: ImGuiInputTextCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn igInputTextWithHint(
        label: *const ::std::os::raw::c_char,
        hint: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        flags: ImGuiInputTextFlags,
        callback: ImGuiInputTextCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn igInputFloat(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        step: f32,
        step_fast: f32,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputFloat2(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputFloat3(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputFloat4(
        label: *const ::std::os::raw::c_char,
        v: *mut f32,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputInt(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
        step_fast: ::std::os::raw::c_int,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputInt2(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputInt3(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputInt4(
        label: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_int,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputDouble(
        label: *const ::std::os::raw::c_char,
        v: *mut f64,
        step: f64,
        step_fast: f64,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputScalar(
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        p_step: *const ::std::os::raw::c_void,
        p_step_fast: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igInputScalarN(
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        components: ::std::os::raw::c_int,
        p_step: *const ::std::os::raw::c_void,
        p_step_fast: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igColorEdit3(
        label: *const ::std::os::raw::c_char,
        col: *mut f32,
        flags: ImGuiColorEditFlags,
    ) -> bool;
}
extern "C" {
    pub fn igColorEdit4(
        label: *const ::std::os::raw::c_char,
        col: *mut f32,
        flags: ImGuiColorEditFlags,
    ) -> bool;
}
extern "C" {
    pub fn igColorPicker3(
        label: *const ::std::os::raw::c_char,
        col: *mut f32,
        flags: ImGuiColorEditFlags,
    ) -> bool;
}
extern "C" {
    pub fn igColorPicker4(
        label: *const ::std::os::raw::c_char,
        col: *mut f32,
        flags: ImGuiColorEditFlags,
        ref_col: *const f32,
    ) -> bool;
}
extern "C" {
    pub fn igColorButton(
        desc_id: *const ::std::os::raw::c_char,
        col: ImVec4,
        flags: ImGuiColorEditFlags,
        size: ImVec2,
    ) -> bool;
}
extern "C" {
    pub fn igSetColorEditOptions(flags: ImGuiColorEditFlags);
}
extern "C" {
    pub fn igTreeNodeStr(label: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn igTreeNodeStrStr(
        str_id: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodePtr(
        ptr_id: *const ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeVStr(
        str_id: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeVPtr(
        ptr_id: *const ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeExStr(label: *const ::std::os::raw::c_char, flags: ImGuiTreeNodeFlags)
        -> bool;
}
extern "C" {
    pub fn igTreeNodeExStrStr(
        str_id: *const ::std::os::raw::c_char,
        flags: ImGuiTreeNodeFlags,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeExPtr(
        ptr_id: *const ::std::os::raw::c_void,
        flags: ImGuiTreeNodeFlags,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeExVStr(
        str_id: *const ::std::os::raw::c_char,
        flags: ImGuiTreeNodeFlags,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeExVPtr(
        ptr_id: *const ::std::os::raw::c_void,
        flags: ImGuiTreeNodeFlags,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> bool;
}
extern "C" {
    pub fn igTreePushStr(str_id: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igTreePushPtr(ptr_id: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn igTreePop();
}
extern "C" {
    pub fn igGetTreeNodeToLabelSpacing() -> f32;
}
extern "C" {
    pub fn igCollapsingHeaderTreeNodeFlags(
        label: *const ::std::os::raw::c_char,
        flags: ImGuiTreeNodeFlags,
    ) -> bool;
}
extern "C" {
    pub fn igCollapsingHeaderBoolPtr(
        label: *const ::std::os::raw::c_char,
        p_open: *mut bool,
        flags: ImGuiTreeNodeFlags,
    ) -> bool;
}
extern "C" {
    pub fn igSetNextItemOpen(is_open: bool, cond: ImGuiCond);
}
extern "C" {
    pub fn igSelectableBool(
        label: *const ::std::os::raw::c_char,
        selected: bool,
        flags: ImGuiSelectableFlags,
        size: ImVec2,
    ) -> bool;
}
extern "C" {
    pub fn igSelectableBoolPtr(
        label: *const ::std::os::raw::c_char,
        p_selected: *mut bool,
        flags: ImGuiSelectableFlags,
        size: ImVec2,
    ) -> bool;
}
extern "C" {
    pub fn igListBoxStr_arr(
        label: *const ::std::os::raw::c_char,
        current_item: *mut ::std::os::raw::c_int,
        items: *const *const ::std::os::raw::c_char,
        items_count: ::std::os::raw::c_int,
        height_in_items: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igListBoxFnPtr(
        label: *const ::std::os::raw::c_char,
        current_item: *mut ::std::os::raw::c_int,
        items_getter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                idx: ::std::os::raw::c_int,
                out_text: *mut *const ::std::os::raw::c_char,
            ) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
        items_count: ::std::os::raw::c_int,
        height_in_items: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igListBoxHeaderVec2(label: *const ::std::os::raw::c_char, size: ImVec2) -> bool;
}
extern "C" {
    pub fn igListBoxHeaderInt(
        label: *const ::std::os::raw::c_char,
        items_count: ::std::os::raw::c_int,
        height_in_items: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn igListBoxFooter();
}
extern "C" {
    pub fn igPlotLinesFloatPtr(
        label: *const ::std::os::raw::c_char,
        values: *const f32,
        values_count: ::std::os::raw::c_int,
        values_offset: ::std::os::raw::c_int,
        overlay_text: *const ::std::os::raw::c_char,
        scale_min: f32,
        scale_max: f32,
        graph_size: ImVec2,
        stride: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn igPlotLinesFnPtr(
        label: *const ::std::os::raw::c_char,
        values_getter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                idx: ::std::os::raw::c_int,
            ) -> f32,
        >,
        data: *mut ::std::os::raw::c_void,
        values_count: ::std::os::raw::c_int,
        values_offset: ::std::os::raw::c_int,
        overlay_text: *const ::std::os::raw::c_char,
        scale_min: f32,
        scale_max: f32,
        graph_size: ImVec2,
    );
}
extern "C" {
    pub fn igPlotHistogramFloatPtr(
        label: *const ::std::os::raw::c_char,
        values: *const f32,
        values_count: ::std::os::raw::c_int,
        values_offset: ::std::os::raw::c_int,
        overlay_text: *const ::std::os::raw::c_char,
        scale_min: f32,
        scale_max: f32,
        graph_size: ImVec2,
        stride: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn igPlotHistogramFnPtr(
        label: *const ::std::os::raw::c_char,
        values_getter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                idx: ::std::os::raw::c_int,
            ) -> f32,
        >,
        data: *mut ::std::os::raw::c_void,
        values_count: ::std::os::raw::c_int,
        values_offset: ::std::os::raw::c_int,
        overlay_text: *const ::std::os::raw::c_char,
        scale_min: f32,
        scale_max: f32,
        graph_size: ImVec2,
    );
}
extern "C" {
    pub fn igValueBool(prefix: *const ::std::os::raw::c_char, b: bool);
}
extern "C" {
    pub fn igValueInt(prefix: *const ::std::os::raw::c_char, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igValueUint(prefix: *const ::std::os::raw::c_char, v: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn igValueFloat(
        prefix: *const ::std::os::raw::c_char,
        v: f32,
        float_format: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn igBeginMenuBar() -> bool;
}
extern "C" {
    pub fn igEndMenuBar();
}
extern "C" {
    pub fn igBeginMainMenuBar() -> bool;
}
extern "C" {
    pub fn igEndMainMenuBar();
}
extern "C" {
    pub fn igBeginMenu(label: *const ::std::os::raw::c_char, enabled: bool) -> bool;
}
extern "C" {
    pub fn igEndMenu();
}
extern "C" {
    pub fn igMenuItemBool(
        label: *const ::std::os::raw::c_char,
        shortcut: *const ::std::os::raw::c_char,
        selected: bool,
        enabled: bool,
    ) -> bool;
}
extern "C" {
    pub fn igMenuItemBoolPtr(
        label: *const ::std::os::raw::c_char,
        shortcut: *const ::std::os::raw::c_char,
        p_selected: *mut bool,
        enabled: bool,
    ) -> bool;
}
extern "C" {
    pub fn igBeginTooltip();
}
extern "C" {
    pub fn igEndTooltip();
}
extern "C" {
    pub fn igSetTooltip(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn igSetTooltipV(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
}
extern "C" {
    pub fn igOpenPopup(str_id: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igBeginPopup(str_id: *const ::std::os::raw::c_char, flags: ImGuiWindowFlags) -> bool;
}
extern "C" {
    pub fn igBeginPopupContextItem(
        str_id: *const ::std::os::raw::c_char,
        mouse_button: ImGuiMouseButton,
    ) -> bool;
}
extern "C" {
    pub fn igBeginPopupContextWindow(
        str_id: *const ::std::os::raw::c_char,
        mouse_button: ImGuiMouseButton,
        also_over_items: bool,
    ) -> bool;
}
extern "C" {
    pub fn igBeginPopupContextVoid(
        str_id: *const ::std::os::raw::c_char,
        mouse_button: ImGuiMouseButton,
    ) -> bool;
}
extern "C" {
    pub fn igBeginPopupModal(
        name: *const ::std::os::raw::c_char,
        p_open: *mut bool,
        flags: ImGuiWindowFlags,
    ) -> bool;
}
extern "C" {
    pub fn igEndPopup();
}
extern "C" {
    pub fn igOpenPopupOnItemClick(
        str_id: *const ::std::os::raw::c_char,
        mouse_button: ImGuiMouseButton,
    ) -> bool;
}
extern "C" {
    pub fn igIsPopupOpenStr(str_id: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn igCloseCurrentPopup();
}
extern "C" {
    pub fn igColumns(count: ::std::os::raw::c_int, id: *const ::std::os::raw::c_char, border: bool);
}
extern "C" {
    pub fn igNextColumn();
}
extern "C" {
    pub fn igGetColumnIndex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igGetColumnWidth(column_index: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn igSetColumnWidth(column_index: ::std::os::raw::c_int, width: f32);
}
extern "C" {
    pub fn igGetColumnOffset(column_index: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn igSetColumnOffset(column_index: ::std::os::raw::c_int, offset_x: f32);
}
extern "C" {
    pub fn igGetColumnsCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igBeginTabBar(str_id: *const ::std::os::raw::c_char, flags: ImGuiTabBarFlags) -> bool;
}
extern "C" {
    pub fn igEndTabBar();
}
extern "C" {
    pub fn igBeginTabItem(
        label: *const ::std::os::raw::c_char,
        p_open: *mut bool,
        flags: ImGuiTabItemFlags,
    ) -> bool;
}
extern "C" {
    pub fn igEndTabItem();
}
extern "C" {
    pub fn igSetTabItemClosed(tab_or_docked_window_label: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igLogToTTY(auto_open_depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igLogToFile(
        auto_open_depth: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn igLogToClipboard(auto_open_depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igLogFinish();
}
extern "C" {
    pub fn igLogButtons();
}
extern "C" {
    pub fn igBeginDragDropSource(flags: ImGuiDragDropFlags) -> bool;
}
extern "C" {
    pub fn igSetDragDropPayload(
        type_: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        sz: size_t,
        cond: ImGuiCond,
    ) -> bool;
}
extern "C" {
    pub fn igEndDragDropSource();
}
extern "C" {
    pub fn igBeginDragDropTarget() -> bool;
}
extern "C" {
    pub fn igAcceptDragDropPayload(
        type_: *const ::std::os::raw::c_char,
        flags: ImGuiDragDropFlags,
    ) -> *const ImGuiPayload;
}
extern "C" {
    pub fn igEndDragDropTarget();
}
extern "C" {
    pub fn igGetDragDropPayload() -> *const ImGuiPayload;
}
extern "C" {
    pub fn igPushClipRect(
        clip_rect_min: ImVec2,
        clip_rect_max: ImVec2,
        intersect_with_current_clip_rect: bool,
    );
}
extern "C" {
    pub fn igPopClipRect();
}
extern "C" {
    pub fn igSetItemDefaultFocus();
}
extern "C" {
    pub fn igSetKeyboardFocusHere(offset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igIsItemHovered(flags: ImGuiHoveredFlags) -> bool;
}
extern "C" {
    pub fn igIsItemActive() -> bool;
}
extern "C" {
    pub fn igIsItemFocused() -> bool;
}
extern "C" {
    pub fn igIsItemClicked(mouse_button: ImGuiMouseButton) -> bool;
}
extern "C" {
    pub fn igIsItemVisible() -> bool;
}
extern "C" {
    pub fn igIsItemEdited() -> bool;
}
extern "C" {
    pub fn igIsItemActivated() -> bool;
}
extern "C" {
    pub fn igIsItemDeactivated() -> bool;
}
extern "C" {
    pub fn igIsItemDeactivatedAfterEdit() -> bool;
}
extern "C" {
    pub fn igIsItemToggledOpen() -> bool;
}
extern "C" {
    pub fn igIsAnyItemHovered() -> bool;
}
extern "C" {
    pub fn igIsAnyItemActive() -> bool;
}
extern "C" {
    pub fn igIsAnyItemFocused() -> bool;
}
extern "C" {
    pub fn igGetItemRectMin(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetItemRectMax(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetItemRectSize(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igSetItemAllowOverlap();
}
extern "C" {
    pub fn igIsRectVisibleNil(size: ImVec2) -> bool;
}
extern "C" {
    pub fn igIsRectVisibleVec2(rect_min: ImVec2, rect_max: ImVec2) -> bool;
}
extern "C" {
    pub fn igGetTime() -> f64;
}
extern "C" {
    pub fn igGetFrameCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igGetBackgroundDrawList() -> *mut ImDrawList;
}
extern "C" {
    pub fn igGetForegroundDrawListNil() -> *mut ImDrawList;
}
extern "C" {
    pub fn igGetDrawListSharedData() -> *mut ImDrawListSharedData;
}
extern "C" {
    pub fn igGetStyleColorName(idx: ImGuiCol) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igSetStateStorage(storage: *mut ImGuiStorage);
}
extern "C" {
    pub fn igGetStateStorage() -> *mut ImGuiStorage;
}
extern "C" {
    pub fn igCalcListClipping(
        items_count: ::std::os::raw::c_int,
        items_height: f32,
        out_items_display_start: *mut ::std::os::raw::c_int,
        out_items_display_end: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn igBeginChildFrame(id: ImGuiID, size: ImVec2, flags: ImGuiWindowFlags) -> bool;
}
extern "C" {
    pub fn igEndChildFrame();
}
extern "C" {
    pub fn igCalcTextSize(
        pOut: *mut ImVec2,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        hide_text_after_double_hash: bool,
        wrap_width: f32,
    );
}
extern "C" {
    pub fn igColorConvertU32ToFloat4(pOut: *mut ImVec4, in_: ImU32);
}
extern "C" {
    pub fn igColorConvertFloat4ToU32(in_: ImVec4) -> ImU32;
}
extern "C" {
    pub fn igGetKeyIndex(imgui_key: ImGuiKey) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igIsKeyDown(user_key_index: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn igIsKeyPressed(user_key_index: ::std::os::raw::c_int, repeat: bool) -> bool;
}
extern "C" {
    pub fn igIsKeyReleased(user_key_index: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn igGetKeyPressedAmount(
        key_index: ::std::os::raw::c_int,
        repeat_delay: f32,
        rate: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igCaptureKeyboardFromApp(want_capture_keyboard_value: bool);
}
extern "C" {
    pub fn igIsMouseDown(button: ImGuiMouseButton) -> bool;
}
extern "C" {
    pub fn igIsMouseClicked(button: ImGuiMouseButton, repeat: bool) -> bool;
}
extern "C" {
    pub fn igIsMouseReleased(button: ImGuiMouseButton) -> bool;
}
extern "C" {
    pub fn igIsMouseDoubleClicked(button: ImGuiMouseButton) -> bool;
}
extern "C" {
    pub fn igIsMouseHoveringRect(r_min: ImVec2, r_max: ImVec2, clip: bool) -> bool;
}
extern "C" {
    pub fn igIsMousePosValid(mouse_pos: *const ImVec2) -> bool;
}
extern "C" {
    pub fn igIsAnyMouseDown() -> bool;
}
extern "C" {
    pub fn igGetMousePos(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igGetMousePosOnOpeningCurrentPopup(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igIsMouseDragging(button: ImGuiMouseButton, lock_threshold: f32) -> bool;
}
extern "C" {
    pub fn igGetMouseDragDelta(pOut: *mut ImVec2, button: ImGuiMouseButton, lock_threshold: f32);
}
extern "C" {
    pub fn igResetMouseDragDelta(button: ImGuiMouseButton);
}
extern "C" {
    pub fn igGetMouseCursor() -> ImGuiMouseCursor;
}
extern "C" {
    pub fn igSetMouseCursor(cursor_type: ImGuiMouseCursor);
}
extern "C" {
    pub fn igCaptureMouseFromApp(want_capture_mouse_value: bool);
}
extern "C" {
    pub fn igGetClipboardText() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igSetClipboardText(text: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igLoadIniSettingsFromDisk(ini_filename: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igLoadIniSettingsFromMemory(ini_data: *const ::std::os::raw::c_char, ini_size: size_t);
}
extern "C" {
    pub fn igSaveIniSettingsToDisk(ini_filename: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn igSaveIniSettingsToMemory(out_ini_size: *mut size_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igDebugCheckVersionAndDataLayout(
        version_str: *const ::std::os::raw::c_char,
        sz_io: size_t,
        sz_style: size_t,
        sz_vec2: size_t,
        sz_vec4: size_t,
        sz_drawvert: size_t,
        sz_drawidx: size_t,
    ) -> bool;
}
extern "C" {
    pub fn igSetAllocatorFunctions(
        alloc_func: ::std::option::Option<
            unsafe extern "C" fn(
                sz: size_t,
                user_data: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        free_func: ::std::option::Option<
            unsafe extern "C" fn(
                ptr: *mut ::std::os::raw::c_void,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn igMemAlloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn igMemFree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ImGuiStyle_ImGuiStyle() -> *mut ImGuiStyle;
}
extern "C" {
    pub fn ImGuiStyle_destroy(self_: *mut ImGuiStyle);
}
extern "C" {
    pub fn ImGuiStyle_ScaleAllSizes(self_: *mut ImGuiStyle, scale_factor: f32);
}
extern "C" {
    pub fn ImGuiIO_AddInputCharacter(self_: *mut ImGuiIO, c: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn ImGuiIO_AddInputCharacterUTF16(self_: *mut ImGuiIO, c: ImWchar16);
}
extern "C" {
    pub fn ImGuiIO_AddInputCharactersUTF8(self_: *mut ImGuiIO, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ImGuiIO_ClearInputCharacters(self_: *mut ImGuiIO);
}
extern "C" {
    pub fn ImGuiIO_ImGuiIO() -> *mut ImGuiIO;
}
extern "C" {
    pub fn ImGuiIO_destroy(self_: *mut ImGuiIO);
}
extern "C" {
    pub fn ImGuiInputTextCallbackData_ImGuiInputTextCallbackData() -> *mut ImGuiInputTextCallbackData;
}
extern "C" {
    pub fn ImGuiInputTextCallbackData_destroy(self_: *mut ImGuiInputTextCallbackData);
}
extern "C" {
    pub fn ImGuiInputTextCallbackData_DeleteChars(
        self_: *mut ImGuiInputTextCallbackData,
        pos: ::std::os::raw::c_int,
        bytes_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImGuiInputTextCallbackData_InsertChars(
        self_: *mut ImGuiInputTextCallbackData,
        pos: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ImGuiInputTextCallbackData_HasSelection(self_: *mut ImGuiInputTextCallbackData) -> bool;
}
extern "C" {
    pub fn ImGuiPayload_ImGuiPayload() -> *mut ImGuiPayload;
}
extern "C" {
    pub fn ImGuiPayload_destroy(self_: *mut ImGuiPayload);
}
extern "C" {
    pub fn ImGuiPayload_Clear(self_: *mut ImGuiPayload);
}
extern "C" {
    pub fn ImGuiPayload_IsDataType(
        self_: *mut ImGuiPayload,
        type_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ImGuiPayload_IsPreview(self_: *mut ImGuiPayload) -> bool;
}
extern "C" {
    pub fn ImGuiPayload_IsDelivery(self_: *mut ImGuiPayload) -> bool;
}
extern "C" {
    pub fn ImGuiOnceUponAFrame_ImGuiOnceUponAFrame() -> *mut ImGuiOnceUponAFrame;
}
extern "C" {
    pub fn ImGuiOnceUponAFrame_destroy(self_: *mut ImGuiOnceUponAFrame);
}
extern "C" {
    pub fn ImGuiTextFilter_ImGuiTextFilter(
        default_filter: *const ::std::os::raw::c_char,
    ) -> *mut ImGuiTextFilter;
}
extern "C" {
    pub fn ImGuiTextFilter_destroy(self_: *mut ImGuiTextFilter);
}
extern "C" {
    pub fn ImGuiTextFilter_Draw(
        self_: *mut ImGuiTextFilter,
        label: *const ::std::os::raw::c_char,
        width: f32,
    ) -> bool;
}
extern "C" {
    pub fn ImGuiTextFilter_PassFilter(
        self_: *mut ImGuiTextFilter,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ImGuiTextFilter_Build(self_: *mut ImGuiTextFilter);
}
extern "C" {
    pub fn ImGuiTextFilter_Clear(self_: *mut ImGuiTextFilter);
}
extern "C" {
    pub fn ImGuiTextFilter_IsActive(self_: *mut ImGuiTextFilter) -> bool;
}
extern "C" {
    pub fn ImGuiTextRange_ImGuiTextRangeNil() -> *mut ImGuiTextRange;
}
extern "C" {
    pub fn ImGuiTextRange_destroy(self_: *mut ImGuiTextRange);
}
extern "C" {
    pub fn ImGuiTextRange_ImGuiTextRangeStr(
        _b: *const ::std::os::raw::c_char,
        _e: *const ::std::os::raw::c_char,
    ) -> *mut ImGuiTextRange;
}
extern "C" {
    pub fn ImGuiTextRange_empty(self_: *mut ImGuiTextRange) -> bool;
}
extern "C" {
    pub fn ImGuiTextRange_split(
        self_: *mut ImGuiTextRange,
        separator: ::std::os::raw::c_char,
        out: *mut ImVector_ImGuiTextRange,
    );
}
extern "C" {
    pub fn ImGuiTextBuffer_ImGuiTextBuffer() -> *mut ImGuiTextBuffer;
}
extern "C" {
    pub fn ImGuiTextBuffer_destroy(self_: *mut ImGuiTextBuffer);
}
extern "C" {
    pub fn ImGuiTextBuffer_begin(self_: *mut ImGuiTextBuffer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ImGuiTextBuffer_end(self_: *mut ImGuiTextBuffer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ImGuiTextBuffer_size(self_: *mut ImGuiTextBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImGuiTextBuffer_empty(self_: *mut ImGuiTextBuffer) -> bool;
}
extern "C" {
    pub fn ImGuiTextBuffer_clear(self_: *mut ImGuiTextBuffer);
}
extern "C" {
    pub fn ImGuiTextBuffer_reserve(self_: *mut ImGuiTextBuffer, capacity: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImGuiTextBuffer_c_str(self_: *mut ImGuiTextBuffer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ImGuiTextBuffer_append(
        self_: *mut ImGuiTextBuffer,
        str_: *const ::std::os::raw::c_char,
        str_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ImGuiTextBuffer_appendfv(
        self_: *mut ImGuiTextBuffer,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn ImGuiStoragePair_ImGuiStoragePairInt(
        _key: ImGuiID,
        _val_i: ::std::os::raw::c_int,
    ) -> *mut ImGuiStoragePair;
}
extern "C" {
    pub fn ImGuiStoragePair_destroy(self_: *mut ImGuiStoragePair);
}
extern "C" {
    pub fn ImGuiStoragePair_ImGuiStoragePairFloat(
        _key: ImGuiID,
        _val_f: f32,
    ) -> *mut ImGuiStoragePair;
}
extern "C" {
    pub fn ImGuiStoragePair_ImGuiStoragePairPtr(
        _key: ImGuiID,
        _val_p: *mut ::std::os::raw::c_void,
    ) -> *mut ImGuiStoragePair;
}
extern "C" {
    pub fn ImGuiStorage_Clear(self_: *mut ImGuiStorage);
}
extern "C" {
    pub fn ImGuiStorage_GetInt(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
        default_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImGuiStorage_SetInt(self_: *mut ImGuiStorage, key: ImGuiID, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImGuiStorage_GetBool(self_: *mut ImGuiStorage, key: ImGuiID, default_val: bool) -> bool;
}
extern "C" {
    pub fn ImGuiStorage_SetBool(self_: *mut ImGuiStorage, key: ImGuiID, val: bool);
}
extern "C" {
    pub fn ImGuiStorage_GetFloat(self_: *mut ImGuiStorage, key: ImGuiID, default_val: f32) -> f32;
}
extern "C" {
    pub fn ImGuiStorage_SetFloat(self_: *mut ImGuiStorage, key: ImGuiID, val: f32);
}
extern "C" {
    pub fn ImGuiStorage_GetVoidPtr(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ImGuiStorage_SetVoidPtr(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
        val: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ImGuiStorage_GetIntRef(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
        default_val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImGuiStorage_GetBoolRef(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
        default_val: bool,
    ) -> *mut bool;
}
extern "C" {
    pub fn ImGuiStorage_GetFloatRef(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
        default_val: f32,
    ) -> *mut f32;
}
extern "C" {
    pub fn ImGuiStorage_GetVoidPtrRef(
        self_: *mut ImGuiStorage,
        key: ImGuiID,
        default_val: *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ImGuiStorage_SetAllInt(self_: *mut ImGuiStorage, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImGuiStorage_BuildSortByKey(self_: *mut ImGuiStorage);
}
extern "C" {
    pub fn ImGuiListClipper_ImGuiListClipper(
        items_count: ::std::os::raw::c_int,
        items_height: f32,
    ) -> *mut ImGuiListClipper;
}
extern "C" {
    pub fn ImGuiListClipper_destroy(self_: *mut ImGuiListClipper);
}
extern "C" {
    pub fn ImGuiListClipper_Step(self_: *mut ImGuiListClipper) -> bool;
}
extern "C" {
    pub fn ImGuiListClipper_Begin(
        self_: *mut ImGuiListClipper,
        items_count: ::std::os::raw::c_int,
        items_height: f32,
    );
}
extern "C" {
    pub fn ImGuiListClipper_End(self_: *mut ImGuiListClipper);
}
extern "C" {
    pub fn ImColor_ImColorNil() -> *mut ImColor;
}
extern "C" {
    pub fn ImColor_destroy(self_: *mut ImColor);
}
extern "C" {
    pub fn ImColor_ImColorInt(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        a: ::std::os::raw::c_int,
    ) -> *mut ImColor;
}
extern "C" {
    pub fn ImColor_ImColorU32(rgba: ImU32) -> *mut ImColor;
}
extern "C" {
    pub fn ImColor_ImColorFloat(r: f32, g: f32, b: f32, a: f32) -> *mut ImColor;
}
extern "C" {
    pub fn ImColor_ImColorVec4(col: ImVec4) -> *mut ImColor;
}
extern "C" {
    pub fn ImColor_SetHSV(self_: *mut ImColor, h: f32, s: f32, v: f32, a: f32);
}
extern "C" {
    pub fn ImColor_HSV(pOut: *mut ImColor, self_: *mut ImColor, h: f32, s: f32, v: f32, a: f32);
}
extern "C" {
    pub fn ImDrawCmd_ImDrawCmd() -> *mut ImDrawCmd;
}
extern "C" {
    pub fn ImDrawCmd_destroy(self_: *mut ImDrawCmd);
}
extern "C" {
    pub fn ImDrawListSplitter_ImDrawListSplitter() -> *mut ImDrawListSplitter;
}
extern "C" {
    pub fn ImDrawListSplitter_destroy(self_: *mut ImDrawListSplitter);
}
extern "C" {
    pub fn ImDrawListSplitter_Clear(self_: *mut ImDrawListSplitter);
}
extern "C" {
    pub fn ImDrawListSplitter_ClearFreeMemory(self_: *mut ImDrawListSplitter);
}
extern "C" {
    pub fn ImDrawListSplitter_Split(
        self_: *mut ImDrawListSplitter,
        draw_list: *mut ImDrawList,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawListSplitter_Merge(self_: *mut ImDrawListSplitter, draw_list: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawListSplitter_SetCurrentChannel(
        self_: *mut ImDrawListSplitter,
        draw_list: *mut ImDrawList,
        channel_idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_ImDrawList(shared_data: *const ImDrawListSharedData) -> *mut ImDrawList;
}
extern "C" {
    pub fn ImDrawList_destroy(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_PushClipRect(
        self_: *mut ImDrawList,
        clip_rect_min: ImVec2,
        clip_rect_max: ImVec2,
        intersect_with_current_clip_rect: bool,
    );
}
extern "C" {
    pub fn ImDrawList_PushClipRectFullScreen(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_PopClipRect(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_PushTextureID(self_: *mut ImDrawList, texture_id: ImTextureID);
}
extern "C" {
    pub fn ImDrawList_PopTextureID(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_GetClipRectMin(pOut: *mut ImVec2, self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_GetClipRectMax(pOut: *mut ImVec2, self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_AddLine(
        self_: *mut ImDrawList,
        p1: ImVec2,
        p2: ImVec2,
        col: ImU32,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddRect(
        self_: *mut ImDrawList,
        p_min: ImVec2,
        p_max: ImVec2,
        col: ImU32,
        rounding: f32,
        rounding_corners: ImDrawCornerFlags,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddRectFilled(
        self_: *mut ImDrawList,
        p_min: ImVec2,
        p_max: ImVec2,
        col: ImU32,
        rounding: f32,
        rounding_corners: ImDrawCornerFlags,
    );
}
extern "C" {
    pub fn ImDrawList_AddRectFilledMultiColor(
        self_: *mut ImDrawList,
        p_min: ImVec2,
        p_max: ImVec2,
        col_upr_left: ImU32,
        col_upr_right: ImU32,
        col_bot_right: ImU32,
        col_bot_left: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_AddQuad(
        self_: *mut ImDrawList,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        col: ImU32,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddQuadFilled(
        self_: *mut ImDrawList,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_AddTriangle(
        self_: *mut ImDrawList,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        col: ImU32,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddTriangleFilled(
        self_: *mut ImDrawList,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_AddCircle(
        self_: *mut ImDrawList,
        center: ImVec2,
        radius: f32,
        col: ImU32,
        num_segments: ::std::os::raw::c_int,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddCircleFilled(
        self_: *mut ImDrawList,
        center: ImVec2,
        radius: f32,
        col: ImU32,
        num_segments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_AddNgon(
        self_: *mut ImDrawList,
        center: ImVec2,
        radius: f32,
        col: ImU32,
        num_segments: ::std::os::raw::c_int,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddNgonFilled(
        self_: *mut ImDrawList,
        center: ImVec2,
        radius: f32,
        col: ImU32,
        num_segments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_AddTextVec2(
        self_: *mut ImDrawList,
        pos: ImVec2,
        col: ImU32,
        text_begin: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ImDrawList_AddTextFontPtr(
        self_: *mut ImDrawList,
        font: *const ImFont,
        font_size: f32,
        pos: ImVec2,
        col: ImU32,
        text_begin: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        wrap_width: f32,
        cpu_fine_clip_rect: *const ImVec4,
    );
}
extern "C" {
    pub fn ImDrawList_AddPolyline(
        self_: *mut ImDrawList,
        points: *const ImVec2,
        num_points: ::std::os::raw::c_int,
        col: ImU32,
        closed: bool,
        thickness: f32,
    );
}
extern "C" {
    pub fn ImDrawList_AddConvexPolyFilled(
        self_: *mut ImDrawList,
        points: *const ImVec2,
        num_points: ::std::os::raw::c_int,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_AddBezierCurve(
        self_: *mut ImDrawList,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        col: ImU32,
        thickness: f32,
        num_segments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_AddImage(
        self_: *mut ImDrawList,
        user_texture_id: ImTextureID,
        p_min: ImVec2,
        p_max: ImVec2,
        uv_min: ImVec2,
        uv_max: ImVec2,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_AddImageQuad(
        self_: *mut ImDrawList,
        user_texture_id: ImTextureID,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        uv1: ImVec2,
        uv2: ImVec2,
        uv3: ImVec2,
        uv4: ImVec2,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_AddImageRounded(
        self_: *mut ImDrawList,
        user_texture_id: ImTextureID,
        p_min: ImVec2,
        p_max: ImVec2,
        uv_min: ImVec2,
        uv_max: ImVec2,
        col: ImU32,
        rounding: f32,
        rounding_corners: ImDrawCornerFlags,
    );
}
extern "C" {
    pub fn ImDrawList_PathClear(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_PathLineTo(self_: *mut ImDrawList, pos: ImVec2);
}
extern "C" {
    pub fn ImDrawList_PathLineToMergeDuplicate(self_: *mut ImDrawList, pos: ImVec2);
}
extern "C" {
    pub fn ImDrawList_PathFillConvex(self_: *mut ImDrawList, col: ImU32);
}
extern "C" {
    pub fn ImDrawList_PathStroke(self_: *mut ImDrawList, col: ImU32, closed: bool, thickness: f32);
}
extern "C" {
    pub fn ImDrawList_PathArcTo(
        self_: *mut ImDrawList,
        center: ImVec2,
        radius: f32,
        a_min: f32,
        a_max: f32,
        num_segments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_PathArcToFast(
        self_: *mut ImDrawList,
        center: ImVec2,
        radius: f32,
        a_min_of_12: ::std::os::raw::c_int,
        a_max_of_12: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_PathBezierCurveTo(
        self_: *mut ImDrawList,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        num_segments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_PathRect(
        self_: *mut ImDrawList,
        rect_min: ImVec2,
        rect_max: ImVec2,
        rounding: f32,
        rounding_corners: ImDrawCornerFlags,
    );
}
extern "C" {
    pub fn ImDrawList_AddCallback(
        self_: *mut ImDrawList,
        callback: ImDrawCallback,
        callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ImDrawList_AddDrawCmd(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_CloneOutput(self_: *mut ImDrawList) -> *mut ImDrawList;
}
extern "C" {
    pub fn ImDrawList_ChannelsSplit(self_: *mut ImDrawList, count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImDrawList_ChannelsMerge(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_ChannelsSetCurrent(self_: *mut ImDrawList, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImDrawList_Clear(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_ClearFreeMemory(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_PrimReserve(
        self_: *mut ImDrawList,
        idx_count: ::std::os::raw::c_int,
        vtx_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_PrimUnreserve(
        self_: *mut ImDrawList,
        idx_count: ::std::os::raw::c_int,
        vtx_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImDrawList_PrimRect(self_: *mut ImDrawList, a: ImVec2, b: ImVec2, col: ImU32);
}
extern "C" {
    pub fn ImDrawList_PrimRectUV(
        self_: *mut ImDrawList,
        a: ImVec2,
        b: ImVec2,
        uv_a: ImVec2,
        uv_b: ImVec2,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_PrimQuadUV(
        self_: *mut ImDrawList,
        a: ImVec2,
        b: ImVec2,
        c: ImVec2,
        d: ImVec2,
        uv_a: ImVec2,
        uv_b: ImVec2,
        uv_c: ImVec2,
        uv_d: ImVec2,
        col: ImU32,
    );
}
extern "C" {
    pub fn ImDrawList_PrimWriteVtx(self_: *mut ImDrawList, pos: ImVec2, uv: ImVec2, col: ImU32);
}
extern "C" {
    pub fn ImDrawList_PrimWriteIdx(self_: *mut ImDrawList, idx: ImDrawIdx);
}
extern "C" {
    pub fn ImDrawList_PrimVtx(self_: *mut ImDrawList, pos: ImVec2, uv: ImVec2, col: ImU32);
}
extern "C" {
    pub fn ImDrawList_UpdateClipRect(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawList_UpdateTextureID(self_: *mut ImDrawList);
}
extern "C" {
    pub fn ImDrawData_ImDrawData() -> *mut ImDrawData;
}
extern "C" {
    pub fn ImDrawData_destroy(self_: *mut ImDrawData);
}
extern "C" {
    pub fn ImDrawData_Clear(self_: *mut ImDrawData);
}
extern "C" {
    pub fn ImDrawData_DeIndexAllBuffers(self_: *mut ImDrawData);
}
extern "C" {
    pub fn ImDrawData_ScaleClipRects(self_: *mut ImDrawData, fb_scale: ImVec2);
}
extern "C" {
    pub fn ImFontConfig_ImFontConfig() -> *mut ImFontConfig;
}
extern "C" {
    pub fn ImFontConfig_destroy(self_: *mut ImFontConfig);
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder() -> *mut ImFontGlyphRangesBuilder;
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_destroy(self_: *mut ImFontGlyphRangesBuilder);
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_Clear(self_: *mut ImFontGlyphRangesBuilder);
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_GetBit(self_: *mut ImFontGlyphRangesBuilder, n: size_t)
        -> bool;
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_SetBit(self_: *mut ImFontGlyphRangesBuilder, n: size_t);
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_AddChar(self_: *mut ImFontGlyphRangesBuilder, c: ImWchar);
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_AddText(
        self_: *mut ImFontGlyphRangesBuilder,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_AddRanges(
        self_: *mut ImFontGlyphRangesBuilder,
        ranges: *const ImWchar,
    );
}
extern "C" {
    pub fn ImFontGlyphRangesBuilder_BuildRanges(
        self_: *mut ImFontGlyphRangesBuilder,
        out_ranges: *mut ImVector_ImWchar,
    );
}
extern "C" {
    pub fn ImFontAtlasCustomRect_ImFontAtlasCustomRect() -> *mut ImFontAtlasCustomRect;
}
extern "C" {
    pub fn ImFontAtlasCustomRect_destroy(self_: *mut ImFontAtlasCustomRect);
}
extern "C" {
    pub fn ImFontAtlasCustomRect_IsPacked(self_: *mut ImFontAtlasCustomRect) -> bool;
}
extern "C" {
    pub fn ImFontAtlas_ImFontAtlas() -> *mut ImFontAtlas;
}
extern "C" {
    pub fn ImFontAtlas_destroy(self_: *mut ImFontAtlas);
}
extern "C" {
    pub fn ImFontAtlas_AddFont(
        self_: *mut ImFontAtlas,
        font_cfg: *const ImFontConfig,
    ) -> *mut ImFont;
}
extern "C" {
    pub fn ImFontAtlas_AddFontDefault(
        self_: *mut ImFontAtlas,
        font_cfg: *const ImFontConfig,
    ) -> *mut ImFont;
}
extern "C" {
    pub fn ImFontAtlas_AddFontFromFileTTF(
        self_: *mut ImFontAtlas,
        filename: *const ::std::os::raw::c_char,
        size_pixels: f32,
        font_cfg: *const ImFontConfig,
        glyph_ranges: *const ImWchar,
    ) -> *mut ImFont;
}
extern "C" {
    pub fn ImFontAtlas_AddFontFromMemoryTTF(
        self_: *mut ImFontAtlas,
        font_data: *mut ::std::os::raw::c_void,
        font_size: ::std::os::raw::c_int,
        size_pixels: f32,
        font_cfg: *const ImFontConfig,
        glyph_ranges: *const ImWchar,
    ) -> *mut ImFont;
}
extern "C" {
    pub fn ImFontAtlas_AddFontFromMemoryCompressedTTF(
        self_: *mut ImFontAtlas,
        compressed_font_data: *const ::std::os::raw::c_void,
        compressed_font_size: ::std::os::raw::c_int,
        size_pixels: f32,
        font_cfg: *const ImFontConfig,
        glyph_ranges: *const ImWchar,
    ) -> *mut ImFont;
}
extern "C" {
    pub fn ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(
        self_: *mut ImFontAtlas,
        compressed_font_data_base85: *const ::std::os::raw::c_char,
        size_pixels: f32,
        font_cfg: *const ImFontConfig,
        glyph_ranges: *const ImWchar,
    ) -> *mut ImFont;
}
extern "C" {
    pub fn ImFontAtlas_ClearInputData(self_: *mut ImFontAtlas);
}
extern "C" {
    pub fn ImFontAtlas_ClearTexData(self_: *mut ImFontAtlas);
}
extern "C" {
    pub fn ImFontAtlas_ClearFonts(self_: *mut ImFontAtlas);
}
extern "C" {
    pub fn ImFontAtlas_Clear(self_: *mut ImFontAtlas);
}
extern "C" {
    pub fn ImFontAtlas_Build(self_: *mut ImFontAtlas) -> bool;
}
extern "C" {
    pub fn ImFontAtlas_GetTexDataAsAlpha8(
        self_: *mut ImFontAtlas,
        out_pixels: *mut *mut ::std::os::raw::c_uchar,
        out_width: *mut ::std::os::raw::c_int,
        out_height: *mut ::std::os::raw::c_int,
        out_bytes_per_pixel: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImFontAtlas_GetTexDataAsRGBA32(
        self_: *mut ImFontAtlas,
        out_pixels: *mut *mut ::std::os::raw::c_uchar,
        out_width: *mut ::std::os::raw::c_int,
        out_height: *mut ::std::os::raw::c_int,
        out_bytes_per_pixel: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImFontAtlas_IsBuilt(self_: *mut ImFontAtlas) -> bool;
}
extern "C" {
    pub fn ImFontAtlas_SetTexID(self_: *mut ImFontAtlas, id: ImTextureID);
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesDefault(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesKorean(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesJapanese(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesChineseFull(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(
        self_: *mut ImFontAtlas,
    ) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesCyrillic(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesThai(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_GetGlyphRangesVietnamese(self_: *mut ImFontAtlas) -> *const ImWchar;
}
extern "C" {
    pub fn ImFontAtlas_AddCustomRectRegular(
        self_: *mut ImFontAtlas,
        id: ::std::os::raw::c_uint,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImFontAtlas_AddCustomRectFontGlyph(
        self_: *mut ImFontAtlas,
        font: *mut ImFont,
        id: ImWchar,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        advance_x: f32,
        offset: ImVec2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImFontAtlas_GetCustomRectByIndex(
        self_: *mut ImFontAtlas,
        index: ::std::os::raw::c_int,
    ) -> *const ImFontAtlasCustomRect;
}
extern "C" {
    pub fn ImFontAtlas_CalcCustomRectUV(
        self_: *mut ImFontAtlas,
        rect: *const ImFontAtlasCustomRect,
        out_uv_min: *mut ImVec2,
        out_uv_max: *mut ImVec2,
    );
}
extern "C" {
    pub fn ImFontAtlas_GetMouseCursorTexData(
        self_: *mut ImFontAtlas,
        cursor: ImGuiMouseCursor,
        out_offset: *mut ImVec2,
        out_size: *mut ImVec2,
        out_uv_border: *mut ImVec2,
        out_uv_fill: *mut ImVec2,
    ) -> bool;
}
extern "C" {
    pub fn ImFont_ImFont() -> *mut ImFont;
}
extern "C" {
    pub fn ImFont_destroy(self_: *mut ImFont);
}
extern "C" {
    pub fn ImFont_FindGlyph(self_: *mut ImFont, c: ImWchar) -> *const ImFontGlyph;
}
extern "C" {
    pub fn ImFont_FindGlyphNoFallback(self_: *mut ImFont, c: ImWchar) -> *const ImFontGlyph;
}
extern "C" {
    pub fn ImFont_GetCharAdvance(self_: *mut ImFont, c: ImWchar) -> f32;
}
extern "C" {
    pub fn ImFont_IsLoaded(self_: *mut ImFont) -> bool;
}
extern "C" {
    pub fn ImFont_GetDebugName(self_: *mut ImFont) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ImFont_CalcTextSizeA(
        pOut: *mut ImVec2,
        self_: *mut ImFont,
        size: f32,
        max_width: f32,
        wrap_width: f32,
        text_begin: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        remaining: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ImFont_CalcWordWrapPositionA(
        self_: *mut ImFont,
        scale: f32,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        wrap_width: f32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ImFont_RenderChar(
        self_: *mut ImFont,
        draw_list: *mut ImDrawList,
        size: f32,
        pos: ImVec2,
        col: ImU32,
        c: ImWchar,
    );
}
extern "C" {
    pub fn ImFont_RenderText(
        self_: *mut ImFont,
        draw_list: *mut ImDrawList,
        size: f32,
        pos: ImVec2,
        col: ImU32,
        clip_rect: ImVec4,
        text_begin: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        wrap_width: f32,
        cpu_fine_clip: bool,
    );
}
extern "C" {
    pub fn ImFont_BuildLookupTable(self_: *mut ImFont);
}
extern "C" {
    pub fn ImFont_ClearOutputData(self_: *mut ImFont);
}
extern "C" {
    pub fn ImFont_GrowIndex(self_: *mut ImFont, new_size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImFont_AddGlyph(
        self_: *mut ImFont,
        c: ImWchar,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        u0: f32,
        v0: f32,
        u1: f32,
        v1: f32,
        advance_x: f32,
    );
}
extern "C" {
    pub fn ImFont_AddRemapChar(self_: *mut ImFont, dst: ImWchar, src: ImWchar, overwrite_dst: bool);
}
extern "C" {
    pub fn ImFont_SetGlyphVisible(self_: *mut ImFont, c: ImWchar, visible: bool);
}
extern "C" {
    pub fn ImFont_SetFallbackChar(self_: *mut ImFont, c: ImWchar);
}
extern "C" {
    pub fn ImFont_IsGlyphRangeUnused(
        self_: *mut ImFont,
        c_begin: ::std::os::raw::c_uint,
        c_last: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn igImHashData(
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
        seed: ImU32,
    ) -> ImU32;
}
extern "C" {
    pub fn igImHashStr(
        data: *const ::std::os::raw::c_char,
        data_size: size_t,
        seed: ImU32,
    ) -> ImU32;
}
extern "C" {
    pub fn igImAlphaBlendColors(col_a: ImU32, col_b: ImU32) -> ImU32;
}
extern "C" {
    pub fn igImIsPowerOfTwo(v: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn igImUpperPowerOfTwo(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImStricmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImStrnicmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImStrncpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        count: size_t,
    );
}
extern "C" {
    pub fn igImStrdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImStrdupcpy(
        dst: *mut ::std::os::raw::c_char,
        p_dst_size: *mut size_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImStrchrRange(
        str_begin: *const ::std::os::raw::c_char,
        str_end: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImStrlenW(str_: *const ImWchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImStreolRange(
        str_: *const ::std::os::raw::c_char,
        str_end: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImStrbolW(buf_mid_line: *const ImWchar, buf_begin: *const ImWchar) -> *const ImWchar;
}
extern "C" {
    pub fn igImStristr(
        haystack: *const ::std::os::raw::c_char,
        haystack_end: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
        needle_end: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImStrTrimBlanks(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn igImStrSkipBlank(str_: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImFormatString(
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImFormatStringV(
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImParseFormatFindStart(
        format: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImParseFormatFindEnd(
        format: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImParseFormatTrimDecorations(
        format: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igImParseFormatPrecision(
        format: *const ::std::os::raw::c_char,
        default_value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImCharIsBlankA(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn igImCharIsBlankW(c: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn igImTextStrToUtf8(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        in_text: *const ImWchar,
        in_text_end: *const ImWchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImTextCharFromUtf8(
        out_char: *mut ::std::os::raw::c_uint,
        in_text: *const ::std::os::raw::c_char,
        in_text_end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImTextStrFromUtf8(
        buf: *mut ImWchar,
        buf_size: ::std::os::raw::c_int,
        in_text: *const ::std::os::raw::c_char,
        in_text_end: *const ::std::os::raw::c_char,
        in_remaining: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImTextCountCharsFromUtf8(
        in_text: *const ::std::os::raw::c_char,
        in_text_end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImTextCountUtf8BytesFromChar(
        in_text: *const ::std::os::raw::c_char,
        in_text_end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImTextCountUtf8BytesFromStr(
        in_text: *const ImWchar,
        in_text_end: *const ImWchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImFileOpen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> ImFileHandle;
}
extern "C" {
    pub fn igImFileClose(file: ImFileHandle) -> bool;
}
extern "C" {
    pub fn igImFileGetSize(file: ImFileHandle) -> ImU64;
}
extern "C" {
    pub fn igImFileRead(
        data: *mut ::std::os::raw::c_void,
        size: ImU64,
        count: ImU64,
        file: ImFileHandle,
    ) -> ImU64;
}
extern "C" {
    pub fn igImFileWrite(
        data: *const ::std::os::raw::c_void,
        size: ImU64,
        count: ImU64,
        file: ImFileHandle,
    ) -> ImU64;
}
extern "C" {
    pub fn igImFileLoadToMemory(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        out_file_size: *mut size_t,
        padding_bytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn igImPowFloat(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn igImPowdouble(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn igImMin(pOut: *mut ImVec2, lhs: ImVec2, rhs: ImVec2);
}
extern "C" {
    pub fn igImMax(pOut: *mut ImVec2, lhs: ImVec2, rhs: ImVec2);
}
extern "C" {
    pub fn igImClamp(pOut: *mut ImVec2, v: ImVec2, mn: ImVec2, mx: ImVec2);
}
extern "C" {
    pub fn igImLerpVec2Float(pOut: *mut ImVec2, a: ImVec2, b: ImVec2, t: f32);
}
extern "C" {
    pub fn igImLerpVec2Vec2(pOut: *mut ImVec2, a: ImVec2, b: ImVec2, t: ImVec2);
}
extern "C" {
    pub fn igImLerpVec4(pOut: *mut ImVec4, a: ImVec4, b: ImVec4, t: f32);
}
extern "C" {
    pub fn igImSaturate(f: f32) -> f32;
}
extern "C" {
    pub fn igImLengthSqrVec2(lhs: ImVec2) -> f32;
}
extern "C" {
    pub fn igImLengthSqrVec4(lhs: ImVec4) -> f32;
}
extern "C" {
    pub fn igImInvLength(lhs: ImVec2, fail_value: f32) -> f32;
}
extern "C" {
    pub fn igImFloorFloat(f: f32) -> f32;
}
extern "C" {
    pub fn igImFloorVec2(pOut: *mut ImVec2, v: ImVec2);
}
extern "C" {
    pub fn igImModPositive(
        a: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igImDot(a: ImVec2, b: ImVec2) -> f32;
}
extern "C" {
    pub fn igImRotate(pOut: *mut ImVec2, v: ImVec2, cos_a: f32, sin_a: f32);
}
extern "C" {
    pub fn igImLinearSweep(current: f32, target: f32, speed: f32) -> f32;
}
extern "C" {
    pub fn igImMul(pOut: *mut ImVec2, lhs: ImVec2, rhs: ImVec2);
}
extern "C" {
    pub fn igImBezierCalc(
        pOut: *mut ImVec2,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        t: f32,
    );
}
extern "C" {
    pub fn igImBezierClosestPoint(
        pOut: *mut ImVec2,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        p: ImVec2,
        num_segments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn igImBezierClosestPointCasteljau(
        pOut: *mut ImVec2,
        p1: ImVec2,
        p2: ImVec2,
        p3: ImVec2,
        p4: ImVec2,
        p: ImVec2,
        tess_tol: f32,
    );
}
extern "C" {
    pub fn igImLineClosestPoint(pOut: *mut ImVec2, a: ImVec2, b: ImVec2, p: ImVec2);
}
extern "C" {
    pub fn igImTriangleContainsPoint(a: ImVec2, b: ImVec2, c: ImVec2, p: ImVec2) -> bool;
}
extern "C" {
    pub fn igImTriangleClosestPoint(pOut: *mut ImVec2, a: ImVec2, b: ImVec2, c: ImVec2, p: ImVec2);
}
extern "C" {
    pub fn igImTriangleBarycentricCoords(
        a: ImVec2,
        b: ImVec2,
        c: ImVec2,
        p: ImVec2,
        out_u: f32,
        out_v: f32,
        out_w: f32,
    );
}
extern "C" {
    pub fn igImTriangleArea(a: ImVec2, b: ImVec2, c: ImVec2) -> f32;
}
extern "C" {
    pub fn igImGetDirQuadrantFromDelta(dx: f32, dy: f32) -> ImGuiDir;
}
extern "C" {
    pub fn igImBitArrayTestBit(arr: *const ImU32, n: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn igImBitArrayClearBit(arr: *mut ImU32, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igImBitArraySetBit(arr: *mut ImU32, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igImBitArraySetBitRange(
        arr: *mut ImU32,
        n: ::std::os::raw::c_int,
        n2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImBitVector_Create(self_: *mut ImBitVector, sz: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImBitVector_Clear(self_: *mut ImBitVector);
}
extern "C" {
    pub fn ImBitVector_TestBit(self_: *mut ImBitVector, n: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn ImBitVector_SetBit(self_: *mut ImBitVector, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImBitVector_ClearBit(self_: *mut ImBitVector, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImVec1_ImVec1Nil() -> *mut ImVec1;
}
extern "C" {
    pub fn ImVec1_destroy(self_: *mut ImVec1);
}
extern "C" {
    pub fn ImVec1_ImVec1Float(_x: f32) -> *mut ImVec1;
}
extern "C" {
    pub fn ImVec2ih_ImVec2ihNil() -> *mut ImVec2ih;
}
extern "C" {
    pub fn ImVec2ih_destroy(self_: *mut ImVec2ih);
}
extern "C" {
    pub fn ImVec2ih_ImVec2ihshort(
        _x: ::std::os::raw::c_short,
        _y: ::std::os::raw::c_short,
    ) -> *mut ImVec2ih;
}
extern "C" {
    pub fn ImVec2ih_ImVec2ihVec2(rhs: ImVec2) -> *mut ImVec2ih;
}
extern "C" {
    pub fn ImRect_ImRectNil() -> *mut ImRect;
}
extern "C" {
    pub fn ImRect_destroy(self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_ImRectVec2(min: ImVec2, max: ImVec2) -> *mut ImRect;
}
extern "C" {
    pub fn ImRect_ImRectVec4(v: ImVec4) -> *mut ImRect;
}
extern "C" {
    pub fn ImRect_ImRectFloat(x1: f32, y1: f32, x2: f32, y2: f32) -> *mut ImRect;
}
extern "C" {
    pub fn ImRect_GetCenter(pOut: *mut ImVec2, self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_GetSize(pOut: *mut ImVec2, self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_GetWidth(self_: *mut ImRect) -> f32;
}
extern "C" {
    pub fn ImRect_GetHeight(self_: *mut ImRect) -> f32;
}
extern "C" {
    pub fn ImRect_GetTL(pOut: *mut ImVec2, self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_GetTR(pOut: *mut ImVec2, self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_GetBL(pOut: *mut ImVec2, self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_GetBR(pOut: *mut ImVec2, self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_ContainsVec2(self_: *mut ImRect, p: ImVec2) -> bool;
}
extern "C" {
    pub fn ImRect_ContainsRect(self_: *mut ImRect, r: ImRect) -> bool;
}
extern "C" {
    pub fn ImRect_Overlaps(self_: *mut ImRect, r: ImRect) -> bool;
}
extern "C" {
    pub fn ImRect_AddVec2(self_: *mut ImRect, p: ImVec2);
}
extern "C" {
    pub fn ImRect_AddRect(self_: *mut ImRect, r: ImRect);
}
extern "C" {
    pub fn ImRect_ExpandFloat(self_: *mut ImRect, amount: f32);
}
extern "C" {
    pub fn ImRect_ExpandVec2(self_: *mut ImRect, amount: ImVec2);
}
extern "C" {
    pub fn ImRect_Translate(self_: *mut ImRect, d: ImVec2);
}
extern "C" {
    pub fn ImRect_TranslateX(self_: *mut ImRect, dx: f32);
}
extern "C" {
    pub fn ImRect_TranslateY(self_: *mut ImRect, dy: f32);
}
extern "C" {
    pub fn ImRect_ClipWith(self_: *mut ImRect, r: ImRect);
}
extern "C" {
    pub fn ImRect_ClipWithFull(self_: *mut ImRect, r: ImRect);
}
extern "C" {
    pub fn ImRect_Floor(self_: *mut ImRect);
}
extern "C" {
    pub fn ImRect_IsInverted(self_: *mut ImRect) -> bool;
}
extern "C" {
    pub fn ImGuiStyleMod_ImGuiStyleModInt(
        idx: ImGuiStyleVar,
        v: ::std::os::raw::c_int,
    ) -> *mut ImGuiStyleMod;
}
extern "C" {
    pub fn ImGuiStyleMod_destroy(self_: *mut ImGuiStyleMod);
}
extern "C" {
    pub fn ImGuiStyleMod_ImGuiStyleModFloat(idx: ImGuiStyleVar, v: f32) -> *mut ImGuiStyleMod;
}
extern "C" {
    pub fn ImGuiStyleMod_ImGuiStyleModVec2(idx: ImGuiStyleVar, v: ImVec2) -> *mut ImGuiStyleMod;
}
extern "C" {
    pub fn ImGuiMenuColumns_ImGuiMenuColumns() -> *mut ImGuiMenuColumns;
}
extern "C" {
    pub fn ImGuiMenuColumns_destroy(self_: *mut ImGuiMenuColumns);
}
extern "C" {
    pub fn ImGuiMenuColumns_Update(
        self_: *mut ImGuiMenuColumns,
        count: ::std::os::raw::c_int,
        spacing: f32,
        clear: bool,
    );
}
extern "C" {
    pub fn ImGuiMenuColumns_DeclColumns(
        self_: *mut ImGuiMenuColumns,
        w0: f32,
        w1: f32,
        w2: f32,
    ) -> f32;
}
extern "C" {
    pub fn ImGuiMenuColumns_CalcExtraSpace(self_: *mut ImGuiMenuColumns, avail_w: f32) -> f32;
}
extern "C" {
    pub fn ImGuiInputTextState_ImGuiInputTextState() -> *mut ImGuiInputTextState;
}
extern "C" {
    pub fn ImGuiInputTextState_destroy(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiInputTextState_ClearText(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiInputTextState_ClearFreeMemory(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiInputTextState_GetUndoAvailCount(
        self_: *mut ImGuiInputTextState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImGuiInputTextState_GetRedoAvailCount(
        self_: *mut ImGuiInputTextState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImGuiInputTextState_OnKeyPressed(
        self_: *mut ImGuiInputTextState,
        key: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ImGuiInputTextState_CursorAnimReset(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiInputTextState_CursorClamp(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiInputTextState_HasSelection(self_: *mut ImGuiInputTextState) -> bool;
}
extern "C" {
    pub fn ImGuiInputTextState_ClearSelection(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiInputTextState_SelectAll(self_: *mut ImGuiInputTextState);
}
extern "C" {
    pub fn ImGuiWindowSettings_ImGuiWindowSettings() -> *mut ImGuiWindowSettings;
}
extern "C" {
    pub fn ImGuiWindowSettings_destroy(self_: *mut ImGuiWindowSettings);
}
extern "C" {
    pub fn ImGuiWindowSettings_GetName(
        self_: *mut ImGuiWindowSettings,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ImGuiSettingsHandler_ImGuiSettingsHandler() -> *mut ImGuiSettingsHandler;
}
extern "C" {
    pub fn ImGuiSettingsHandler_destroy(self_: *mut ImGuiSettingsHandler);
}
extern "C" {
    pub fn ImGuiPopupData_ImGuiPopupData() -> *mut ImGuiPopupData;
}
extern "C" {
    pub fn ImGuiPopupData_destroy(self_: *mut ImGuiPopupData);
}
extern "C" {
    pub fn ImGuiColumnData_ImGuiColumnData() -> *mut ImGuiColumnData;
}
extern "C" {
    pub fn ImGuiColumnData_destroy(self_: *mut ImGuiColumnData);
}
extern "C" {
    pub fn ImGuiColumns_ImGuiColumns() -> *mut ImGuiColumns;
}
extern "C" {
    pub fn ImGuiColumns_destroy(self_: *mut ImGuiColumns);
}
extern "C" {
    pub fn ImGuiColumns_Clear(self_: *mut ImGuiColumns);
}
extern "C" {
    pub fn ImDrawListSharedData_ImDrawListSharedData() -> *mut ImDrawListSharedData;
}
extern "C" {
    pub fn ImDrawListSharedData_destroy(self_: *mut ImDrawListSharedData);
}
extern "C" {
    pub fn ImDrawListSharedData_SetCircleSegmentMaxError(
        self_: *mut ImDrawListSharedData,
        max_error: f32,
    );
}
extern "C" {
    pub fn ImDrawDataBuilder_Clear(self_: *mut ImDrawDataBuilder);
}
extern "C" {
    pub fn ImDrawDataBuilder_ClearFreeMemory(self_: *mut ImDrawDataBuilder);
}
extern "C" {
    pub fn ImDrawDataBuilder_FlattenIntoSingleLayer(self_: *mut ImDrawDataBuilder);
}
extern "C" {
    pub fn ImGuiNavMoveResult_ImGuiNavMoveResult() -> *mut ImGuiNavMoveResult;
}
extern "C" {
    pub fn ImGuiNavMoveResult_destroy(self_: *mut ImGuiNavMoveResult);
}
extern "C" {
    pub fn ImGuiNavMoveResult_Clear(self_: *mut ImGuiNavMoveResult);
}
extern "C" {
    pub fn ImGuiNextWindowData_ImGuiNextWindowData() -> *mut ImGuiNextWindowData;
}
extern "C" {
    pub fn ImGuiNextWindowData_destroy(self_: *mut ImGuiNextWindowData);
}
extern "C" {
    pub fn ImGuiNextWindowData_ClearFlags(self_: *mut ImGuiNextWindowData);
}
extern "C" {
    pub fn ImGuiNextItemData_ImGuiNextItemData() -> *mut ImGuiNextItemData;
}
extern "C" {
    pub fn ImGuiNextItemData_destroy(self_: *mut ImGuiNextItemData);
}
extern "C" {
    pub fn ImGuiNextItemData_ClearFlags(self_: *mut ImGuiNextItemData);
}
extern "C" {
    pub fn ImGuiPtrOrIndex_ImGuiPtrOrIndexPtr(
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut ImGuiPtrOrIndex;
}
extern "C" {
    pub fn ImGuiPtrOrIndex_destroy(self_: *mut ImGuiPtrOrIndex);
}
extern "C" {
    pub fn ImGuiPtrOrIndex_ImGuiPtrOrIndexInt(index: ::std::os::raw::c_int)
        -> *mut ImGuiPtrOrIndex;
}
extern "C" {
    pub fn ImGuiContext_ImGuiContext(shared_font_atlas: *mut ImFontAtlas) -> *mut ImGuiContext;
}
extern "C" {
    pub fn ImGuiContext_destroy(self_: *mut ImGuiContext);
}
extern "C" {
    pub fn ImGuiWindowTempData_ImGuiWindowTempData() -> *mut ImGuiWindowTempData;
}
extern "C" {
    pub fn ImGuiWindowTempData_destroy(self_: *mut ImGuiWindowTempData);
}
extern "C" {
    pub fn ImGuiWindow_ImGuiWindow(
        context: *mut ImGuiContext,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ImGuiWindow;
}
extern "C" {
    pub fn ImGuiWindow_destroy(self_: *mut ImGuiWindow);
}
extern "C" {
    pub fn ImGuiWindow_GetIDStr(
        self_: *mut ImGuiWindow,
        str_: *const ::std::os::raw::c_char,
        str_end: *const ::std::os::raw::c_char,
    ) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_GetIDPtr(
        self_: *mut ImGuiWindow,
        ptr: *const ::std::os::raw::c_void,
    ) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_GetIDInt(self_: *mut ImGuiWindow, n: ::std::os::raw::c_int) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_GetIDNoKeepAliveStr(
        self_: *mut ImGuiWindow,
        str_: *const ::std::os::raw::c_char,
        str_end: *const ::std::os::raw::c_char,
    ) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_GetIDNoKeepAlivePtr(
        self_: *mut ImGuiWindow,
        ptr: *const ::std::os::raw::c_void,
    ) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_GetIDNoKeepAliveInt(
        self_: *mut ImGuiWindow,
        n: ::std::os::raw::c_int,
    ) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_GetIDFromRectangle(self_: *mut ImGuiWindow, r_abs: ImRect) -> ImGuiID;
}
extern "C" {
    pub fn ImGuiWindow_Rect(pOut: *mut ImRect, self_: *mut ImGuiWindow);
}
extern "C" {
    pub fn ImGuiWindow_CalcFontSize(self_: *mut ImGuiWindow) -> f32;
}
extern "C" {
    pub fn ImGuiWindow_TitleBarHeight(self_: *mut ImGuiWindow) -> f32;
}
extern "C" {
    pub fn ImGuiWindow_TitleBarRect(pOut: *mut ImRect, self_: *mut ImGuiWindow);
}
extern "C" {
    pub fn ImGuiWindow_MenuBarHeight(self_: *mut ImGuiWindow) -> f32;
}
extern "C" {
    pub fn ImGuiWindow_MenuBarRect(pOut: *mut ImRect, self_: *mut ImGuiWindow);
}
extern "C" {
    pub fn ImGuiItemHoveredDataBackup_ImGuiItemHoveredDataBackup() -> *mut ImGuiItemHoveredDataBackup;
}
extern "C" {
    pub fn ImGuiItemHoveredDataBackup_destroy(self_: *mut ImGuiItemHoveredDataBackup);
}
extern "C" {
    pub fn ImGuiItemHoveredDataBackup_Backup(self_: *mut ImGuiItemHoveredDataBackup);
}
extern "C" {
    pub fn ImGuiItemHoveredDataBackup_Restore(self_: *mut ImGuiItemHoveredDataBackup);
}
extern "C" {
    pub fn ImGuiTabItem_ImGuiTabItem() -> *mut ImGuiTabItem;
}
extern "C" {
    pub fn ImGuiTabItem_destroy(self_: *mut ImGuiTabItem);
}
extern "C" {
    pub fn ImGuiTabBar_ImGuiTabBar() -> *mut ImGuiTabBar;
}
extern "C" {
    pub fn ImGuiTabBar_destroy(self_: *mut ImGuiTabBar);
}
extern "C" {
    pub fn ImGuiTabBar_GetTabOrder(
        self_: *mut ImGuiTabBar,
        tab: *const ImGuiTabItem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ImGuiTabBar_GetTabName(
        self_: *mut ImGuiTabBar,
        tab: *const ImGuiTabItem,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igGetCurrentWindowRead() -> *mut ImGuiWindow;
}
extern "C" {
    pub fn igGetCurrentWindow() -> *mut ImGuiWindow;
}
extern "C" {
    pub fn igFindWindowByID(id: ImGuiID) -> *mut ImGuiWindow;
}
extern "C" {
    pub fn igFindWindowByName(name: *const ::std::os::raw::c_char) -> *mut ImGuiWindow;
}
extern "C" {
    pub fn igUpdateWindowParentAndRootLinks(
        window: *mut ImGuiWindow,
        flags: ImGuiWindowFlags,
        parent_window: *mut ImGuiWindow,
    );
}
extern "C" {
    pub fn igCalcWindowExpectedSize(pOut: *mut ImVec2, window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igIsWindowChildOf(window: *mut ImGuiWindow, potential_parent: *mut ImGuiWindow) -> bool;
}
extern "C" {
    pub fn igIsWindowNavFocusable(window: *mut ImGuiWindow) -> bool;
}
extern "C" {
    pub fn igGetWindowAllowedExtentRect(pOut: *mut ImRect, window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igSetWindowPosWindowPtr(window: *mut ImGuiWindow, pos: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowSizeWindowPtr(window: *mut ImGuiWindow, size: ImVec2, cond: ImGuiCond);
}
extern "C" {
    pub fn igSetWindowCollapsedWindowPtr(
        window: *mut ImGuiWindow,
        collapsed: bool,
        cond: ImGuiCond,
    );
}
extern "C" {
    pub fn igFocusWindow(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igFocusTopMostWindowUnderOne(
        under_this_window: *mut ImGuiWindow,
        ignore_window: *mut ImGuiWindow,
    );
}
extern "C" {
    pub fn igBringWindowToFocusFront(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igBringWindowToDisplayFront(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igBringWindowToDisplayBack(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igSetCurrentFont(font: *mut ImFont);
}
extern "C" {
    pub fn igGetDefaultFont() -> *mut ImFont;
}
extern "C" {
    pub fn igGetForegroundDrawListWindowPtr(window: *mut ImGuiWindow) -> *mut ImDrawList;
}
extern "C" {
    pub fn igInitialize(context: *mut ImGuiContext);
}
extern "C" {
    pub fn igShutdown(context: *mut ImGuiContext);
}
extern "C" {
    pub fn igUpdateHoveredWindowAndCaptureFlags();
}
extern "C" {
    pub fn igStartMouseMovingWindow(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igUpdateMouseMovingWindowNewFrame();
}
extern "C" {
    pub fn igUpdateMouseMovingWindowEndFrame();
}
extern "C" {
    pub fn igMarkIniSettingsDirtyNil();
}
extern "C" {
    pub fn igMarkIniSettingsDirtyWindowPtr(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igCreateNewWindowSettings(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ImGuiWindowSettings;
}
extern "C" {
    pub fn igFindWindowSettings(id: ImGuiID) -> *mut ImGuiWindowSettings;
}
extern "C" {
    pub fn igFindOrCreateWindowSettings(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ImGuiWindowSettings;
}
extern "C" {
    pub fn igFindSettingsHandler(
        type_name: *const ::std::os::raw::c_char,
    ) -> *mut ImGuiSettingsHandler;
}
extern "C" {
    pub fn igSetScrollXWindowPtr(window: *mut ImGuiWindow, new_scroll_x: f32);
}
extern "C" {
    pub fn igSetScrollYWindowPtr(window: *mut ImGuiWindow, new_scroll_y: f32);
}
extern "C" {
    pub fn igSetScrollFromPosXWindowPtr(
        window: *mut ImGuiWindow,
        local_x: f32,
        center_x_ratio: f32,
    );
}
extern "C" {
    pub fn igSetScrollFromPosYWindowPtr(
        window: *mut ImGuiWindow,
        local_y: f32,
        center_y_ratio: f32,
    );
}
extern "C" {
    pub fn igScrollToBringRectIntoView(
        pOut: *mut ImVec2,
        window: *mut ImGuiWindow,
        item_rect: ImRect,
    );
}
extern "C" {
    pub fn igGetItemID() -> ImGuiID;
}
extern "C" {
    pub fn igGetItemStatusFlags() -> ImGuiItemStatusFlags;
}
extern "C" {
    pub fn igGetActiveID() -> ImGuiID;
}
extern "C" {
    pub fn igGetFocusID() -> ImGuiID;
}
extern "C" {
    pub fn igSetActiveID(id: ImGuiID, window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igSetFocusID(id: ImGuiID, window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igClearActiveID();
}
extern "C" {
    pub fn igGetHoveredID() -> ImGuiID;
}
extern "C" {
    pub fn igSetHoveredID(id: ImGuiID);
}
extern "C" {
    pub fn igKeepAliveID(id: ImGuiID);
}
extern "C" {
    pub fn igMarkItemEdited(id: ImGuiID);
}
extern "C" {
    pub fn igPushOverrideID(id: ImGuiID);
}
extern "C" {
    pub fn igItemSizeVec2(size: ImVec2, text_baseline_y: f32);
}
extern "C" {
    pub fn igItemSizeRect(bb: ImRect, text_baseline_y: f32);
}
extern "C" {
    pub fn igItemAdd(bb: ImRect, id: ImGuiID, nav_bb: *const ImRect) -> bool;
}
extern "C" {
    pub fn igItemHoverable(bb: ImRect, id: ImGuiID) -> bool;
}
extern "C" {
    pub fn igIsClippedEx(bb: ImRect, id: ImGuiID, clip_even_when_logged: bool) -> bool;
}
extern "C" {
    pub fn igFocusableItemRegister(window: *mut ImGuiWindow, id: ImGuiID) -> bool;
}
extern "C" {
    pub fn igFocusableItemUnregister(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igCalcItemSize(pOut: *mut ImVec2, size: ImVec2, default_w: f32, default_h: f32);
}
extern "C" {
    pub fn igCalcWrapWidthForPos(pos: ImVec2, wrap_pos_x: f32) -> f32;
}
extern "C" {
    pub fn igPushMultiItemsWidths(components: ::std::os::raw::c_int, width_full: f32);
}
extern "C" {
    pub fn igPushItemFlag(option: ImGuiItemFlags, enabled: bool);
}
extern "C" {
    pub fn igPopItemFlag();
}
extern "C" {
    pub fn igIsItemToggledSelection() -> bool;
}
extern "C" {
    pub fn igGetContentRegionMaxAbs(pOut: *mut ImVec2);
}
extern "C" {
    pub fn igShrinkWidths(
        items: *mut ImGuiShrinkWidthItem,
        count: ::std::os::raw::c_int,
        width_excess: f32,
    );
}
extern "C" {
    pub fn igLogBegin(type_: ImGuiLogType, auto_open_depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igLogToBuffer(auto_open_depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igBeginChildEx(
        name: *const ::std::os::raw::c_char,
        id: ImGuiID,
        size_arg: ImVec2,
        border: bool,
        flags: ImGuiWindowFlags,
    ) -> bool;
}
extern "C" {
    pub fn igOpenPopupEx(id: ImGuiID);
}
extern "C" {
    pub fn igClosePopupToLevel(
        remaining: ::std::os::raw::c_int,
        restore_focus_to_window_under_popup: bool,
    );
}
extern "C" {
    pub fn igClosePopupsOverWindow(
        ref_window: *mut ImGuiWindow,
        restore_focus_to_window_under_popup: bool,
    );
}
extern "C" {
    pub fn igIsPopupOpenID(id: ImGuiID) -> bool;
}
extern "C" {
    pub fn igBeginPopupEx(id: ImGuiID, extra_flags: ImGuiWindowFlags) -> bool;
}
extern "C" {
    pub fn igBeginTooltipEx(extra_flags: ImGuiWindowFlags, tooltip_flags: ImGuiTooltipFlags);
}
extern "C" {
    pub fn igGetTopMostPopupModal() -> *mut ImGuiWindow;
}
extern "C" {
    pub fn igFindBestWindowPosForPopup(pOut: *mut ImVec2, window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igFindBestWindowPosForPopupEx(
        pOut: *mut ImVec2,
        ref_pos: ImVec2,
        size: ImVec2,
        last_dir: *mut ImGuiDir,
        r_outer: ImRect,
        r_avoid: ImRect,
        policy: ImGuiPopupPositionPolicy,
    );
}
extern "C" {
    pub fn igNavInitWindow(window: *mut ImGuiWindow, force_reinit: bool);
}
extern "C" {
    pub fn igNavMoveRequestButNoResultYet() -> bool;
}
extern "C" {
    pub fn igNavMoveRequestCancel();
}
extern "C" {
    pub fn igNavMoveRequestForward(
        move_dir: ImGuiDir,
        clip_dir: ImGuiDir,
        bb_rel: ImRect,
        move_flags: ImGuiNavMoveFlags,
    );
}
extern "C" {
    pub fn igNavMoveRequestTryWrapping(window: *mut ImGuiWindow, move_flags: ImGuiNavMoveFlags);
}
extern "C" {
    pub fn igGetNavInputAmount(n: ImGuiNavInput, mode: ImGuiInputReadMode) -> f32;
}
extern "C" {
    pub fn igGetNavInputAmount2d(
        pOut: *mut ImVec2,
        dir_sources: ImGuiNavDirSourceFlags,
        mode: ImGuiInputReadMode,
        slow_factor: f32,
        fast_factor: f32,
    );
}
extern "C" {
    pub fn igCalcTypematicRepeatAmount(
        t0: f32,
        t1: f32,
        repeat_delay: f32,
        repeat_rate: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igActivateItem(id: ImGuiID);
}
extern "C" {
    pub fn igSetNavID(id: ImGuiID, nav_layer: ::std::os::raw::c_int, focus_scope_id: ImGuiID);
}
extern "C" {
    pub fn igSetNavIDWithRectRel(
        id: ImGuiID,
        nav_layer: ::std::os::raw::c_int,
        focus_scope_id: ImGuiID,
        rect_rel: ImRect,
    );
}
extern "C" {
    pub fn igPushFocusScope(id: ImGuiID);
}
extern "C" {
    pub fn igPopFocusScope();
}
extern "C" {
    pub fn igGetFocusScopeID() -> ImGuiID;
}
extern "C" {
    pub fn igIsActiveIdUsingNavDir(dir: ImGuiDir) -> bool;
}
extern "C" {
    pub fn igIsActiveIdUsingNavInput(input: ImGuiNavInput) -> bool;
}
extern "C" {
    pub fn igIsActiveIdUsingKey(key: ImGuiKey) -> bool;
}
extern "C" {
    pub fn igIsMouseDragPastThreshold(button: ImGuiMouseButton, lock_threshold: f32) -> bool;
}
extern "C" {
    pub fn igIsKeyPressedMap(key: ImGuiKey, repeat: bool) -> bool;
}
extern "C" {
    pub fn igIsNavInputDown(n: ImGuiNavInput) -> bool;
}
extern "C" {
    pub fn igIsNavInputTest(n: ImGuiNavInput, rm: ImGuiInputReadMode) -> bool;
}
extern "C" {
    pub fn igGetMergedKeyModFlags() -> ImGuiKeyModFlags;
}
extern "C" {
    pub fn igBeginDragDropTargetCustom(bb: ImRect, id: ImGuiID) -> bool;
}
extern "C" {
    pub fn igClearDragDrop();
}
extern "C" {
    pub fn igIsDragDropPayloadBeingAccepted() -> bool;
}
extern "C" {
    pub fn igBeginColumns(
        str_id: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        flags: ImGuiColumnsFlags,
    );
}
extern "C" {
    pub fn igEndColumns();
}
extern "C" {
    pub fn igPushColumnClipRect(column_index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn igPushColumnsBackground();
}
extern "C" {
    pub fn igPopColumnsBackground();
}
extern "C" {
    pub fn igGetColumnsID(
        str_id: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> ImGuiID;
}
extern "C" {
    pub fn igFindOrCreateColumns(window: *mut ImGuiWindow, id: ImGuiID) -> *mut ImGuiColumns;
}
extern "C" {
    pub fn igGetColumnOffsetFromNorm(columns: *const ImGuiColumns, offset_norm: f32) -> f32;
}
extern "C" {
    pub fn igGetColumnNormFromOffset(columns: *const ImGuiColumns, offset: f32) -> f32;
}
extern "C" {
    pub fn igBeginTabBarEx(tab_bar: *mut ImGuiTabBar, bb: ImRect, flags: ImGuiTabBarFlags) -> bool;
}
extern "C" {
    pub fn igTabBarFindTabByID(tab_bar: *mut ImGuiTabBar, tab_id: ImGuiID) -> *mut ImGuiTabItem;
}
extern "C" {
    pub fn igTabBarRemoveTab(tab_bar: *mut ImGuiTabBar, tab_id: ImGuiID);
}
extern "C" {
    pub fn igTabBarCloseTab(tab_bar: *mut ImGuiTabBar, tab: *mut ImGuiTabItem);
}
extern "C" {
    pub fn igTabBarQueueChangeTabOrder(
        tab_bar: *mut ImGuiTabBar,
        tab: *const ImGuiTabItem,
        dir: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn igTabItemEx(
        tab_bar: *mut ImGuiTabBar,
        label: *const ::std::os::raw::c_char,
        p_open: *mut bool,
        flags: ImGuiTabItemFlags,
    ) -> bool;
}
extern "C" {
    pub fn igTabItemCalcSize(
        pOut: *mut ImVec2,
        label: *const ::std::os::raw::c_char,
        has_close_button: bool,
    );
}
extern "C" {
    pub fn igTabItemBackground(
        draw_list: *mut ImDrawList,
        bb: ImRect,
        flags: ImGuiTabItemFlags,
        col: ImU32,
    );
}
extern "C" {
    pub fn igTabItemLabelAndCloseButton(
        draw_list: *mut ImDrawList,
        bb: ImRect,
        flags: ImGuiTabItemFlags,
        frame_padding: ImVec2,
        label: *const ::std::os::raw::c_char,
        tab_id: ImGuiID,
        close_button_id: ImGuiID,
    ) -> bool;
}
extern "C" {
    pub fn igRenderText(
        pos: ImVec2,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        hide_text_after_hash: bool,
    );
}
extern "C" {
    pub fn igRenderTextWrapped(
        pos: ImVec2,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        wrap_width: f32,
    );
}
extern "C" {
    pub fn igRenderTextClipped(
        pos_min: ImVec2,
        pos_max: ImVec2,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        text_size_if_known: *const ImVec2,
        align: ImVec2,
        clip_rect: *const ImRect,
    );
}
extern "C" {
    pub fn igRenderTextClippedEx(
        draw_list: *mut ImDrawList,
        pos_min: ImVec2,
        pos_max: ImVec2,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        text_size_if_known: *const ImVec2,
        align: ImVec2,
        clip_rect: *const ImRect,
    );
}
extern "C" {
    pub fn igRenderTextEllipsis(
        draw_list: *mut ImDrawList,
        pos_min: ImVec2,
        pos_max: ImVec2,
        clip_max_x: f32,
        ellipsis_max_x: f32,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        text_size_if_known: *const ImVec2,
    );
}
extern "C" {
    pub fn igRenderFrame(
        p_min: ImVec2,
        p_max: ImVec2,
        fill_col: ImU32,
        border: bool,
        rounding: f32,
    );
}
extern "C" {
    pub fn igRenderFrameBorder(p_min: ImVec2, p_max: ImVec2, rounding: f32);
}
extern "C" {
    pub fn igRenderColorRectWithAlphaCheckerboard(
        draw_list: *mut ImDrawList,
        p_min: ImVec2,
        p_max: ImVec2,
        fill_col: ImU32,
        grid_step: f32,
        grid_off: ImVec2,
        rounding: f32,
        rounding_corners_flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn igRenderNavHighlight(bb: ImRect, id: ImGuiID, flags: ImGuiNavHighlightFlags);
}
extern "C" {
    pub fn igFindRenderedTextEnd(
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn igLogRenderedText(
        ref_pos: *const ImVec2,
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn igRenderArrow(
        draw_list: *mut ImDrawList,
        pos: ImVec2,
        col: ImU32,
        dir: ImGuiDir,
        scale: f32,
    );
}
extern "C" {
    pub fn igRenderBullet(draw_list: *mut ImDrawList, pos: ImVec2, col: ImU32);
}
extern "C" {
    pub fn igRenderCheckMark(draw_list: *mut ImDrawList, pos: ImVec2, col: ImU32, sz: f32);
}
extern "C" {
    pub fn igRenderMouseCursor(
        draw_list: *mut ImDrawList,
        pos: ImVec2,
        scale: f32,
        mouse_cursor: ImGuiMouseCursor,
        col_fill: ImU32,
        col_border: ImU32,
        col_shadow: ImU32,
    );
}
extern "C" {
    pub fn igRenderArrowPointingAt(
        draw_list: *mut ImDrawList,
        pos: ImVec2,
        half_sz: ImVec2,
        direction: ImGuiDir,
        col: ImU32,
    );
}
extern "C" {
    pub fn igRenderRectFilledRangeH(
        draw_list: *mut ImDrawList,
        rect: ImRect,
        col: ImU32,
        x_start_norm: f32,
        x_end_norm: f32,
        rounding: f32,
    );
}
extern "C" {
    pub fn igTextEx(
        text: *const ::std::os::raw::c_char,
        text_end: *const ::std::os::raw::c_char,
        flags: ImGuiTextFlags,
    );
}
extern "C" {
    pub fn igButtonEx(
        label: *const ::std::os::raw::c_char,
        size_arg: ImVec2,
        flags: ImGuiButtonFlags,
    ) -> bool;
}
extern "C" {
    pub fn igCloseButton(id: ImGuiID, pos: ImVec2) -> bool;
}
extern "C" {
    pub fn igCollapseButton(id: ImGuiID, pos: ImVec2) -> bool;
}
extern "C" {
    pub fn igArrowButtonEx(
        str_id: *const ::std::os::raw::c_char,
        dir: ImGuiDir,
        size_arg: ImVec2,
        flags: ImGuiButtonFlags,
    ) -> bool;
}
extern "C" {
    pub fn igScrollbar(axis: ImGuiAxis);
}
extern "C" {
    pub fn igScrollbarEx(
        bb: ImRect,
        id: ImGuiID,
        axis: ImGuiAxis,
        p_scroll_v: *mut f32,
        avail_v: f32,
        contents_v: f32,
        rounding_corners: ImDrawCornerFlags,
    ) -> bool;
}
extern "C" {
    pub fn igGetWindowScrollbarRect(pOut: *mut ImRect, window: *mut ImGuiWindow, axis: ImGuiAxis);
}
extern "C" {
    pub fn igGetWindowScrollbarID(window: *mut ImGuiWindow, axis: ImGuiAxis) -> ImGuiID;
}
extern "C" {
    pub fn igGetWindowResizeID(window: *mut ImGuiWindow, n: ::std::os::raw::c_int) -> ImGuiID;
}
extern "C" {
    pub fn igSeparatorEx(flags: ImGuiSeparatorFlags);
}
extern "C" {
    pub fn igButtonBehavior(
        bb: ImRect,
        id: ImGuiID,
        out_hovered: *mut bool,
        out_held: *mut bool,
        flags: ImGuiButtonFlags,
    ) -> bool;
}
extern "C" {
    pub fn igDragBehavior(
        id: ImGuiID,
        data_type: ImGuiDataType,
        p_v: *mut ::std::os::raw::c_void,
        v_speed: f32,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
        flags: ImGuiDragFlags,
    ) -> bool;
}
extern "C" {
    pub fn igSliderBehavior(
        bb: ImRect,
        id: ImGuiID,
        data_type: ImGuiDataType,
        p_v: *mut ::std::os::raw::c_void,
        p_min: *const ::std::os::raw::c_void,
        p_max: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        power: f32,
        flags: ImGuiSliderFlags,
        out_grab_bb: *mut ImRect,
    ) -> bool;
}
extern "C" {
    pub fn igSplitterBehavior(
        bb: ImRect,
        id: ImGuiID,
        axis: ImGuiAxis,
        size1: *mut f32,
        size2: *mut f32,
        min_size1: f32,
        min_size2: f32,
        hover_extend: f32,
        hover_visibility_delay: f32,
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeBehavior(
        id: ImGuiID,
        flags: ImGuiTreeNodeFlags,
        label: *const ::std::os::raw::c_char,
        label_end: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igTreeNodeBehaviorIsOpen(id: ImGuiID, flags: ImGuiTreeNodeFlags) -> bool;
}
extern "C" {
    pub fn igTreePushOverrideID(id: ImGuiID);
}
extern "C" {
    pub fn igDataTypeGetInfo(data_type: ImGuiDataType) -> *const ImGuiDataTypeInfo;
}
extern "C" {
    pub fn igDataTypeFormatString(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        data_type: ImGuiDataType,
        p_data: *const ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igDataTypeApplyOp(
        data_type: ImGuiDataType,
        op: ::std::os::raw::c_int,
        output: *mut ::std::os::raw::c_void,
        arg_1: *mut ::std::os::raw::c_void,
        arg_2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn igDataTypeApplyOpFromText(
        buf: *const ::std::os::raw::c_char,
        initial_value_buf: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igInputTextEx(
        label: *const ::std::os::raw::c_char,
        hint: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        size_arg: ImVec2,
        flags: ImGuiInputTextFlags,
        callback: ImGuiInputTextCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn igTempInputText(
        bb: ImRect,
        id: ImGuiID,
        label: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        flags: ImGuiInputTextFlags,
    ) -> bool;
}
extern "C" {
    pub fn igTempInputScalar(
        bb: ImRect,
        id: ImGuiID,
        label: *const ::std::os::raw::c_char,
        data_type: ImGuiDataType,
        p_data: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn igTempInputIsActive(id: ImGuiID) -> bool;
}
extern "C" {
    pub fn igGetInputTextState(id: ImGuiID) -> *mut ImGuiInputTextState;
}
extern "C" {
    pub fn igColorTooltip(
        text: *const ::std::os::raw::c_char,
        col: *const f32,
        flags: ImGuiColorEditFlags,
    );
}
extern "C" {
    pub fn igColorEditOptionsPopup(col: *const f32, flags: ImGuiColorEditFlags);
}
extern "C" {
    pub fn igColorPickerOptionsPopup(ref_col: *const f32, flags: ImGuiColorEditFlags);
}
extern "C" {
    pub fn igPlotEx(
        plot_type: ImGuiPlotType,
        label: *const ::std::os::raw::c_char,
        values_getter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                idx: ::std::os::raw::c_int,
            ) -> f32,
        >,
        data: *mut ::std::os::raw::c_void,
        values_count: ::std::os::raw::c_int,
        values_offset: ::std::os::raw::c_int,
        overlay_text: *const ::std::os::raw::c_char,
        scale_min: f32,
        scale_max: f32,
        frame_size: ImVec2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn igShadeVertsLinearColorGradientKeepAlpha(
        draw_list: *mut ImDrawList,
        vert_start_idx: ::std::os::raw::c_int,
        vert_end_idx: ::std::os::raw::c_int,
        gradient_p0: ImVec2,
        gradient_p1: ImVec2,
        col0: ImU32,
        col1: ImU32,
    );
}
extern "C" {
    pub fn igShadeVertsLinearUV(
        draw_list: *mut ImDrawList,
        vert_start_idx: ::std::os::raw::c_int,
        vert_end_idx: ::std::os::raw::c_int,
        a: ImVec2,
        b: ImVec2,
        uv_a: ImVec2,
        uv_b: ImVec2,
        clamp: bool,
    );
}
extern "C" {
    pub fn igGcCompactTransientWindowBuffers(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igGcAwakeTransientWindowBuffers(window: *mut ImGuiWindow);
}
extern "C" {
    pub fn igDebugDrawItemRect(col: ImU32);
}
extern "C" {
    pub fn igDebugStartItemPicker();
}
extern "C" {
    pub fn igImFontAtlasBuildWithStbTruetype(atlas: *mut ImFontAtlas) -> bool;
}
extern "C" {
    pub fn igImFontAtlasBuildInit(atlas: *mut ImFontAtlas);
}
extern "C" {
    pub fn igImFontAtlasBuildSetupFont(
        atlas: *mut ImFontAtlas,
        font: *mut ImFont,
        font_config: *mut ImFontConfig,
        ascent: f32,
        descent: f32,
    );
}
extern "C" {
    pub fn igImFontAtlasBuildPackCustomRects(
        atlas: *mut ImFontAtlas,
        stbrp_context_opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn igImFontAtlasBuildFinish(atlas: *mut ImFontAtlas);
}
extern "C" {
    pub fn igImFontAtlasBuildMultiplyCalcLookupTable(
        out_table: *mut ::std::os::raw::c_uchar,
        in_multiply_factor: f32,
    );
}
extern "C" {
    pub fn igImFontAtlasBuildMultiplyRectAlpha8(
        table: *const ::std::os::raw::c_uchar,
        pixels: *mut ::std::os::raw::c_uchar,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "hand written functions"]
    pub fn igLogText(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ImGuiTextBuffer_appendf(
        buffer: *mut ImGuiTextBuffer,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn igGET_FLT_MAX() -> f32;
}
extern "C" {
    pub fn igColorConvertRGBtoHSV(
        r: f32,
        g: f32,
        b: f32,
        out_h: *mut f32,
        out_s: *mut f32,
        out_v: *mut f32,
    );
}
extern "C" {
    pub fn igColorConvertHSVtoRGB(
        h: f32,
        s: f32,
        v: f32,
        out_r: *mut f32,
        out_g: *mut f32,
        out_b: *mut f32,
    );
}
extern "C" {
    pub fn ImVector_ImWchar_create() -> *mut ImVector_ImWchar;
}
extern "C" {
    pub fn ImVector_ImWchar_destroy(self_: *mut ImVector_ImWchar);
}
extern "C" {
    pub fn ImVector_ImWchar_Init(p: *mut ImVector_ImWchar);
}
extern "C" {
    pub fn ImVector_ImWchar_UnInit(p: *mut ImVector_ImWchar);
}
extern "C" {
    pub fn ImGui_ImplSDL2_InitForOpenGL(
        window: *mut SDL_Window,
        sdl_gl_context: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn ImGui_ImplSDL2_InitForVulkan(window: *mut SDL_Window) -> bool;
}
extern "C" {
    pub fn ImGui_ImplSDL2_InitForD3D(window: *mut SDL_Window) -> bool;
}
extern "C" {
    pub fn ImGui_ImplSDL2_InitForMetal(window: *mut SDL_Window) -> bool;
}
extern "C" {
    pub fn ImGui_ImplSDL2_Shutdown();
}
extern "C" {
    pub fn ImGui_ImplSDL2_NewFrame(window: *mut SDL_Window);
}
extern "C" {
    pub fn ImGui_ImplSDL2_ProcessEvent(event: *const SDL_Event) -> bool;
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_Init(glsl_version: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_Shutdown();
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_NewFrame();
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_RenderDrawData(draw_data: *mut ImDrawData);
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_CreateFontsTexture() -> bool;
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_DestroyFontsTexture();
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_CreateDeviceObjects() -> bool;
}
extern "C" {
    pub fn ImGui_ImplOpenGL3_DestroyDeviceObjects();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = "< Private"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_BlitMap {
    pub _address: u8,
}
